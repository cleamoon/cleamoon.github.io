<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">







<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.yj0.se","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/./public/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script>



<link rel="canonical" href="http://blog.yj0.se/2022/basic-functional-programming-in-scala/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://blog.yj0.se/2022/basic-functional-programming-in-scala/","path":"2022/basic-functional-programming-in-scala/","title":"Basic Functional Programming in Scala"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Basic Functional Programming in Scala | Yue Jiao's blog</title>
  








  <style>:root {
  --body-bg-color: #eee;
  --content-bg-color: #fff;
  --card-bg-color: #f5f5f5;
  --text-color: #555;
  --selection-bg: #262a30;
  --selection-color: #eee;
  --blockquote-color: #666;
  --link-color: #555;
  --link-hover-color: #222;
  --brand-color: #fff;
  --brand-hover-color: #fff;
  --table-row-odd-bg-color: #f9f9f9;
  --table-row-hover-bg-color: #f5f5f5;
  --menu-item-bg-color: #f5f5f5;
  --theme-color: #222;
  --btn-default-bg: #fff;
  --btn-default-color: #555;
  --btn-default-border-color: #555;
  --btn-default-hover-bg: #222;
  --btn-default-hover-color: #fff;
  --btn-default-hover-border-color: #222;
  --highlight-background: #f3f3f3;
  --highlight-foreground: #444;
  --highlight-gutter-background: #e1e1e1;
  --highlight-gutter-foreground: #555;
  color-scheme: light;
}
html {
  line-height: 1.15; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
}
body {
  margin: 0;
}
main {
  display: block;
}
h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
hr {
  box-sizing: content-box; /* 1 */
  height: 0; /* 1 */
  overflow: visible; /* 2 */
}
pre {
  font-family: monospace, monospace; /* 1 */
  font-size: 1em; /* 2 */
}
a {
  background: transparent;
}
abbr[title] {
  border-bottom: none; /* 1 */
  text-decoration: underline; /* 2 */
  text-decoration: underline dotted; /* 2 */
}
b,
strong {
  font-weight: bolder;
}
code,
kbd,
samp {
  font-family: monospace, monospace; /* 1 */
  font-size: 1em; /* 2 */
}
small {
  font-size: 80%;
}
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sub {
  bottom: -0.25em;
}
sup {
  top: -0.5em;
}
img {
  border-style: none;
}
button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-size: 100%; /* 1 */
  line-height: 1.15; /* 1 */
  margin: 0; /* 2 */
}
button,
input {
/* 1 */
  overflow: visible;
}
button,
select {
/* 1 */
  text-transform: none;
}
button,
[type='button'],
[type='reset'],
[type='submit'] {
  -webkit-appearance: button;
}
button::-moz-focus-inner,
[type='button']::-moz-focus-inner,
[type='reset']::-moz-focus-inner,
[type='submit']::-moz-focus-inner {
  border-style: none;
  padding: 0;
}
button:-moz-focusring,
[type='button']:-moz-focusring,
[type='reset']:-moz-focusring,
[type='submit']:-moz-focusring {
  outline: 1px dotted ButtonText;
}
fieldset {
  padding: 0.35em 0.75em 0.625em;
}
legend {
  box-sizing: border-box; /* 1 */
  color: inherit; /* 2 */
  display: table; /* 1 */
  max-width: 100%; /* 1 */
  padding: 0; /* 3 */
  white-space: normal; /* 1 */
}
progress {
  vertical-align: baseline;
}
textarea {
  overflow: auto;
}
[type='checkbox'],
[type='radio'] {
  box-sizing: border-box; /* 1 */
  padding: 0; /* 2 */
}
[type='number']::-webkit-inner-spin-button,
[type='number']::-webkit-outer-spin-button {
  height: auto;
}
[type='search'] {
  outline-offset: -2px; /* 2 */
  -webkit-appearance: textfield; /* 1 */
}
[type='search']::-webkit-search-decoration {
  -webkit-appearance: none;
}
::-webkit-file-upload-button {
  font: inherit; /* 2 */
  -webkit-appearance: button; /* 1 */
}
details {
  display: block;
}
summary {
  display: list-item;
}
template {
  display: none;
}
[hidden] {
  display: none;
}
::selection {
  background: var(--selection-bg);
  color: var(--selection-color);
}
html,
body {
  height: 100%;
}
body {
  background: var(--body-bg-color);
  box-sizing: border-box;
  color: var(--text-color);
  font-family: Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;
  font-size: 1em;
  line-height: 2;
  min-height: 100%;
  position: relative;
  transition: padding 0.2s ease-in-out;
}
h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;
  font-weight: bold;
  line-height: 1.5;
  margin: 30px 0 15px;
}
h1 {
  font-size: 1.5em;
}
h2 {
  font-size: 1.375em;
}
h3 {
  font-size: 1.25em;
}
h4 {
  font-size: 1.125em;
}
h5 {
  font-size: 1em;
}
h6 {
  font-size: 0.875em;
}
p {
  margin: 0 0 20px;
}
a {
  border-bottom: 1px solid #999;
  color: var(--link-color);
  cursor: pointer;
  outline: 0;
  text-decoration: none;
  overflow-wrap: break-word;
}
a:hover {
  border-bottom-color: var(--link-hover-color);
  color: var(--link-hover-color);
}
iframe,
img,
video,
embed {
  display: block;
  margin-left: auto;
  margin-right: auto;
  max-width: 100%;
}
hr {
  background-image: repeating-linear-gradient(-45deg, #ddd, #ddd 4px, transparent 4px, transparent 8px);
  border: 0;
  height: 3px;
  margin: 40px 0;
}
blockquote {
  border-left: 4px solid #ddd;
  color: var(--blockquote-color);
  margin: 0;
  padding: 0 15px;
}
blockquote cite::before {
  content: '-';
  padding: 0 5px;
}
dt {
  font-weight: bold;
}
dd {
  margin: 0;
  padding: 0;
}
.table-container {
  overflow: auto;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
  font-size: 0.875em;
  margin: 0 0 20px;
  width: 100%;
}
tbody tr:nth-of-type(odd) {
  background: var(--table-row-odd-bg-color);
}
tbody tr:hover {
  background: var(--table-row-hover-bg-color);
}
caption,
th,
td {
  padding: 8px;
}
th,
td {
  border: 1px solid #ddd;
  border-bottom: 3px solid #ddd;
}
th {
  font-weight: 700;
  padding-bottom: 10px;
}
td {
  border-bottom-width: 1px;
}
.btn {
  background: var(--btn-default-bg);
  border: 2px solid var(--btn-default-border-color);
  border-radius: 2px;
  color: var(--btn-default-color);
  display: inline-block;
  font-size: 0.875em;
  line-height: 2;
  padding: 0 20px;
  transition: background-color 0.2s ease-in-out;
}
.btn:hover {
  background: var(--btn-default-hover-bg);
  border-color: var(--btn-default-hover-border-color);
  color: var(--btn-default-hover-color);
}
.btn + .btn {
  margin: 0 0 8px 8px;
}
.btn .fa-fw {
  text-align: left;
  width: 1.285714285714286em;
}
.toggle {
  line-height: 0;
}
.toggle .toggle-line {
  background: #fff;
  display: block;
  height: 2px;
  left: 0;
  position: relative;
  top: 0;
  transition: 0.4s;
  transition-property: left, opacity, top, transform, width;
  width: 100%;
}
.toggle .toggle-line:first-child {
  margin-top: 1px;
}
.toggle .toggle-line:not(:first-child) {
  margin-top: 4px;
}
.toggle.toggle-arrow :first-child {
  left: 50%;
  top: 2px;
  transform: rotate(45deg);
  width: 50%;
}
.toggle.toggle-arrow :last-child {
  left: 50%;
  top: -2px;
  transform: rotate(-45deg);
  width: 50%;
}
.toggle.toggle-close :nth-child(2) {
  opacity: 0;
}
.toggle.toggle-close :first-child {
  top: 6px;
  transform: rotate(45deg);
}
.toggle.toggle-close :last-child {
  top: -6px;
  transform: rotate(-45deg);
}
pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1em
}
code.hljs {
  padding: 3px 5px
}
/*!
  Theme: Default
  Description: Original highlight.js style
  Author: (c) Ivan Sagalaev <maniac@softwaremaniacs.org>
  Maintainer: @highlightjs/core-team
  Website: https://highlightjs.org/
  License: see project LICENSE
  Touched: 2021
*/
/*
This is left on purpose making default.css the single file that can be lifted
as-is from the repository directly without the need for a build step

Typically this "required" baseline CSS is added by `makestuff.js` during build.
*/
pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1em
}
code.hljs {
  padding: 3px 5px
}
/* end baseline CSS */
.hljs {
  background: #F3F3F3;
  color: #444
}
/* Base color: saturation 0; */
.hljs-subst {
  /* default */
  
}
/* purposely ignored */
.hljs-formula,
.hljs-attr,
.hljs-property,
.hljs-params {
  
}
.hljs-comment {
  color: #697070
}
.hljs-tag,
.hljs-punctuation {
  color: #444a
}
.hljs-tag .hljs-name,
.hljs-tag .hljs-attr {
  color: #444
}
.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-meta .hljs-keyword,
.hljs-doctag,
.hljs-name {
  font-weight: bold
}
/* User color: hue: 0 */
.hljs-type,
.hljs-string,
.hljs-number,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #880000
}
.hljs-title,
.hljs-section {
  color: #880000;
  font-weight: bold
}
.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-operator,
.hljs-selector-pseudo {
  color: #ab5656
}
/* Language color: hue: 90; */
.hljs-literal {
  color: #695
}
.hljs-built_in,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #397300
}
/* Meta color: hue: 200 */
.hljs-meta {
  color: #1f7199
}
.hljs-meta .hljs-string {
  color: #38a
}
/* Misc effects */
.hljs-emphasis {
  font-style: italic
}
.hljs-strong {
  font-weight: bold
}
code,
kbd,
figure.highlight,
pre {
  background: var(--highlight-background);
  color: var(--highlight-foreground);
}
figure.highlight,
pre {
  line-height: 1.6;
  margin: 0 auto 20px;
}
figure.highlight figcaption,
pre .caption {
  background: var(--highlight-gutter-background);
  color: var(--highlight-foreground);
  display: flow-root;
  font-size: 0.875em;
  line-height: 1.2;
  padding: 0.5em;
}
figure.highlight figcaption a,
pre .caption a {
  color: var(--highlight-foreground);
  float: right;
}
figure.highlight figcaption a:hover,
pre .caption a:hover {
  border-bottom-color: var(--highlight-foreground);
}
pre,
code {
  font-family: consolas, Menlo, monospace, 'PingFang SC', 'Microsoft YaHei';
}
code {
  border-radius: 3px;
  font-size: 0.875em;
  padding: 2px 4px;
  overflow-wrap: break-word;
}
kbd {
  border: 2px solid #ccc;
  border-radius: 0.2em;
  box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1);
  font-family: inherit;
  padding: 0.1em 0.3em;
  white-space: nowrap;
}
figure.highlight {
  overflow: auto;
  position: relative;
}
figure.highlight pre {
  border: 0;
  margin: 0;
  padding: 10px 0;
}
figure.highlight table {
  border: 0;
  margin: 0;
  width: auto;
}
figure.highlight td {
  border: 0;
  padding: 0;
}
figure.highlight .gutter {
  -webkit-user-select: none;
  user-select: none;
}
figure.highlight .gutter pre {
  background: var(--highlight-gutter-background);
  color: var(--highlight-gutter-foreground);
  padding-left: 10px;
  padding-right: 10px;
  text-align: right;
}
figure.highlight .code pre {
  padding-left: 10px;
  width: 100%;
}
figure.highlight .marked {
  background: rgba(0,0,0,0.3);
}
pre .caption {
  margin-bottom: 10px;
}
.gist table {
  width: auto;
}
.gist table td {
  border: 0;
}
pre {
  overflow: auto;
  padding: 10px;
}
pre code {
  background: none;
  padding: 0;
  text-shadow: none;
}
.blockquote-center {
  border-left: 0;
  margin: 40px 0;
  padding: 0;
  position: relative;
  text-align: center;
}
.blockquote-center::before,
.blockquote-center::after {
  left: 0;
  line-height: 1;
  opacity: 0.6;
  position: absolute;
  width: 100%;
}
.blockquote-center::before {
  border-top: 1px solid #ccc;
  text-align: left;
  top: -20px;
  content: '\f10d';
  font-family: 'Font Awesome 6 Free';
  font-weight: 900;
}
.blockquote-center::after {
  border-bottom: 1px solid #ccc;
  bottom: -20px;
  text-align: right;
  content: '\f10e';
  font-family: 'Font Awesome 6 Free';
  font-weight: 900;
}
.blockquote-center p,
.blockquote-center div {
  text-align: center;
}
.group-picture {
  margin-bottom: 20px;
}
.group-picture .group-picture-row {
  display: flex;
  gap: 3px;
  margin-bottom: 3px;
}
.group-picture .group-picture-column {
  flex: 1;
}
.group-picture .group-picture-column img {
  height: 100%;
  margin: 0;
  object-fit: cover;
  width: 100%;
}
.post-body .label {
  color: #555;
  padding: 0 2px;
}
.post-body .label.default {
  background: #f0f0f0;
}
.post-body .label.primary {
  background: #efe6f7;
}
.post-body .label.info {
  background: #e5f2f8;
}
.post-body .label.success {
  background: #e7f4e9;
}
.post-body .label.warning {
  background: #fcf6e1;
}
.post-body .label.danger {
  background: #fae8eb;
}
.post-body .link-grid {
  display: grid;
  grid-gap: 1.5rem;
  gap: 1.5rem;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  margin-bottom: 20px;
  padding: 1rem;
}
.post-body .link-grid .link-grid-container {
  border: solid #ddd;
  box-shadow: 1rem 1rem 0.5rem rgba(0,0,0,0.5);
  min-height: 5rem;
  min-width: 0;
  padding: 0.5rem;
  position: relative;
  transition: background 0.3s;
}
.post-body .link-grid .link-grid-container:hover {
  animation: next-shake 0.5s;
  background: var(--card-bg-color);
}
.post-body .link-grid .link-grid-container:active {
  box-shadow: 0.5rem 0.5rem 0.25rem rgba(0,0,0,0.5);
  transform: translate(0.2rem, 0.2rem);
}
.post-body .link-grid .link-grid-container .link-grid-image {
  border: 1px solid #ddd;
  border-radius: 50%;
  box-sizing: border-box;
  height: 5rem;
  padding: 3px;
  position: absolute;
  width: 5rem;
}
.post-body .link-grid .link-grid-container p {
  margin: 0 1rem 0 6rem;
}
.post-body .link-grid .link-grid-container p:first-of-type {
  font-size: 1.2em;
}
.post-body .link-grid .link-grid-container p:last-of-type {
  font-size: 0.8em;
  line-height: 1.3rem;
  opacity: 0.7;
}
.post-body .link-grid .link-grid-container a {
  border: 0;
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}
@keyframes next-shake {
  0% {
    transform: translate(1pt, 1pt) rotate(0deg);
  }
  10% {
    transform: translate(-1pt, -2pt) rotate(-1deg);
  }
  20% {
    transform: translate(-3pt, 0pt) rotate(1deg);
  }
  30% {
    transform: translate(3pt, 2pt) rotate(0deg);
  }
  40% {
    transform: translate(1pt, -1pt) rotate(1deg);
  }
  50% {
    transform: translate(-1pt, 2pt) rotate(-1deg);
  }
  60% {
    transform: translate(-3pt, 1pt) rotate(0deg);
  }
  70% {
    transform: translate(3pt, 1pt) rotate(-1deg);
  }
  80% {
    transform: translate(-1pt, -1pt) rotate(1deg);
  }
  90% {
    transform: translate(1pt, 2pt) rotate(0deg);
  }
  100% {
    transform: translate(1pt, -2pt) rotate(-1deg);
  }
}
.post-body .note {
  border-radius: 3px;
  margin-bottom: 20px;
  padding: 1em;
  position: relative;
  background: #f5f5f5;
  border: 1px solid transparent;
}
.post-body .note summary {
  cursor: pointer;
  outline: 0;
}
.post-body .note summary p {
  display: inline;
}
.post-body .note h2,
.post-body .note h3,
.post-body .note h4,
.post-body .note h5,
.post-body .note h6 {
  border-bottom: initial;
  margin: 0;
  padding-top: 0;
}
.post-body .note :first-child {
  margin-top: 0;
}
.post-body .note :last-child {
  margin-bottom: 0;
}
.post-body .note.default {
  background: #f3f3f3;
  border-color: #e1e1e1;
  color: #666;
}
.post-body .note.default a:not(.btn) {
  border-bottom-color: #666;
  color: #666;
}
.post-body .note.default a:not(.btn):hover {
  border-bottom-color: #454545;
  color: #454545;
}
.post-body .note.primary {
  background: #f3daff;
  border-color: #e1c2ff;
  color: #6f42c1;
}
.post-body .note.primary a:not(.btn) {
  border-bottom-color: #6f42c1;
  color: #6f42c1;
}
.post-body .note.primary a:not(.btn):hover {
  border-bottom-color: #453298;
  color: #453298;
}
.post-body .note.info {
  background: #d9edf7;
  border-color: #b3e5ef;
  color: #31708f;
}
.post-body .note.info a:not(.btn) {
  border-bottom-color: #31708f;
  color: #31708f;
}
.post-body .note.info a:not(.btn):hover {
  border-bottom-color: #215761;
  color: #215761;
}
.post-body .note.success {
  background: #dff0d8;
  border-color: #d0e6be;
  color: #3c763d;
}
.post-body .note.success a:not(.btn) {
  border-bottom-color: #3c763d;
  color: #3c763d;
}
.post-body .note.success a:not(.btn):hover {
  border-bottom-color: #32562c;
  color: #32562c;
}
.post-body .note.warning {
  background: #fcf4e3;
  border-color: #fae4cd;
  color: #8a6d3b;
}
.post-body .note.warning a:not(.btn) {
  border-bottom-color: #8a6d3b;
  color: #8a6d3b;
}
.post-body .note.warning a:not(.btn):hover {
  border-bottom-color: #714f30;
  color: #714f30;
}
.post-body .note.danger {
  background: #f2dfdf;
  border-color: #ebcdd2;
  color: #a94442;
}
.post-body .note.danger a:not(.btn) {
  border-bottom-color: #a94442;
  color: #a94442;
}
.post-body .note.danger a:not(.btn):hover {
  border-bottom-color: #84333f;
  color: #84333f;
}
.post-body .tabs {
  margin-bottom: 20px;
}
.post-body .tabs,
.tabs-comment {
  padding-top: 10px;
}
.post-body .tabs ul.nav-tabs,
.tabs-comment ul.nav-tabs {
  background: var(--content-bg-color);
  display: flex;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  margin: 0;
  padding: 0;
  position: sticky;
  top: 0;
  z-index: 5;
}
@media (max-width: 413px) {
  .post-body .tabs ul.nav-tabs,
  .tabs-comment ul.nav-tabs {
    display: block;
    margin-bottom: 5px;
  }
}
.post-body .tabs ul.nav-tabs li.tab,
.tabs-comment ul.nav-tabs li.tab {
  border-bottom: 1px solid #ddd;
  border-left: 1px solid transparent;
  border-right: 1px solid transparent;
  border-radius: 0 0 0 0;
  border-top: 3px solid transparent;
  flex-grow: 1;
  list-style-type: none;
}
@media (max-width: 413px) {
  .post-body .tabs ul.nav-tabs li.tab,
  .tabs-comment ul.nav-tabs li.tab {
    border-bottom: 1px solid transparent;
    border-left: 3px solid transparent;
    border-right: 1px solid transparent;
    border-top: 1px solid transparent;
  }
}
@media (max-width: 413px) {
  .post-body .tabs ul.nav-tabs li.tab,
  .tabs-comment ul.nav-tabs li.tab {
    border-radius: 0;
  }
}
.post-body .tabs ul.nav-tabs li.tab a,
.tabs-comment ul.nav-tabs li.tab a {
  border-bottom: initial;
  display: block;
  line-height: 1.8;
  padding: 0.25em 0.75em;
  text-align: center;
  transition: all 0.2s ease-out;
}
.post-body .tabs ul.nav-tabs li.tab a i[class^='fa'],
.tabs-comment ul.nav-tabs li.tab a i[class^='fa'] {
  width: 1.285714285714286em;
}
.post-body .tabs ul.nav-tabs li.tab.active,
.tabs-comment ul.nav-tabs li.tab.active {
  border-bottom-color: transparent;
  border-left-color: #ddd;
  border-right-color: #ddd;
  border-top-color: #fc6423;
}
@media (max-width: 413px) {
  .post-body .tabs ul.nav-tabs li.tab.active,
  .tabs-comment ul.nav-tabs li.tab.active {
    border-bottom-color: #ddd;
    border-left-color: #fc6423;
    border-right-color: #ddd;
    border-top-color: #ddd;
  }
}
.post-body .tabs ul.nav-tabs li.tab.active a,
.tabs-comment ul.nav-tabs li.tab.active a {
  cursor: default;
}
.post-body .tabs .tab-content,
.tabs-comment .tab-content {
  border: 1px solid #ddd;
  border-radius: 0 0 0 0;
  border-top-color: transparent;
}
@media (max-width: 413px) {
  .post-body .tabs .tab-content,
  .tabs-comment .tab-content {
    border-radius: 0;
    border-top-color: #ddd;
  }
}
.post-body .tabs .tab-content .tab-pane,
.tabs-comment .tab-content .tab-pane {
  padding: 20px 20px 0;
}
.post-body .tabs .tab-content .tab-pane:not(.active),
.tabs-comment .tab-content .tab-pane:not(.active) {
  display: none;
}
.pagination .prev,
.pagination .next,
.pagination .page-number,
.pagination .space {
  display: inline-block;
  margin: -1px 10px 0;
  padding: 0 10px;
}
@media (max-width: 767px) {
  .pagination .prev,
  .pagination .next,
  .pagination .page-number,
  .pagination .space {
    margin: 0 5px;
  }
}
.pagination .page-number.current {
  background: #ccc;
  border-color: #ccc;
  color: var(--content-bg-color);
}
.pagination {
  border-top: 1px solid #eee;
  margin: 120px 0 0;
  text-align: center;
}
.pagination .prev,
.pagination .next,
.pagination .page-number {
  border-bottom: 0;
  border-top: 1px solid #eee;
  transition: border-color 0.2s ease-in-out;
}
.pagination .prev:hover,
.pagination .next:hover,
.pagination .page-number:hover {
  border-top-color: var(--link-hover-color);
}
@media (max-width: 767px) {
  .pagination {
    border-top: 0;
  }
  .pagination .prev,
  .pagination .next,
  .pagination .page-number {
    border-bottom: 1px solid #eee;
    border-top: 0;
  }
  .pagination .prev:hover,
  .pagination .next:hover,
  .pagination .page-number:hover {
    border-bottom-color: var(--link-hover-color);
  }
}
.pagination .space {
  margin: 0;
  padding: 0;
}
.comments {
  margin-top: 60px;
  overflow: hidden;
}
.comment-button-group {
  display: flex;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  justify-content: center;
  margin: 1em 0;
}
.comment-button-group .comment-button {
  margin: 0.1em 0.2em;
}
.comment-button-group .comment-button.active {
  background: var(--btn-default-hover-bg);
  border-color: var(--btn-default-hover-border-color);
  color: var(--btn-default-hover-color);
}
.comment-position {
  display: none;
}
.comment-position.active {
  display: block;
}
.tabs-comment {
  margin-top: 4em;
  padding-top: 0;
}
.tabs-comment .comments {
  margin-top: 0;
  padding-top: 0;
}
.headband {
  background: var(--theme-color);
  height: 3px;
}
@media (max-width: 991px) {
  .headband {
    display: none;
  }
}
.site-brand-container {
  display: flex;
  flex-shrink: 0;
  padding: 0 10px;
}
.use-motion .column,
.use-motion .site-brand-container .toggle {
  opacity: 0;
}
.site-meta {
  flex-grow: 1;
  text-align: center;
}
@media (max-width: 767px) {
  .site-meta {
    text-align: center;
  }
}
.custom-logo-image {
  margin-top: 20px;
}
@media (max-width: 991px) {
  .custom-logo-image {
    display: none;
  }
}
.brand {
  border-bottom: 0;
  color: var(--brand-color);
  display: inline-block;
  padding: 0;
}
.brand:hover {
  color: var(--brand-hover-color);
}
.site-title {
  font-family: Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;
  font-size: 1.375em;
  font-weight: normal;
  line-height: 1.5;
  margin: 0;
}
.site-subtitle {
  color: #ddd;
  font-size: 0.8125em;
  margin: 10px 10px 0;
}
.use-motion .site-title,
.use-motion .site-subtitle,
.use-motion .custom-logo-image {
  opacity: 0;
  position: relative;
  top: -10px;
}
.site-nav-toggle,
.site-nav-right {
  display: none;
}
@media (max-width: 767px) {
  .site-nav-toggle,
  .site-nav-right {
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
}
.site-nav-toggle .toggle,
.site-nav-right .toggle {
  color: var(--text-color);
  padding: 10px;
  width: 22px;
}
.site-nav-toggle .toggle .toggle-line,
.site-nav-right .toggle .toggle-line {
  background: var(--text-color);
  border-radius: 1px;
}
@media (max-width: 767px) {
  .site-nav {
    --scroll-height: 0;
    height: 0;
    overflow: hidden;
    transition: 0.2s ease-in-out;
    transition-property: height, visibility;
    visibility: hidden;
  }
  body:not(.site-nav-on) .site-nav .animated {
    animation: none;
  }
  body.site-nav-on .site-nav {
    height: var(--scroll-height);
    visibility: unset;
  }
}
.menu {
  margin: 0;
  padding: 1em 0;
  text-align: center;
}
.menu-item {
  display: inline-block;
  list-style: none;
  margin: 0 10px;
}
@media (max-width: 767px) {
  .menu-item {
    display: block;
    margin-top: 10px;
  }
  .menu-item.menu-item-search {
    display: none;
  }
}
.menu-item a {
  border-bottom: 0;
  display: block;
  font-size: 0.8125em;
  transition: border-color 0.2s ease-in-out;
}
.menu-item a:hover,
.menu-item a.menu-item-active {
  background: var(--menu-item-bg-color);
}
.menu-item i[class^='fa'] {
  margin-right: 8px;
}
.menu-item .badge {
  background: #ccc;
  border-radius: 10px;
  color: var(--content-bg-color);
  font-weight: bold;
  line-height: 1;
  margin-left: 0.35em;
  padding: 2px 5px;
  text-shadow: 1px 1px 0 rgba(0,0,0,0.1);
}
.use-motion .menu-item {
  visibility: hidden;
}
@media (max-width: 991px) {
  .sidebar {
    left: -320px;
  }
  .sidebar-active .sidebar {
    left: 0;
  }
  .sidebar {
    background: #222;
    bottom: 0;
    box-shadow: inset 0 2px 6px #000;
    max-height: 100vh;
    overflow-y: auto;
    position: fixed;
    top: 0;
    transition: 0.2s ease-out;
    transition-property: left, right;
    width: 320px;
    z-index: 20;
  }
  .sidebar a {
    border-bottom-color: #555;
    color: #999;
  }
  .sidebar a:hover {
    border-bottom-color: #eee;
    color: #eee;
  }
  .links-of-author:not(:first-child) {
    margin-top: 15px;
  }
  .links-of-author a {
    border-bottom-color: #555;
    display: inline-block;
    margin-bottom: 10px;
    margin-right: 10px;
    vertical-align: middle;
  }
  .links-of-author a::before {
    background: #f1abff;
    display: inline-block;
    margin-right: 3px;
    transform: translateY(-2px);
    border-radius: 50%;
    content: ' ';
    height: 4px;
    width: 4px;
  }
  .links-of-blogroll-item {
    padding: 0 5px;
  }
  .popular-posts .popular-posts-item .popular-posts-link:hover {
    background: none;
  }
  .sidebar-dimmer {
    background: #000;
    height: 100%;
    left: 0;
    opacity: 0;
    position: fixed;
    top: 0;
    transition: visibility 0.4s, opacity 0.4s;
    visibility: hidden;
    width: 100%;
    z-index: 10;
  }
  .sidebar-active .sidebar-dimmer {
    opacity: 0.7;
    visibility: visible;
  }
}
.sidebar-inner {
  color: #999;
  padding: 18px 10px;
  text-align: center;
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.sidebar-toggle {
  bottom: 61px;
  height: 16px;
  padding: 5px;
  width: 16px;
  background: #222;
  cursor: pointer;
  opacity: 0.6;
  position: fixed;
  z-index: 30;
  left: 30px;
}
@media (max-width: 991px) {
  .sidebar-toggle {
    left: 20px;
  }
}
.sidebar-toggle:hover {
  opacity: 0.8;
}
@media (max-width: 991px) {
  .sidebar-toggle {
    opacity: 0.8;
  }
}
.sidebar-toggle:hover .toggle-line {
  background: #fc6423;
}
@media (any-hover: hover) {
  body:not(.sidebar-active) .sidebar-toggle:hover :first-child {
    left: 50%;
    top: 2px;
    transform: rotate(45deg);
    width: 50%;
  }
  body:not(.sidebar-active) .sidebar-toggle:hover :last-child {
    left: 50%;
    top: -2px;
    transform: rotate(-45deg);
    width: 50%;
  }
}
.sidebar-active .sidebar-toggle :nth-child(2) {
  opacity: 0;
}
.sidebar-active .sidebar-toggle :first-child {
  top: 6px;
  transform: rotate(45deg);
}
.sidebar-active .sidebar-toggle :last-child {
  top: -6px;
  transform: rotate(-45deg);
}
.sidebar-nav {
  font-size: 0.875em;
  height: 0;
  margin: 0;
  overflow: hidden;
  padding-left: 0;
  pointer-events: none;
  transition: 0.2s ease-in-out;
  transition-property: height, visibility;
  visibility: hidden;
}
.sidebar-nav-active .sidebar-nav {
  height: calc(2em + 1px);
  pointer-events: unset;
  visibility: unset;
}
.sidebar-nav li {
  border-bottom: 1px solid transparent;
  color: var(--text-color);
  cursor: pointer;
  display: inline-block;
  transition: 0.2s ease-in-out;
  transition-property: border-bottom-color, color;
}
.sidebar-nav li.sidebar-nav-overview {
  margin-left: 10px;
}
.sidebar-nav li:hover {
  color: #fc6423;
}
.sidebar-toc-active .sidebar-nav-toc,
.sidebar-overview-active .sidebar-nav-overview {
  border-bottom-color: #fc6423;
  color: #fc6423;
  transition-delay: 0.2s;
}
.sidebar-toc-active .sidebar-nav-toc:hover,
.sidebar-overview-active .sidebar-nav-overview:hover {
  color: #fc6423;
}
.sidebar-panel-container {
  align-items: start;
  display: grid;
  flex: 1;
  overflow-x: hidden;
  overflow-y: auto;
  padding-top: 0;
  transition: padding-top 0.2s ease-in-out;
}
.sidebar-nav-active .sidebar-panel-container {
  padding-top: 20px;
}
.sidebar-panel {
  animation: deactivate-sidebar-panel 0.2s ease-in-out;
  grid-area: 1/1;
  height: 0;
  opacity: 0;
  overflow: hidden;
  pointer-events: none;
  transform: translateY(0);
  transition: 0.2s ease-in-out;
  transition-delay: 0s;
  transition-property: opacity, transform, visibility;
  visibility: hidden;
}
.sidebar-nav-active .sidebar-panel,
.sidebar-overview-active .sidebar-panel.post-toc-wrap {
  transform: translateY(-20px);
}
.sidebar-overview-active:not(.sidebar-nav-active) .sidebar-panel.post-toc-wrap {
  transition-delay: 0s, 0.2s, 0s;
}
.sidebar-overview-active .sidebar-panel.site-overview-wrap,
.sidebar-toc-active .sidebar-panel.post-toc-wrap {
  animation-name: activate-sidebar-panel;
  height: auto;
  opacity: 1;
  pointer-events: unset;
  transform: translateY(0);
  transition-delay: 0.2s, 0.2s, 0s;
  visibility: unset;
}
.sidebar-panel.site-overview-wrap {
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 10px;
  justify-content: flex-start;
}
@keyframes deactivate-sidebar-panel {
  from {
    height: var(--inactive-panel-height, 0);
  }
  to {
    height: var(--active-panel-height, 0);
  }
}
@keyframes activate-sidebar-panel {
  from {
    height: var(--inactive-panel-height, auto);
  }
  to {
    height: var(--active-panel-height, auto);
  }
}
.post-toc {
  font-size: 0.875em;
}
.post-toc ol {
  list-style: none;
  margin: 0;
  padding: 0 2px 0 10px;
  text-align: left;
}
.post-toc ol > :last-child {
  margin-bottom: 5px;
}
.post-toc ol > ol {
  padding-left: 0;
}
.post-toc ol a {
  transition: all 0.2s ease-in-out;
}
.post-toc .nav-item {
  line-height: 1.8;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.post-toc .nav .nav-child {
  --height: 0;
  height: 0;
  opacity: 0;
  overflow: hidden;
  transition-property: height, opacity, visibility;
  transition: 0.2s ease-in-out;
  visibility: hidden;
}
.post-toc .nav .active > .nav-child {
  height: var(--height, auto);
  opacity: 1;
  visibility: unset;
}
.post-toc .nav .active > a {
  border-bottom-color: #fc6423;
  color: #fc6423;
}
.post-toc .nav .active-current > a {
  color: #fc6423;
}
.post-toc .nav .active-current > a:hover {
  color: #fc6423;
}
.site-author-image {
  border: 1px solid #eee;
  max-width: 120px;
  padding: 2px;
}
.site-author-name {
  color: var(--text-color);
  font-weight: 600;
  margin: 0;
}
.site-description {
  color: #999;
  font-size: 0.8125em;
  margin-top: 0;
}
.site-state {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  line-height: 1.4;
}
.site-state-item {
  padding: 0 15px;
}
.site-state-item a {
  border-bottom: 0;
  display: block;
}
.site-state-item-count {
  display: block;
  font-size: 1em;
  font-weight: 600;
}
.site-state-item-name {
  color: #999;
  font-size: 0.8125em;
}
.sidebar .sidebar-button:not(:first-child) {
  margin-top: 15px;
}
.sidebar .sidebar-button button {
  background: transparent;
  color: #fc6423;
  cursor: pointer;
  line-height: 2;
  padding: 0 15px;
  border: 1px solid #fc6423;
  border-radius: 4px;
}
.sidebar .sidebar-button button:hover {
  background: #fc6423;
  color: #fff;
}
.sidebar .sidebar-button button i[class^='fa'] {
  margin-right: 5px;
}
.links-of-author a {
  font-size: 0.8125em;
}
.links-of-author i[class^='fa'] {
  margin-right: 2px;
}
.cc-license .cc-opacity {
  border-bottom: 0;
  opacity: 0.7;
}
.cc-license .cc-opacity:hover {
  opacity: 0.9;
}
.cc-license img {
  display: inline-block;
}
.links-of-blogroll {
  font-size: 0.8125em;
}
.links-of-blogroll-title {
  font-size: 0.875em;
  font-weight: 600;
}
.links-of-blogroll-list {
  list-style: none;
  gap: 5px;
  margin: 5px 0 0;
  padding: 0;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  flex-direction: column;
}
.links-of-blogroll-item {
  max-width: calc(100% - 20px);
}
.links-of-blogroll-item a {
  box-sizing: border-box;
  display: inline-block;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.footer {
  color: #999;
  font-size: 0.875em;
  padding: 20px 0;
  transition: 0.2s ease-in-out;
  transition-property: left, right;
}
.footer.footer-fixed {
  bottom: 0;
  left: 0;
  position: absolute;
  right: 0;
}
.footer-inner {
  box-sizing: border-box;
  text-align: center;
  display: flex;
  flex-direction: column;
  justify-content: center;
  margin: 0 auto;
  width: calc(100% - 20px);
}
@media (max-width: 767px) {
  .footer-inner {
    width: auto;
  }
}
@media (min-width: 1200px) {
  .footer-inner {
    width: 1160px;
  }
}
@media (min-width: 1600px) {
  .footer-inner {
    width: 73%;
  }
}
.use-motion .footer {
  opacity: 0;
}
.languages {
  display: inline-block;
  font-size: 1.125em;
  position: relative;
}
.languages .lang-select-label span {
  margin: 0 0.5em;
}
.languages .lang-select {
  height: 100%;
  left: 0;
  opacity: 0;
  position: absolute;
  top: 0;
  width: 100%;
}
.with-love {
  color: ##0000ff;
  display: inline-block;
  margin: 0 5px;
}
@keyframes icon-animate {
  0%, 100% {
    transform: scale(1);
  }
  10%, 30% {
    transform: scale(0.9);
  }
  20%, 40%, 60%, 80% {
    transform: scale(1.1);
  }
  50%, 70% {
    transform: scale(1.1);
  }
}
.back-to-top {
  font-size: 12px;
  align-items: center;
  bottom: -100px;
  color: #fff;
  display: flex;
  height: 26px;
  transition: 0.2s ease-in-out;
  transition-property: bottom;
  background: #222;
  cursor: pointer;
  opacity: 0.6;
  position: fixed;
  z-index: 30;
  left: 30px;
}
.back-to-top span {
  margin-right: 8px;
  display: none;
}
.back-to-top .fa {
  text-align: center;
  width: 26px;
}
@media (max-width: 991px) {
  .back-to-top {
    left: 20px;
  }
}
.back-to-top:hover {
  opacity: 0.8;
}
@media (max-width: 991px) {
  .back-to-top {
    opacity: 0.8;
  }
}
.back-to-top:hover {
  color: #fc6423;
}
.back-to-top.back-to-top-on {
  bottom: 30px;
}
.reading-progress-bar {
  --progress: 0;
  background: #37c6c0;
  height: 3px;
  position: fixed;
  z-index: 50;
  width: var(--progress);
  left: 0;
  bottom: 0;
}
.rtl.post-body p,
.rtl.post-body a,
.rtl.post-body h1,
.rtl.post-body h2,
.rtl.post-body h3,
.rtl.post-body h4,
.rtl.post-body h5,
.rtl.post-body h6,
.rtl.post-body li,
.rtl.post-body ul,
.rtl.post-body ol {
  direction: rtl;
  font-family: UKIJ Ekran;
}
.rtl.post-title {
  font-family: UKIJ Ekran;
}
.post-button {
  margin-top: 40px;
  text-align: center;
}
.use-motion .post-block,
.use-motion .pagination,
.use-motion .comments {
  visibility: hidden;
}
.use-motion .post-header {
  visibility: hidden;
}
.use-motion .post-body {
  visibility: hidden;
}
.use-motion .collection-header {
  visibility: hidden;
}
.posts-collapse .post-content {
  margin-bottom: 35px;
  margin-left: 35px;
  position: relative;
}
@media (max-width: 767px) {
  .posts-collapse .post-content {
    margin-left: 0;
    margin-right: 0;
  }
}
.posts-collapse .post-content .collection-title {
  font-size: 1.125em;
  position: relative;
}
.posts-collapse .post-content .collection-title::before {
  background: #999;
  border: 1px solid #fff;
  margin-left: -6px;
  margin-top: -4px;
  position: absolute;
  top: 50%;
  border-radius: 50%;
  content: ' ';
  height: 10px;
  width: 10px;
}
.posts-collapse .post-content .collection-year {
  font-size: 1.5em;
  font-weight: bold;
  margin: 60px 0;
  position: relative;
}
.posts-collapse .post-content .collection-year .collection-year-count {
  font-size: 0.75em;
  background: #ccc;
  border-radius: 10px;
  color: var(--content-bg-color);
  font-weight: bold;
  line-height: 1;
  margin-left: 0.35em;
  padding: 2px 5px;
  text-shadow: 1px 1px 0 rgba(0,0,0,0.1);
}
.posts-collapse .post-content .collection-year::before {
  background: #bbb;
  margin-left: -4px;
  margin-top: -4px;
  position: absolute;
  top: 50%;
  border-radius: 50%;
  content: ' ';
  height: 8px;
  width: 8px;
}
.posts-collapse .post-content .collection-header {
  display: block;
  margin-left: 20px;
}
.posts-collapse .post-content .collection-header small {
  color: #bbb;
  margin-left: 5px;
}
.posts-collapse .post-content .post-header {
  border-bottom: 1px dashed #ccc;
  margin: 30px 2px 0;
  padding-left: 15px;
  position: relative;
  transition: border 0.2s ease-in-out;
}
.posts-collapse .post-content .post-header::before {
  background: #bbb;
  border: 1px solid #fff;
  left: -6px;
  position: absolute;
  top: 0.75em;
  transition: background 0.2s ease-in-out;
  border-radius: 50%;
  content: ' ';
  height: 6px;
  width: 6px;
}
.posts-collapse .post-content .post-header:hover {
  border-bottom-color: #666;
}
.posts-collapse .post-content .post-header:hover::before {
  background: #222;
}
.posts-collapse .post-content .post-meta-container {
  display: inline;
  font-size: 0.75em;
  margin-right: 10px;
}
.posts-collapse .post-content .post-title {
  display: inline;
}
.posts-collapse .post-content .post-title a {
  border-bottom: 0;
  color: var(--link-color);
}
.posts-collapse .post-content .post-title .fa {
  font-size: 0.875em;
  margin-left: 5px;
}
.posts-collapse .post-content::before {
  background: #f5f5f5;
  content: ' ';
  height: 100%;
  margin-left: -2px;
  position: absolute;
  top: 1.25em;
  width: 4px;
}
.post-body {
  font-family: Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;
  overflow-wrap: break-word;
}
@media (min-width: 1200px) {
  .post-body {
    font-size: 1.125em;
  }
}
@media (min-width: 992px) {
  .post-body {
    text-align: justify;
  }
}
@media (max-width: 991px) {
  .post-body {
    text-align: justify;
  }
}
.post-body h1 .header-anchor,
.post-body h2 .header-anchor,
.post-body h3 .header-anchor,
.post-body h4 .header-anchor,
.post-body h5 .header-anchor,
.post-body h6 .header-anchor,
.post-body h1 .headerlink,
.post-body h2 .headerlink,
.post-body h3 .headerlink,
.post-body h4 .headerlink,
.post-body h5 .headerlink,
.post-body h6 .headerlink {
  border-bottom-style: none;
  color: inherit;
  float: right;
  font-size: 0.875em;
  margin-left: 10px;
  opacity: 0;
}
.post-body h1 .header-anchor::before,
.post-body h2 .header-anchor::before,
.post-body h3 .header-anchor::before,
.post-body h4 .header-anchor::before,
.post-body h5 .header-anchor::before,
.post-body h6 .header-anchor::before,
.post-body h1 .headerlink::before,
.post-body h2 .headerlink::before,
.post-body h3 .headerlink::before,
.post-body h4 .headerlink::before,
.post-body h5 .headerlink::before,
.post-body h6 .headerlink::before {
  content: '\f0c1';
  font-family: 'Font Awesome 6 Free';
  font-weight: 900;
}
.post-body h1:hover .header-anchor,
.post-body h2:hover .header-anchor,
.post-body h3:hover .header-anchor,
.post-body h4:hover .header-anchor,
.post-body h5:hover .header-anchor,
.post-body h6:hover .header-anchor,
.post-body h1:hover .headerlink,
.post-body h2:hover .headerlink,
.post-body h3:hover .headerlink,
.post-body h4:hover .headerlink,
.post-body h5:hover .headerlink,
.post-body h6:hover .headerlink {
  opacity: 0.5;
}
.post-body h1:hover .header-anchor:hover,
.post-body h2:hover .header-anchor:hover,
.post-body h3:hover .header-anchor:hover,
.post-body h4:hover .header-anchor:hover,
.post-body h5:hover .header-anchor:hover,
.post-body h6:hover .header-anchor:hover,
.post-body h1:hover .headerlink:hover,
.post-body h2:hover .headerlink:hover,
.post-body h3:hover .headerlink:hover,
.post-body h4:hover .headerlink:hover,
.post-body h5:hover .headerlink:hover,
.post-body h6:hover .headerlink:hover {
  opacity: 1;
}
.post-body .exturl .fa {
  font-size: 0.875em;
  margin-left: 4px;
}
.post-body figure:not(.highlight) figcaption {
  color: #999;
  font-size: 0.875em;
  font-weight: bold;
  line-height: 1;
  margin: -15px auto 15px;
  text-align: center;
}
.post-body iframe,
.post-body img,
.post-body video,
.post-body embed {
  margin-bottom: 20px;
}
.post-body .video-container {
  height: 0;
  margin-bottom: 20px;
  overflow: hidden;
  padding-top: 75%;
  position: relative;
  width: 100%;
}
.post-body .video-container iframe,
.post-body .video-container object,
.post-body .video-container embed {
  height: 100%;
  left: 0;
  margin: 0;
  position: absolute;
  top: 0;
  width: 100%;
}
.post-gallery {
  display: flex;
  min-height: 200px;
}
.post-gallery .post-gallery-image {
  flex: 1;
}
.post-gallery .post-gallery-image:not(:first-child) {
  clip-path: polygon(40px 0, 100% 0, 100% 100%, 0 100%);
  margin-left: -20px;
}
.post-gallery .post-gallery-image:not(:last-child) {
  margin-right: -20px;
}
.post-gallery .post-gallery-image img {
  height: 100%;
  object-fit: cover;
  opacity: 1;
  width: 100%;
}
.posts-expand .post-gallery {
  margin-bottom: 60px;
}
.posts-collapse .post-gallery {
  margin: 15px 0;
}
.posts-expand .post-header {
  font-size: 1.125em;
  margin-bottom: 60px;
  text-align: center;
}
.posts-expand .post-title {
  font-size: 1.5em;
  font-weight: normal;
  margin: initial;
  overflow-wrap: break-word;
}
.posts-expand .post-title-link {
  border-bottom: 0;
  color: var(--link-color);
  display: inline-block;
  position: relative;
}
.posts-expand .post-title-link::before {
  background: var(--link-color);
  bottom: 0;
  content: '';
  height: 2px;
  left: 0;
  position: absolute;
  transform: scaleX(0);
  transition: transform 0.2s ease-in-out;
  width: 100%;
}
.posts-expand .post-title-link:hover::before {
  transform: scaleX(1);
}
.posts-expand .post-title-link .fa {
  font-size: 0.875em;
  margin-left: 5px;
}
.post-sticky-flag {
  display: inline-block;
  margin-right: 8px;
  transform: rotate(30deg);
}
.posts-expand .post-meta-container {
  color: #999;
  font-family: Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;
  font-size: 0.75em;
  margin-top: 3px;
}
.posts-expand .post-meta-container .post-description {
  font-size: 0.875em;
  margin-top: 2px;
}
.posts-expand .post-meta-container time {
  border-bottom: 1px dashed #999;
}
.post-meta {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}
:not(.post-meta-break) + .post-meta-item::before {
  content: '|';
  margin: 0 0.5em;
}
.post-meta-item-icon {
  margin-right: 3px;
}
@media (max-width: 991px) {
  .post-meta-item-text {
    display: none;
  }
}
.post-meta-break {
  flex-basis: 100%;
  height: 0;
}
.post-nav {
  border-top: 1px solid #eee;
  display: flex;
  gap: 30px;
  justify-content: space-between;
  margin-top: 1em;
  padding: 10px 5px 0;
}
.post-nav-item {
  flex: 1;
}
.post-nav-item a {
  border-bottom: 0;
  display: block;
  font-size: 0.875em;
  line-height: 1.6;
}
.post-nav-item a:active {
  top: 2px;
}
.post-nav-item .fa {
  font-size: 0.75em;
}
.post-nav-item:first-child .fa {
  margin-right: 5px;
}
.post-nav-item:last-child {
  text-align: right;
}
.post-nav-item:last-child .fa {
  margin-left: 5px;
}
.post-footer {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.post-eof {
  background: #ccc;
  height: 1px;
  margin: 80px auto 60px;
  width: 8%;
}
.post-block:last-of-type .post-eof {
  display: none;
}
.post-tags {
  margin-top: 40px;
  text-align: center;
}
.post-tags a {
  display: inline-block;
  font-size: 0.8125em;
}
.post-tags a:not(:last-child) {
  margin-right: 10px;
}
.social-like {
  border-top: 1px solid #eee;
  font-size: 0.875em;
  margin-top: 1em;
  padding-top: 1em;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}
.social-like a {
  border-bottom: none;
}
.reward-container {
  margin: 1em 0 0;
  padding: 1em 0;
  text-align: center;
}
.reward-container button {
  background: transparent;
  color: #fc6423;
  cursor: pointer;
  line-height: 2;
  padding: 0 15px;
  border: 2px solid #fc6423;
  border-radius: 2px;
  outline: 0;
  vertical-align: text-top;
}
.reward-container button:hover {
  background: #fc6423;
  color: #fff;
}
.post-reward {
  display: none;
  padding-top: 20px;
}
.post-reward.active {
  display: block;
}
.post-reward div {
  display: inline-block;
}
.post-reward div span {
  display: block;
}
.post-reward img {
  display: inline-block;
  margin: 0.8em 2em 0;
  max-width: 100%;
  width: 180px;
}
@keyframes next-roll {
  from {
    transform: rotateZ(30deg);
  }
  to {
    transform: rotateZ(-30deg);
  }
}
.category-all-page .category-all-title {
  text-align: center;
}
.category-all-page .category-all {
  margin-top: 20px;
}
.category-all-page .category-list {
  list-style: none;
  margin: 0;
  padding: 0;
}
.category-all-page .category-list-item {
  margin: 5px 10px;
}
.category-all-page .category-list-count {
  font-size: 0.75em;
  background: #ccc;
  border-radius: 10px;
  color: var(--content-bg-color);
  font-weight: bold;
  line-height: 1;
  margin-left: 0.35em;
  padding: 2px 5px;
  text-shadow: 1px 1px 0 rgba(0,0,0,0.1);
}
.category-all-page .category-list-child {
  padding-left: 10px;
}
.event-list hr {
  background: #222;
  margin: 20px 0 45px;
}
.event-list hr::after {
  background: #222;
  color: #fff;
  content: 'NOW';
  display: inline-block;
  font-weight: bold;
  padding: 0 5px;
}
.event-list .event {
  --event-background: #222;
  --event-foreground: #bbb;
  --event-title: #fff;
  background: var(--event-background);
  padding: 15px;
}
.event-list .event .event-summary {
  border-bottom: 0;
  color: var(--event-title);
  margin: 0;
  padding: 0 0 0 35px;
  position: relative;
}
.event-list .event .event-summary::before {
  animation: dot-flash 1s alternate infinite ease-in-out;
  background: var(--event-title);
  left: 0;
  margin-top: -6px;
  position: absolute;
  top: 50%;
  border-radius: 50%;
  content: ' ';
  height: 12px;
  width: 12px;
}
.event-list .event:nth-of-type(odd) .event-summary::before {
  animation-delay: 0.5s;
}
.event-list .event:not(:last-child) {
  margin-bottom: 20px;
}
.event-list .event .event-relative-time {
  color: var(--event-foreground);
  display: inline-block;
  font-size: 12px;
  font-weight: normal;
  padding-left: 12px;
}
.event-list .event .event-details {
  color: var(--event-foreground);
  display: block;
  line-height: 18px;
  padding: 6px 0 6px 35px;
}
.event-list .event .event-details::before {
  color: var(--event-foreground);
  display: inline-block;
  margin-right: 9px;
  width: 14px;
  font-family: 'Font Awesome 6 Free';
  font-weight: 900;
}
.event-list .event .event-details.event-location::before {
  content: '\f041';
}
.event-list .event .event-details.event-duration::before {
  content: '\f017';
}
.event-list .event .event-details.event-description::before {
  content: '\f024';
}
.event-list .event-past {
  --event-background: #f5f5f5;
  --event-foreground: #999;
  --event-title: #222;
}
@keyframes dot-flash {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.8);
  }
}
ul.breadcrumb {
  font-size: 0.75em;
  list-style: none;
  margin: 1em 0;
  padding: 0 2em;
  text-align: center;
}
ul.breadcrumb li {
  display: inline;
}
ul.breadcrumb li:not(:first-child)::before {
  content: '/\00a0';
  font-weight: normal;
  padding: 0.5em;
}
ul.breadcrumb li:last-child {
  font-weight: bold;
}
.tag-cloud {
  text-align: center;
}
.tag-cloud a {
  display: inline-block;
  margin: 10px;
}
.tag-cloud-0 {
  border-bottom-color: #aaa;
  color: #aaa;
}
.tag-cloud-1 {
  border-bottom-color: #9a9a9a;
  color: #9a9a9a;
}
.tag-cloud-2 {
  border-bottom-color: #8b8b8b;
  color: #8b8b8b;
}
.tag-cloud-3 {
  border-bottom-color: #7c7c7c;
  color: #7c7c7c;
}
.tag-cloud-4 {
  border-bottom-color: #6c6c6c;
  color: #6c6c6c;
}
.tag-cloud-5 {
  border-bottom-color: #5d5d5d;
  color: #5d5d5d;
}
.tag-cloud-6 {
  border-bottom-color: #4e4e4e;
  color: #4e4e4e;
}
.tag-cloud-7 {
  border-bottom-color: #3e3e3e;
  color: #3e3e3e;
}
.tag-cloud-8 {
  border-bottom-color: #2f2f2f;
  color: #2f2f2f;
}
.tag-cloud-9 {
  border-bottom-color: #202020;
  color: #202020;
}
.tag-cloud-10 {
  border-bottom-color: #111;
  color: #111;
}
.search-active {
  overflow: hidden;
}
.search-pop-overlay {
  background: rgba(0,0,0,0);
  display: flex;
  height: 100%;
  left: 0;
  position: fixed;
  top: 0;
  transition: visibility 0.4s, background 0.4s;
  visibility: hidden;
  width: 100%;
  z-index: 40;
}
.search-active .search-pop-overlay {
  background: rgba(0,0,0,0.3);
  visibility: visible;
}
.search-popup {
  background: var(--card-bg-color);
  border-radius: 5px;
  height: 80%;
  margin: auto;
  transform: scale(0);
  transition: transform 0.4s;
  width: 700px;
}
.search-active .search-popup {
  transform: scale(1);
}
@media (max-width: 767px) {
  .search-popup {
    border-radius: 0;
    height: 100%;
    width: 100%;
  }
}
.search-popup .search-icon,
.search-popup .popup-btn-close {
  color: #999;
  font-size: 18px;
  padding: 0 10px;
}
.search-popup .popup-btn-close {
  cursor: pointer;
}
.search-popup .popup-btn-close:hover .fa {
  color: #222;
}
.search-popup .search-header {
  background: #eee;
  border-top-left-radius: 5px;
  border-top-right-radius: 5px;
  display: flex;
  padding: 5px;
}
.search-popup input.search-input {
  background: transparent;
  border: 0;
  outline: 0;
  width: 100%;
}
.search-popup input.search-input::-webkit-search-cancel-button {
  display: none;
}
.search-popup .search-result-container {
  display: flex;
  flex-direction: column;
  height: calc(100% - 55px);
  overflow: auto;
  padding: 5px 25px;
}
.search-popup .search-result-container hr {
  flex-shrink: 0;
  margin: 5px 0 10px;
}
.search-popup .search-result-container hr:first-child {
  display: none;
}
.search-popup .search-result-list {
  margin: 0 5px;
  padding: 0;
}
.search-popup a.search-result-title {
  font-weight: bold;
}
.search-popup p.search-result {
  border-bottom: 1px dashed #ccc;
  padding: 5px 0;
}
.search-popup .search-input-container {
  flex-grow: 1;
  padding: 2px;
}
.search-popup .search-result-icon {
  color: #ccc;
  margin: auto;
}
mark.search-keyword {
  background: transparent;
  border-bottom: 1px dashed #ff2a2a;
  color: #ff2a2a;
  font-weight: bold;
}
.use-motion .animated {
  animation-fill-mode: none;
  visibility: inherit;
}
.use-motion .sidebar .animated {
  animation-fill-mode: both;
}
header.header {
  background: var(--content-bg-color);
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);
}
@media (max-width: 991px) {
  header.header {
    border-radius: initial;
  }
}
.main {
  align-items: stretch;
  display: flex;
  justify-content: space-between;
  margin: 0 auto;
  width: calc(100% - 20px);
}
@media (max-width: 767px) {
  .main {
    width: auto;
  }
}
@media (min-width: 1200px) {
  .main {
    width: 1160px;
  }
}
@media (min-width: 1600px) {
  .main {
    width: 73%;
  }
}
@media (max-width: 991px) {
  .main {
    display: block;
    width: auto;
  }
}
.main-inner {
  border-radius: initial;
  box-sizing: border-box;
  width: calc(100% - 252px);
}
@media (max-width: 991px) {
  .main-inner {
    border-radius: initial;
    width: 100%;
  }
}
.footer-inner {
  padding-left: 252px;
}
@media (max-width: 991px) {
  .footer-inner {
    padding-left: 0;
    padding-right: 0;
    width: auto;
  }
}
.column {
  width: 240px;
}
@media (max-width: 991px) {
  .column {
    width: auto;
  }
}
.site-brand-container {
  background: var(--theme-color);
}
@media (max-width: 991px) {
  .site-nav-on .site-brand-container {
    box-shadow: 0 0 16px rgba(0,0,0,0.5);
  }
}
.site-meta {
  padding: 20px 0;
}
@media (min-width: 768px) and (max-width: 991px) {
  .site-nav-toggle,
  .site-nav-right {
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
}
.site-nav-toggle .toggle,
.site-nav-right .toggle {
  color: #fff;
}
.site-nav-toggle .toggle .toggle-line,
.site-nav-right .toggle .toggle-line {
  background: #fff;
}
@media (min-width: 768px) and (max-width: 991px) {
  .site-nav {
    --scroll-height: 0;
    height: 0;
    overflow: hidden;
    transition: 0.2s ease-in-out;
    transition-property: height, visibility;
    visibility: hidden;
  }
  body:not(.site-nav-on) .site-nav .animated {
    animation: none;
  }
  body.site-nav-on .site-nav {
    height: var(--scroll-height);
    visibility: unset;
  }
}
.menu .menu-item {
  display: block;
  margin: 0;
}
.menu .menu-item a {
  padding: 5px 20px;
  position: relative;
  transition-property: background-color;
  display: flex;
  align-items: center;
}
.menu .menu-item a .badge {
  margin-left: auto;
}
@media (max-width: 991px) {
  .menu .menu-item.menu-item-search {
    display: none;
  }
}
.main-menu .menu-item-active::after {
  background: #bbb;
  border-radius: 50%;
  content: ' ';
  height: 6px;
  margin-top: -3px;
  position: absolute;
  right: 15px;
  top: 50%;
  width: 6px;
}
.sub-menu {
  margin: 0;
  padding: 6px 0;
}
.sub-menu .menu-item {
  display: inline-block;
}
.sub-menu .menu-item a {
  background: transparent;
  margin: 5px 10px;
  padding: initial;
}
.sub-menu .menu-item a:hover {
  background: transparent;
  color: #fc6423;
}
.sub-menu .menu-item-active {
  border-bottom-color: #fc6423;
  color: #fc6423;
}
.sub-menu .menu-item-active:hover {
  border-bottom-color: #fc6423;
}
@media (min-width: 992px) {
  .sidebar {
    position: sticky;
    top: 12px;
  }
  .sidebar-toggle {
    display: none;
  }
  .sidebar-inner {
    background: var(--content-bg-color);
    border-radius: initial;
    box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);
    box-sizing: border-box;
    color: var(--text-color);
    margin-top: 12px;
    max-height: calc(100vh - 24px);
  }
  .site-state-item {
    padding: 0 10px;
  }
  .sidebar .sidebar-button {
    border-bottom: 1px dotted #ccc;
    border-top: 1px dotted #ccc;
  }
  .sidebar .sidebar-button button {
    border: 0;
    color: #fc6423;
    display: block;
    width: 100%;
  }
  .sidebar .sidebar-button button:hover {
    background: none;
    border: 0;
    color: #e34603;
  }
  .links-of-author {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
  }
  .links-of-author-item {
    margin: 5px 0 0;
    width: 50%;
  }
  .links-of-author-item a {
    border-bottom: 0;
    border-radius: 4px;
    display: block;
    padding: 0 5px;
    box-sizing: border-box;
    display: inline-block;
    max-width: 100%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .links-of-author-item a:hover {
    background: var(--body-bg-color);
  }
  .links-of-blogroll-item a {
    padding: 0 5px;
  }
}
.main-inner .sub-menu,
.main-inner .post-block,
.main-inner .tabs-comment,
.main-inner > .comments,
.main-inner .comment-position .comments,
.main-inner .pagination {
  background: var(--content-bg-color);
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);
}
.main-inner .post-block:not(:first-child):not(:first-child) {
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);
  margin-top: 12px;
}
@media (min-width: 768px) and (max-width: 991px) {
  .main-inner .post-block:not(:first-child):not(:first-child) {
    margin-top: 10px;
  }
}
@media (max-width: 767px) {
  .main-inner .post-block:not(:first-child):not(:first-child) {
    margin-top: 8px;
  }
}
.main-inner .tabs-comment,
.main-inner > .comments,
.main-inner .comment-position .comments,
.main-inner .pagination {
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);
  margin-top: 12px;
}
@media (min-width: 768px) and (max-width: 991px) {
  .main-inner .tabs-comment,
  .main-inner > .comments,
  .main-inner .comment-position .comments,
  .main-inner .pagination {
    margin-top: 10px;
  }
}
@media (max-width: 767px) {
  .main-inner .tabs-comment,
  .main-inner > .comments,
  .main-inner .comment-position .comments,
  .main-inner .pagination {
    margin-top: 8px;
  }
}
.post-block,
.comments {
  padding: 40px;
}
.post-eof {
  display: none;
}
.pagination {
  border-top: initial;
  padding: 10px 0;
}
.post-body h1,
.post-body h2 {
  border-bottom: 1px solid #eee;
}
.post-body h3 {
  border-bottom: 1px dotted #eee;
}
@media (min-width: 768px) and (max-width: 991px) {
  .main-inner {
    padding: 10px;
  }
  .posts-expand .post-button {
    margin-top: 20px;
  }
  .post-block {
    padding: 20px;
  }
  .comments {
    padding: 10px 20px;
  }
}
@media (max-width: 767px) {
  .main-inner {
    padding: 8px;
  }
  .posts-expand .post-button {
    margin: 12px 0;
  }
  .post-block {
    padding: 12px;
  }
  .comments {
    padding: 10px 12px;
  }
}
</style><noscript>
    
  </noscript>
<link rel="alternate" href="/atom.xml" title="Yue Jiao's blog" type="application/atom+xml">
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"></noscript></head>

<body itemscope="" itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Yue Jiao's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#main-programming-paradigms"><span class="nav-number">1.</span> <span class="nav-text">Main programming paradigms:</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#element-of-programming"><span class="nav-number">1.1.</span> <span class="nav-text">Element of Programming</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#the-substitution-model"><span class="nav-number">1.2.</span> <span class="nav-text">The substitution model</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#call-by-name-and-call-by-value-evaluation-strategies-in-scala"><span class="nav-number">1.2.1.</span> <span class="nav-text">Call-by-name
and call-by-value evaluation strategies in Scala</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#value-definitions-in-scala"><span class="nav-number">1.3.</span> <span class="nav-text">Value definitions in Scala</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#blocks-in-scala"><span class="nav-number">1.4.</span> <span class="nav-text">Blocks in Scala</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#semicolons-in-scala"><span class="nav-number">1.5.</span> <span class="nav-text">Semicolons in Scala</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rewriting-rule"><span class="nav-number">1.6.</span> <span class="nav-text">Rewriting rule</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tail-recursion"><span class="nav-number">1.7.</span> <span class="nav-text">Tail recursion</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#types-and-pattern-matching"><span class="nav-number">2.</span> <span class="nav-text">Types and Pattern Matching</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#decomposition"><span class="nav-number">2.1.</span> <span class="nav-text">Decomposition</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#problems"><span class="nav-number">2.1.1.</span> <span class="nav-text">Problems</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#non-solution-type-tests-and-type-casts"><span class="nav-number">2.1.2.</span> <span class="nav-text">Non-solution: Type tests
and type casts</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-1-object-oriented-decomposition"><span class="nav-number">2.1.3.</span> <span class="nav-text">Solution 1:
Object-oriented decomposition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#solution-2-functional-decomposition-with-pattern-matching"><span class="nav-number">2.1.4.</span> <span class="nav-text">Solution
2: Functional decomposition with Pattern matching</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#case-classes"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">Case classes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pattern-matching"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">Pattern matching</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#forms-of-patterns"><span class="nav-number">2.1.4.2.1.</span> <span class="nav-text">Forms of patterns</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#evaluating-match-expressions"><span class="nav-number">2.1.4.2.2.</span> <span class="nav-text">Evaluating match expressions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pattern-matching-and-methods"><span class="nav-number">2.1.4.2.3.</span> <span class="nav-text">Pattern matching and methods</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lists"><span class="nav-number">2.2.</span> <span class="nav-text">Lists</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#constructors-of-lists"><span class="nav-number">2.2.1.</span> <span class="nav-text">Constructors of lists</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#right-associativity"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">Right associativity</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#operations-on-lists"><span class="nav-number">2.2.2.</span> <span class="nav-text">Operations on Lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list-patterns"><span class="nav-number">2.2.3.</span> <span class="nav-text">List patterns</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sorting-lists"><span class="nav-number">2.2.4.</span> <span class="nav-text">Sorting lists</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#enums"><span class="nav-number">2.3.</span> <span class="nav-text">Enums</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-case-class-hierarchy"><span class="nav-number">2.3.1.</span> <span class="nav-text">A case class hierarchy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#enums-for-adts"><span class="nav-number">2.3.2.</span> <span class="nav-text">Enums for ADTs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pattern-matching-on-adts"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">Pattern matching on ADTs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#simple-enums"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">Simple enums</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pattern-matching-on-simple-enums"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">Pattern matching on simple
enums</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#more-on-enums"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">More on enums</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#domain-modeling"><span class="nav-number">2.3.2.5.</span> <span class="nav-text">Domain modeling</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#subtyping-and-generics"><span class="nav-number">2.4.</span> <span class="nav-text">Subtyping and generics</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#polymorphism"><span class="nav-number">2.4.1.</span> <span class="nav-text">Polymorphism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-bounds"><span class="nav-number">2.4.2.</span> <span class="nav-text">Type bounds</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lower-bounds"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">Lower bounds</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mixed-bounds"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">Mixed bounds</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#covariance"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">Covariance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#the-liskov-substitution-principle"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">The Liskov substitution
principle</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#variance"><span class="nav-number">2.5.</span> <span class="nav-text">Variance</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#definition-of-variance"><span class="nav-number">2.5.1.</span> <span class="nav-text">Definition of variance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typing-rules-for-functions"><span class="nav-number">2.5.2.</span> <span class="nav-text">Typing rules for functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#variance-checks"><span class="nav-number">2.5.3.</span> <span class="nav-text">Variance checks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#variance-and-lists"><span class="nav-number">2.5.4.</span> <span class="nav-text">Variance and lists</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#idealized-lists"><span class="nav-number">2.5.4.1.</span> <span class="nav-text">Idealized lists</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lists-1"><span class="nav-number">3.</span> <span class="nav-text">Lists</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#lists-operations"><span class="nav-number">3.1.</span> <span class="nav-text">Lists operations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sublists-and-element-access"><span class="nav-number">3.1.1.</span> <span class="nav-text">Sublists and element access</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#creating-new-lists"><span class="nav-number">3.1.2.</span> <span class="nav-text">Creating new lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finding-elements"><span class="nav-number">3.1.3.</span> <span class="nav-text">Finding elements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#implementation-of-last"><span class="nav-number">3.1.4.</span> <span class="nav-text">Implementation of last</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#implementation-of-concatenation"><span class="nav-number">3.1.5.</span> <span class="nav-text">Implementation of
concatenation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#implementation-of-reverse"><span class="nav-number">3.1.6.</span> <span class="nav-text">Implementation of
reverse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#implementation-of-flatten"><span class="nav-number">3.1.7.</span> <span class="nav-text">Implementation of
flatten</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tuples-and-generic-methods"><span class="nav-number">3.2.</span> <span class="nav-text">Tuples and generic methods</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pair-and-tuples"><span class="nav-number">3.2.1.</span> <span class="nav-text">Pair and tuples</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#translation-of-tuples"><span class="nav-number">3.2.2.</span> <span class="nav-text">Translation of tuples</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#merge-sort"><span class="nav-number">3.2.3.</span> <span class="nav-text">Merge sort</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#higher-order-list-functions"><span class="nav-number">3.3.</span> <span class="nav-text">Higher-order list functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mapping"><span class="nav-number">3.3.1.</span> <span class="nav-text">Mapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filtering"><span class="nav-number">3.3.2.</span> <span class="nav-text">Filtering</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reduction-of-lists"><span class="nav-number">3.3.3.</span> <span class="nav-text">Reduction of lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#foldleft"><span class="nav-number">3.3.4.</span> <span class="nav-text">FoldLeft</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#implementations-of-reduceleft-and-foldleft"><span class="nav-number">3.3.5.</span> <span class="nav-text">Implementations of
reduceLeft and foldLeft</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#foldright-and-reduceright"><span class="nav-number">3.3.6.</span> <span class="nav-text">FoldRight and ReduceRight</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#difference-between-foldleft-and-foldright"><span class="nav-number">3.3.6.1.</span> <span class="nav-text">Difference between
FoldLeft and FoldRight</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reasoning-about-lists"><span class="nav-number">3.4.</span> <span class="nav-text">Reasoning about lists</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#laws-of-concat"><span class="nav-number">3.4.1.</span> <span class="nav-text">Laws of concat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#referential-transparency"><span class="nav-number">3.4.2.</span> <span class="nav-text">Referential transparency</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#structural-induction"><span class="nav-number">3.4.3.</span> <span class="nav-text">Structural induction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#example"><span class="nav-number">3.4.4.</span> <span class="nav-text">Example</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#other-collections"><span class="nav-number">4.</span> <span class="nav-text">Other Collections</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vectors"><span class="nav-number">4.1.</span> <span class="nav-text">Vectors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#operations-on-vectors"><span class="nav-number">4.1.1.</span> <span class="nav-text">Operations on vectors</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collection-hierarchy"><span class="nav-number">4.2.</span> <span class="nav-text">Collection hierarchy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arrays-and-strings"><span class="nav-number">4.3.</span> <span class="nav-text">Arrays and strings</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ranges"><span class="nav-number">4.4.</span> <span class="nav-text">Ranges</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#some-more-sequence-operations"><span class="nav-number">4.5.</span> <span class="nav-text">Some more sequence
operations:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#example-1"><span class="nav-number">4.5.1.</span> <span class="nav-text">Example 1:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#example-2"><span class="nav-number">4.5.2.</span> <span class="nav-text">Example 2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#combinatorial-search-and-for-expressions"><span class="nav-number">4.6.</span> <span class="nav-text">Combinatorial search
and for-expressions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#handling-nested-sequences"><span class="nav-number">4.6.1.</span> <span class="nav-text">Handling nested sequences</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-expressions"><span class="nav-number">4.6.2.</span> <span class="nav-text">For-expressions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#syntax-of-for"><span class="nav-number">4.6.2.1.</span> <span class="nav-text">Syntax of For</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sets"><span class="nav-number">4.7.</span> <span class="nav-text">Sets</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#maps"><span class="nav-number">4.8.</span> <span class="nav-text">Maps</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#maps-are-iterables."><span class="nav-number">4.8.1.</span> <span class="nav-text">Maps are iterables.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maps-are-functions"><span class="nav-number">4.8.2.</span> <span class="nav-text">Maps are functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#querying-map"><span class="nav-number">4.8.3.</span> <span class="nav-text">Querying map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#updating-maps"><span class="nav-number">4.8.4.</span> <span class="nav-text">Updating maps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sorted-and-groupby"><span class="nav-number">4.8.5.</span> <span class="nav-text">Sorted and groupBy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#default-values"><span class="nav-number">4.8.6.</span> <span class="nav-text">Default values</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#the-option-type"><span class="nav-number">4.9.</span> <span class="nav-text">The Option type</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#decomposing-option"><span class="nav-number">4.9.1.</span> <span class="nav-text">Decomposing Option</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#benefits-of-scalas-immutable-collections"><span class="nav-number">4.10.</span> <span class="nav-text">Benefits of Scala's
immutable collections</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yue Jiao</p>
  <div class="site-description" itemprop="description">Personal blog for idea sharing and archiving.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://blog.yj0.se/2022/basic-functional-programming-in-scala/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yue Jiao">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yue Jiao's blog">
      <meta itemprop="description" content="Personal blog for idea sharing and archiving.">
    </span>

    <span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Basic Functional Programming in Scala | Yue Jiao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Basic Functional Programming in Scala
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-22 14:04:01" itemprop="dateCreated datePublished" datetime="2022-06-22T14:04:01+02:00">2022-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-29 03:00:41" itemprop="dateModified" datetime="2022-07-29T03:00:41+02:00">2022-07-29</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>34k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time ≈</span>
      <span>30 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>A brief introduction to functional programming in Scala.</p>
<span id="more"></span>
<h1 id="main-programming-paradigms">Main programming paradigms:</h1>
<ul>
<li><p>Imperative programming</p>
<ul>
<li><p>Imperative programming is about:</p>
<ul>
<li>Modifying mutable variables</li>
<li>Using assignment</li>
<li>Control structures such as if-then-else, loops, return</li>
</ul></li>
<li><p>The most common informal way to understand imperative programs is
as instruction sequences for a Von Neumann computer</p>
<ul>
<li>There is a strong correspondence between
<ul>
<li>Mutable variables <span class="math inline">\(\approx\)</span>
memory cells</li>
<li>Variable dereference <span class="math inline">\(\approx\)</span>
load instructions</li>
<li>Variable assignment <span class="math inline">\(\approx\)</span>
store instructions</li>
<li>Control structures <span class="math inline">\(\approx\)</span>
jumps</li>
</ul></li>
</ul></li>
<li><p>Problem:</p>
<ul>
<li>Scaling up. How can we avoid conceptualising programs word by
word?</li>
<li>We need other techniques for defining high-level abstractions</li>
<li>Ideally: develop theories of collections, shapes, strings, ...</li>
</ul></li>
<li><p>Theory</p>
<ul>
<li><p>A theory consist of:</p>
<ul>
<li>One or more data types</li>
<li>Operations on these types</li>
<li>Laws that describe the relationships between values and
operations</li>
</ul></li>
<li><p>Normally, a theory does not describe mutations</p>
<ul>
<li><p>For instance the theory of polynomials defines the sum of two
polynomials by law such as:</p>
<p>(a * x + b) + (c * x + d) = (a + c) * x + (b + d)</p>
<p>But it does not define an operator to change a coefficient while
keeping the polynomial the same</p></li>
</ul></li>
<li><p>Consequently, if we want to implement high-level concept
following their mathematical theories, there is no place for
mutation</p>
<ul>
<li>The theories do not admit it</li>
<li>Mutation can destroy useful laws in the theories</li>
<li>Therefore, we want to:
<ul>
<li>Concentrate on defining theories for operators expressed as
functions</li>
<li>Avoid mutations</li>
<li>Have powerful ways to abstract and compose functions</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>Functional programming</p>
<ul>
<li>In a restricted sense, functional programming means programming
without mutable variables, assignments, loops, and other imperative
control structures</li>
<li>In a wider sense, functional programming means focusing on the
functions</li>
<li>In particular, functions can be values that are produced, consumed,
and composed
<ul>
<li>They can be defined anywhere, including inside other functions</li>
<li>Like any other value, they can be passed as parameters to functions
and returned as results</li>
<li>As for other values, there exists a set of operators to compose
functions</li>
</ul></li>
<li>Some functional programming languages
<ul>
<li>In the restricted sense:
<ul>
<li>Pure Lisp, XSLT, XPath, XQuery, FP</li>
<li>Haskell (without I/O Monad or UnsafePerformIO)</li>
</ul></li>
<li>In the wider sense:
<ul>
<li>Lisp, Scheme, Racket, Clojure</li>
<li>SML, Ocaml, F#</li>
<li>Haskell</li>
<li>Scala</li>
<li>Smalltalk, Ruby</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>Logic programming</p></li>
</ul>
<h2 id="element-of-programming">Element of Programming</h2>
<p>Every non-trivial programming language provides:</p>
<ul>
<li>Primitive expressions representing the simplest elements</li>
<li>Ways to combine expressions</li>
<li>Ways to abstract expressions, which introduce a name for an
expression by which it can then be referred to</li>
</ul>
<h2 id="the-substitution-model">The substitution model</h2>
<ul>
<li>The idea underlying this model is that all evaluation does is to
reduce an expression to a value</li>
<li>It can be applied to all expressions, as long as they have no side
effects</li>
<li>The substitution model is formalized in the <span class="math inline">\(\lambda\)</span>-calculus, which gives a
foundation for functional programming</li>
</ul>
<h3 id="call-by-name-and-call-by-value-evaluation-strategies-in-scala">Call-by-name
and call-by-value evaluation strategies in Scala</h3>
<p>Both evaluation evaluation strategies reduce an expression to the
same final values as long as</p>
<ul>
<li>The reduced expression consists of pure functions</li>
<li>Both evaluations terminate</li>
</ul>
<p>Comparison</p>
<ul>
<li>Call-by-value has the advantage that it evaluates every function
argument only once</li>
<li>Call-by-name has the advantage that a function argument is not
evaluated if the corresponding parameter is unused in the evaluation of
the function body</li>
<li>If CBV evaluation of an expression terminates, then CBN evaluation
of the same expression terminates too.</li>
<li>The other direction is not true</li>
</ul>
<p>Scala normally uses call-by-value. But if the type of a function
parameter starts with <code>=&gt;</code> it uses call-by-name.</p>
<p>Example:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">constOne</span></span>(x: <span class="type">Int</span>, y: =&gt; <span class="type">Int</span>) = <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>Then</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constOne(<span class="number">1</span>+<span class="number">2</span>, infiniteLoop)</span><br></pre></td></tr></tbody></table></figure>
<p>will be able to terminate.</p>
<h2 id="value-definitions-in-scala">Value definitions in Scala</h2>
<p>The <code>def</code> form of value definition is "by-name". Its right
hand side is evaluated on each use.</p>
<p>The <code>val</code> form of value definition is "by-value". Its
right hand side is evaluated at the point of the definition itself.
Afterward, the name refers to the value.</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>: <span class="type">Boolean</span> = loop</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span> </span>= loop  	<span class="comment">// this is ok</span></span><br><span class="line"><span class="keyword">val</span> x = loop	<span class="comment">// this will result in infinite loop</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="blocks-in-scala">Blocks in Scala</h2>
<ul>
<li><p>A block is delimited by braces <code>{...}</code></p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="keyword">val</span> x = f(<span class="number">3</span>)</span><br><span class="line"> x * x</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>It contains a sequence of definitions or expressions</p></li>
<li><p>The last element of a block is an expression that defines its
value</p></li>
<li><p>This return expression can be preceded by auxiliary
definitions</p></li>
<li><p>Blocks are themselves expression. A block may appear everywhere
an expression can</p></li>
<li><p>The definitions inside a block are only visible from within the
block</p></li>
<li><p>The definitions inside a block shadow definitions of the same
name outside the block</p></li>
</ul>
<h2 id="semicolons-in-scala">Semicolons in Scala</h2>
<ul>
<li><p>Semicolons at the end of lines are in most cases optional but if
there are more than one statements on a line, they need to be separated
by semicolons</p></li>
<li><p>You could write a multi-line expression in parentheses or write
the operator at the end of the first line. This tells the Scala compiler
that the expression is not yet finished.</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">someLongExpression + </span><br><span class="line">someOtherExpression</span><br><span class="line"></span><br><span class="line">(someLongExpression</span><br><span class="line">+ someOtherExpression)</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="rewriting-rule">Rewriting rule</h2>
<p>Consider the following situation:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(x1, ..., xn) = <span class="type">B</span>; ... f(v1, ..., vn)</span><br></pre></td></tr></tbody></table></figure>
<p>This will be later rewritten as the following</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(x1, ..., xn) = <span class="type">B</span>; ... [v1/x1, ..., vn/xn]<span class="type">B</span></span><br></pre></td></tr></tbody></table></figure>
<p>Here, <code>[v1/x1, ..., vn/xn]B</code> means:</p>
<p>The expression <code>B</code> in which all occurrences of
<code>xi</code> have been replaced by <code>vi</code>.
<code>[v1/x1, ..., vn/xn]</code> is called a substitution.</p>
<h2 id="tail-recursion">Tail recursion</h2>
<ul>
<li><p>Implementation consideration: if a function calls itself as its
last action, the function's stack frame can be reused. This is called
tail recursion. Tail recursive function are iterative
processes.</p></li>
<li><p>In general, if the last action of a function consist of calling a
function (which may be the same), one stack frame would be sufficient
for both functions. Such calls are called tail-calls.</p></li>
<li><p>In Scala, only directly recursive calls to the current function
are optimized</p></li>
<li><p>One can require that a function is tail-recursive using a
<code>@tailrec</code> annotation:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@tailrec</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = ...</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>If the annotation is given, and the implementation of
<code>gcd</code> were not tail recursive, an error would be
issued</p></li>
</ul>
<h1 id="types-and-pattern-matching">Types and Pattern Matching</h1>
<h2 id="decomposition">Decomposition</h2>
<p>Suppose you want to write a small interpreter for arithmetic
expressions. To keep it simple, let's restrict ourselves to numbers and
additions. Expressions can be represented as a class hierarchy, with a
base trait <code>Expr</code> and two subclasses, <code>Number</code> and
<code>Sum</code>. To treat an expression, it's necessary to know the
expression's shape and its components. This brings us to the following
implementation.</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isNumber</span></span>: <span class="type">Boolean</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isSum</span></span>: <span class="type">Boolean</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">numValue</span></span>: <span class="type">Int</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">leftOp</span></span>: <span class="type">Expr</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">rightOp</span></span>: <span class="type">Expr</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isNumber</span> </span>= <span class="literal">true</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isSum</span> </span>= <span class="literal">false</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">numValue</span> </span>= n</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">leftOp</span> </span>= <span class="keyword">throw</span> <span class="type">Error</span>(<span class="string">"Number.leftOp"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">rightOp</span> </span>= <span class="keyword">throw</span> <span class="type">Error</span>(<span class="string">"Number.rightOp"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isNumber</span> </span>= <span class="literal">false</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isSum</span> </span>= <span class="literal">true</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">numValue</span> </span>= <span class="keyword">throw</span> <span class="type">Error</span>(<span class="string">"Sum.numValue"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">leftOp</span> </span>= e1</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">rightOp</span> </span>= e2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(e: <span class="type">Expr</span>): <span class="type">Int</span> = </span><br><span class="line">	<span class="keyword">if</span> e.isNumber <span class="keyword">then</span> e.numValue</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> e.isSum <span class="keyword">then</span> eval(e.leftOp) + eval(e.rightOp)</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">throw</span> <span class="type">Error</span>(<span class="string">"Unknown expression "</span> + e)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="problems">Problems</h3>
<ul>
<li>Writing all these classification and accessor functions quickly
becomes tedious</li>
<li>There is no static guarantee you use the right accessor functions.
You might hit an Error case if you are not careful.</li>
</ul>
<h3 id="non-solution-type-tests-and-type-casts">Non-solution: Type tests
and type casts</h3>
<ul>
<li><p>Scala lets you do these using method defined in class
<code>Any</code>:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isInstanceOf</span></span>[<span class="type">T</span>]: <span class="type">Boolean</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asInstanceOf</span></span>[<span class="type">T</span>]: <span class="type">T</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>These correspond to Java's type tests and casts</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">instanceof</span> T;</span><br><span class="line">(T) x;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>But their use in Scala is discouraged, because there are better
alternatives.</p></li>
</ul>
<h3 id="solution-1-object-oriented-decomposition">Solution 1:
Object-oriented decomposition</h3>
<ul>
<li><p>For example, suppose that all you want to do is evaluate
expressions</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span> = n</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span> = e1.eval + e2.eval</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>But what happens if you'd like to display expressions now? You
have to define new methods in all the subclasses.</p></li>
<li><p>Assessment of OO decomposition</p>
<ul>
<li>OO decomposition mixes data with operations on the data.</li>
<li>This can be the right thing if there's a need for encapsulation and
data abstraction.</li>
<li>On the other hand, it increases complexity and adds new dependencies
to classes.</li>
<li>It makes it easy to add new kinds of data but hard to add new kinds
of operations.</li>
<li>Thus, complexity arises from mixing several things together.</li>
</ul></li>
<li><p>Limitations of OO decomposition</p>
<ul>
<li><p>OO decomposition only works well if operations are on a single
object.</p></li>
<li><p>What is you want to simplify expressions, say using the rule:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a * b + a * c  -&gt; a * (b + c)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Problem: This is a non-local simplification. It cannot be
encapsulated in the method of a single object.</p></li>
<li><p>You are back to square one; you need test and access method sfor
all the different subclasses.</p></li>
</ul></li>
</ul>
<h3 id="solution-2-functional-decomposition-with-pattern-matching">Solution
2: Functional decomposition with Pattern matching</h3>
<p>Observation: the sole purpose of test and accessor functions is to
reverse the construction process:</p>
<ul>
<li>Which subclass was used?</li>
<li>What were the arguments of the constructor?</li>
</ul>
<p>This situation is so common that many functional languages, Scala
included, automate it.</p>
<h4 id="case-classes">Case classes</h4>
<p>A case class definition is similar to a normal class definition,
except that it is preceded by the modifier case. For example:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>These classes are now empty. So how can we access the members?</p>
<h4 id="pattern-matching">Pattern matching</h4>
<p>Pattern matching is a generalization of <code>switch</code> from
C/Java to class hierarchies:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(e: <span class="type">Expr</span>): <span class="type">Int</span> = e <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Sum</span>(e1, e2) =&gt; eval(e1) + eval(e2)</span><br></pre></td></tr></tbody></table></figure>
<p>Rules:</p>
<ul>
<li><code>match</code> is preceded by a selector expression and is
followed by a sequence of <code>cases</code>,
<code>pat =&gt; expr</code>.</li>
<li>Each case associates an expression <code>expr</code> with a pattern
<code>pat</code>.</li>
<li>A <code>MatchError</code> exception is thrown if no pattern matches
the value of the selector.</li>
<li>The compiler creates a <code>.field_i</code> accessor for each
<code>field_i</code> of the case class.</li>
</ul>
<h5 id="forms-of-patterns">Forms of patterns</h5>
<p>Patterns are constructed from:</p>
<ul>
<li><p>Constructors, e.g. <code>Number</code>, <code>Sum</code></p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNumberMessage</span></span>(e: <span class="type">Expr</span>): <span class="type">String</span> = e <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; <span class="string">"This is a number"</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Sum</span>(e1, e2) =&gt; eval(e1) + eval(e2)</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Variables, e.g. <code>e1</code>, <code>e2</code></p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNumberMessage</span></span>(e: <span class="type">Expr</span>): <span class="type">String</span> = e <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; <span class="string">"This is a number"</span></span><br><span class="line">	<span class="keyword">case</span> v =&gt; <span class="string">"This is not a number"</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Variable patterns are often used as fallbacks. For example, in
example above, <code>v</code> is a variable pattern.</li>
<li>Variables always begin with a lowercase letter.</li>
<li>The same variable name can only appear once in a pattern. So,
<code>Sum(x, x)</code> is not a legal pattern.</li>
</ul></li>
<li><p>Wildcard patterns <code>_</code></p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNumber2</span></span>(n: <span class="type">Int</span>): <span class="type">Boolean</span> = e <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p>Constants, e.g. 1, <code>true</code></p>
<ul>
<li>Example as above.</li>
<li>Names of constants begin with a capital letter, with the exception
of the reserved words <code>null</code>, <code>true</code>,
<code>false</code>.</li>
</ul></li>
<li><p>Type tests, e.g. n: <code>Number</code></p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNumber</span></span>(e: <span class="type">Expr</span>): <span class="type">Boolean</span> = e <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> n: <span class="type">Number</span> =&gt; <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h5 id="evaluating-match-expressions">Evaluating match expressions</h5>
<p>An expression of the form</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e <span class="keyword">match</span> {</span><br><span class="line">    <span class="keyword">case</span> p1 =&gt; e1</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> pn =&gt; en</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>matches the value of the selector <code>e</code> with the patterns
<code>p1, ..., pn</code> in the order in which they are written. The
whole match expression is written to the right-hand side of the first
case where the pattern matches the selector <code>e</code>. References
to pattern variables are replaced by the corresponding parts in the
selector.</p>
<p>A constructor pattern <code>C(p1, ..., pn)</code> matches all the
values of type <code>C</code> (or a subtype) that have been constructed
with arguments matching the patterns <code>p1, ..., pn</code>. A
variable pattern <code>x</code> matches any value, and binds the name of
the variable to this value. A constant pattern <code>c</code> matches
values that are equal to <code>c</code> (in the sense of ==).</p>
<h5 id="pattern-matching-and-methods">Pattern matching and methods</h5>
<p>It is possible to define the evaluation function as a method of the
base trait:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span></span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>: <span class="type">Int</span> = <span class="keyword">this</span> <span class="keyword">match</span> </span><br><span class="line">		<span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n</span><br><span class="line">		<span class="keyword">case</span> <span class="type">Sum</span>(e1, e2) =&gt; e1.eval + e2.eval</span><br></pre></td></tr></tbody></table></figure>
<p>Another example:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Var</span>(<span class="params">name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Prod</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span></span>(e: <span class="type">Expr</span>): <span class="type">String</span> = e <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; n.toString</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Sum</span>(e1, e2) =&gt; <span class="string">s"<span class="subst">${show(e1)}</span> + <span class="subst">${show(e2)}</span>"</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Var</span>(x) =&gt; x</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Prod</span>(e1, e2) =&gt;<span class="string">s"<span class="subst">${showP(e1)}</span> * <span class="subst">${showP(e2)}</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showP</span></span>(e: <span class="type">Expr</span>): <span class="type">String</span> = e <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> e: <span class="type">Sum</span> =&gt; <span class="string">s"(<span class="subst">${show(e)}</span>)"</span></span><br><span class="line">	<span class="keyword">case</span> _ =&gt; show(e)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="lists">Lists</h2>
<p>The list is a fundamental data structure in functional programming..
A list having <code>x1, ..., xn</code> as elements is written
<code>List(x1, ..., xn)</code>.</p>
<p>There are two important differences between lists and arrays</p>
<ul>
<li>Lists are immutable - the elements of a list cannot be changed</li>
<li>Lists are recursive, while arrays are flat.</li>
</ul>
<h3 id="constructors-of-lists">Constructors of lists</h3>
<p>All lists are constructed from:</p>
<ul>
<li><p>The empty list <code>Nil</code></p></li>
<li><p>The construction operation <code>::</code> (pronounced
<code>cons</code>)</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">nums2 = <span class="number">1</span> :: (<span class="number">2</span> :: (<span class="number">3</span> :: <span class="number">4</span> :: <span class="type">Nil</span>))</span><br><span class="line">empty = <span class="type">Nil</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="right-associativity">Right associativity</h4>
<p>Convention: operators ending in <code>:</code> associate to the
right. So <code>A :: B :: C</code> is interpreted as
<code>A :: (B :: C)</code>. We can thus omit the parenthesis in the
definition above.</p>
<h3 id="operations-on-lists">Operations on Lists</h3>
<p>All operations on lists can be expressed in terms of the following
three:</p>
<ul>
<li><code>head</code>: the first element of the list</li>
<li><code>tail</code>: the list composed of all the elements except the
first.</li>
<li><code>isEmpty</code>: <code>true</code> if the list is empty,
<code>false</code> otherwise.</li>
</ul>
<p>These operations are defined as methods of objects of type
<code>List</code>. For example:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums.head == <span class="number">1</span></span><br><span class="line">nums.tail == <span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">empty.head == <span class="keyword">throw</span> <span class="type">NoSuchElementException</span>(<span class="string">"head of empty list"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="list-patterns">List patterns</h3>
<p>It is possible to decompose lists with pattern matching:</p>
<ul>
<li><code>Nil</code>: the <code>Nil</code> constant</li>
<li><code>p :: ps</code>: A pattern that matches a list with a head
matching <code>p</code> and a tail matching <code>ps</code>.</li>
<li><code>List(p1, ..., pn)</code>: same as
<code>p1 :: ... :: pn :: Nil</code></li>
</ul>
<h3 id="sorting-lists">Sorting lists</h3>
<p>Suppose we want to sort a list of number in ascending order. The code
below describes insertion sort:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isort</span></span>(xs: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">List</span>[<span class="type">Int</span>] = xs <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">List</span>() =&gt; <span class="type">List</span>()</span><br><span class="line">	<span class="keyword">case</span> y :: ys =&gt; insert(y, isort(ys))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(x: <span class="type">Int</span>, xs: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">List</span>[<span class="type">Int</span>] = xs <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">List</span>() =&gt; <span class="type">List</span>(x)</span><br><span class="line">	<span class="keyword">case</span> y :: ys =&gt; </span><br><span class="line">		<span class="keyword">if</span> x &lt; y <span class="keyword">then</span> x :: xs <span class="keyword">else</span> y :: insert(x, ys)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="enums">Enums</h2>
<p>Sometimes we just need to compose and decompose pure data without any
associated functions. Case classes and pattern matching work well for
this task.</p>
<h3 id="a-case-class-hierarchy">A case class hierarchy</h3>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Exor</span></span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Expr</span></span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Var</span>(<span class="params">s: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line">	<span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line">	<span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line">	<span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Prod</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>This time we have put all case classes in the Expr companion object,
in order not to pollute the global namespace. So it's
<code>Expr.Number(1)</code> instead of <code>Number(1)</code>, for
example. But one can still "pull out" all the cases using an import:
<code>import Expr.*</code>.</p>
<p>Pure data definitions like these are called algebraic data types, or
ADTs for short. They are very common in functional programming. To make
them even more convenient, Scala offers some special syntax.</p>
<h3 id="enums-for-adts">Enums for ADTs</h3>
<p>An enum enumerates all the cases of an ADT and nothing else. For
example:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">Expr</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Var</span>(s: <span class="type">String</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Number</span>(n: <span class="type">Int</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Sum</span>(e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Prod</span>(e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>This enum is equivalent to the case class hierarchy above but is
shorter.</p>
<h4 id="pattern-matching-on-adts">Pattern matching on ADTs</h4>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span></span>(e: <span class="type">Expr</span>): <span class="type">String</span> = e <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Expr</span>.<span class="type">Var</span>(x) =&gt; x</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Expr</span>.<span class="type">Number</span>(n) =&gt; n.toString</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Expr</span>.<span class="type">Sum</span>(a, b) =&gt; <span class="string">s"<span class="subst">${show(a)}</span> + <span class="subst">${show(b)}</span>"</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Expr</span>.<span class="type">Prod</span>(a, b) =&gt; <span class="string">s"<span class="subst">${showP(a)}</span> + <span class="subst">${showP(b)}</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="type">Expr</span>.*</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showP</span></span>(e: <span class="type">Expr</span>): <span class="type">String</span> = e <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> e: <span class="type">Sum</span> =&gt; <span class="string">s"(<span class="subst">${show(e)}</span>)"</span></span><br><span class="line">	<span class="keyword">case</span> _ =&gt; show(e)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="simple-enums">Simple enums</h4>
<p>Cases of an enum can also be simple values, without any parameters.
For example:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">Color</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Red</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Green</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Blue</span></span><br></pre></td></tr></tbody></table></figure>
<p>or shorter:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">Color</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Red</span>, <span class="type">Green</span>, <span class="type">Blue</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="pattern-matching-on-simple-enums">Pattern matching on simple
enums</h4>
<p>For pattern matching, simple cases count as constants:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">DayOfWeek</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Monday</span>, <span class="type">Tuesday</span>, <span class="type">Wednesday</span>, <span class="type">Thursday</span>, <span class="type">Friday</span>, <span class="type">Saturday</span>, <span class="type">Sunday</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="type">DayOfWeek</span>.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isWeekend</span></span>(day: <span class="type">DayOfWeek</span>) = day <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Saturday</span> | <span class="type">Sunday</span> =&gt; <span class="literal">true</span></span><br><span class="line">	<span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="more-on-enums">More on enums</h4>
<p>Enumerations can take parameters and can define methods. For
example:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">Direction</span>(<span class="keyword">val</span> dx: <span class="type">Int</span>, <span class="keyword">val</span> dy: <span class="type">Int</span>):</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Right</span> <span class="keyword">extends</span> <span class="type">Direction</span>( <span class="number">1</span>,  <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Up</span>    <span class="keyword">extends</span> <span class="type">Direction</span>( <span class="number">0</span>,  <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Left</span>  <span class="keyword">extends</span> <span class="type">Direction</span>(<span class="number">-1</span>,  <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Down</span>  <span class="keyword">extends</span> <span class="type">Direction</span>( <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">leftTurn</span> </span>= <span class="type">Direction</span>.values((ordinal + <span class="number">1</span>) % <span class="number">4</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="type">Direction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> r = <span class="type">Direction</span>.<span class="type">Right</span></span><br><span class="line"><span class="keyword">val</span> u = x.leftTurn			<span class="comment">// u = Up</span></span><br><span class="line"><span class="keyword">val</span> v = (u.dx, u.dy)		<span class="comment">// v = (0, 1)</span></span><br></pre></td></tr></tbody></table></figure>
<p>Notes:</p>
<ul>
<li>Enumeration cases that pass parameters have to use an explicit
<code>extends</code> clause</li>
<li>The expression <code>e.ordinal</code> gives the ordinal value of the
enum case <code>e</code>. Cases start with zero and are numbered
consecutively.</li>
<li><code>values</code> is an immutable array in the companion object of
an enum that contains all enum values.</li>
<li>Only simple cases have ordinal numbers and show up in values,
parameterized cases do not.</li>
<li>Enumerations are shorthands for classes and objects</li>
</ul>
<h4 id="domain-modeling">Domain modeling</h4>
<p>ADTs and enums are particularly useful for domain modelling tasks
where one needs to define a large number of data types without attaching
operations. For example modelling payment methods:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="type">PaymentMethod</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="type">CreditCard</span>(kind: <span class="type">Card</span>, holder: <span class="type">String</span>, number: <span class="type">Long</span>, expires: <span class="type">Date</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">PayPal</span>(email: <span class="type">String</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Cash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="type">Card</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Visa</span>, <span class="type">Mastercard</span>, <span class="type">Amex</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="subtyping-and-generics">Subtyping and generics</h2>
<h3 id="polymorphism">Polymorphism</h3>
<p>Two principal forms of polymorphism</p>
<ul>
<li>Subtyping</li>
<li>Generics</li>
</ul>
<h3 id="type-bounds">Type bounds</h3>
<p>Consider the method <code>assertAllPos</code> which</p>
<ul>
<li>takes an <code>IntSet</code></li>
<li>returns the <code>IntSet</code> itself if all its elements are
positive</li>
<li>throws an exception otherwise</li>
</ul>
<p>What would be the best type you can give to
<code>assertAllPos</code>? Maybe:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assertAllPos</span></span>(s: <span class="type">IntSet</span>): <span class="type">IntSet</span></span><br></pre></td></tr></tbody></table></figure>
<p>In most situations this is fine, but can one be more precise? One
might want to express that <code>assertAllPos</code> takes empty sets to
empty sets and non-empty sets to non-empty sets. A way to express this
is:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assertAllPos</span></span>[<span class="type">S</span> &lt;: <span class="type">IntSet</span>](r: <span class="type">S</span>): <span class="type">S</span> = ...</span><br></pre></td></tr></tbody></table></figure>
<p>Here, <code>&lt;: IntSet</code> is an upper bound of the type
parameter <code>S</code>. It means that <code>S</code> can be
instantiated only to types that conform to <code>IntSet</code>.
Generally, the notation:</p>
<ul>
<li><code>S &lt;: T</code> means <code>S</code> is a subtype of
<code>T</code></li>
<li><code>S &gt;: T</code> means <code>S</code> is a supertype of
<code>T</code></li>
</ul>
<h4 id="lower-bounds">Lower bounds</h4>
<p>You can also use a lower bound for a type variable. For example</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">S</span> &gt;: <span class="type">NonEmpty</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>introduces a type parameter <code>S</code> that can range only over
supertypes of <code>NonEmpty</code>. So <code>S</code> could be one of
<code>NonEmpty</code>, <code>IntSet</code>, <code>AnyRef</code>, or
<code>Any</code>.</p>
<h4 id="mixed-bounds">Mixed bounds</h4>
<p>Finally, it is possible to mix a lower bound with an upper bound. For
instance:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">S</span> &gt;: <span class="type">NonEmpty</span> &lt;: <span class="type">IntSet</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>would restrict <code>S</code> any type on the interval between
<code>NonEmpty</code> and <code>IntSet</code>.</p>
<h4 id="covariance">Covariance</h4>
<p>There's another interaction between subtyping and type parameters we
need to consider. Given:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NonEmpty &lt;: IntSet</span><br></pre></td></tr></tbody></table></figure>
<p>is the following true?</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List[NonEmpty] &lt;: List[IntSet]</span><br></pre></td></tr></tbody></table></figure>
<p>Intuitively, this makes sense: A list of non-empty sets is a special
case of a list of arbitrary sets. We call types for which this
relationship holds covariant because their subtyping relationship varies
with the type parameter.</p>
<h4 id="the-liskov-substitution-principle">The Liskov substitution
principle</h4>
<p>The following principle, stated by Barbara Liskov, tells us when a
type can be a subtype of another.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">It A &lt;: B, then everything one can to do with a value of type B one should also be able to do with a value of type A. </span><br></pre></td></tr></tbody></table></figure>
<h2 id="variance">Variance</h2>
<p>You have seen that some types should be covariant whereas others
should not. Roughly speaking, a type that accepts mutations of its
elements should not be covariant. But immutable types can be covariant,
if some conditions on methods are met.</p>
<h3 id="definition-of-variance">Definition of variance</h3>
<p>Say <code>C[T]</code> is a parameterized type and <code>A</code>,
<code>B</code> are types such that <code>A &lt;: B</code>. In general,
there are three possible relationships between <code>C[A]</code> and
<code>C[B]</code>:</p>
<ul>
<li><code>C[A] &lt;: C[B]</code> --&gt; <code>C</code> is covariant</li>
<li><code>C[A] &gt;: C[B]</code> --&gt; <code>C</code> is
contravariant</li>
<li>Neither <code>C[A]</code> nor <code>C[B]</code> is a subtype of the
other --&gt; <code>C</code> is nonvariant</li>
</ul>
<p>Scala lets you declare the variance of a type by annotating the type
parameter:</p>
<ul>
<li><code>class C[+A] {...}</code> --&gt; <code>C</code> is
covariant</li>
<li><code>class C[-A] {...}</code> --&gt; <code>C</code> is
contravariant</li>
<li><code>class C[A] {...}</code> --&gt; <code>C</code> is
nonvariant</li>
</ul>
<h3 id="typing-rules-for-functions">Typing rules for functions</h3>
<p>Generally, we have the following rule for subtyping between function
types: If <code>A2 &lt;: A1</code> and <code>B1 &lt;: B2</code>,
then</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A1</span> =&gt; <span class="type">B1</span> &lt;: <span class="type">A2</span> =&gt; <span class="type">B2</span></span><br></pre></td></tr></tbody></table></figure>
<p>So functions are contravariant in their argument types and covariant
in their result type.</p>
<h3 id="variance-checks">Variance checks</h3>
<p>If we turn <code>Array</code> into a class, and update into a method,
it would look like this:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>[+<span class="type">T</span>]</span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(x: <span class="type">T</span>) = ...</span><br></pre></td></tr></tbody></table></figure>
<p>The problematic combination is</p>
<ul>
<li>the covariant type parameter <code>T</code></li>
<li>which appears in parameter position of the method update.</li>
</ul>
<p>The Scala compiler will check that there are no problematic
combinations when compiling a class with variance annotations.
Roughly,</p>
<ul>
<li>Covariant type parameters can only appear in method results</li>
<li>Contravariant type parameters can only appear in method
parameters</li>
<li>Invariant type parameters can appear annywhere</li>
</ul>
<p>The precise rules are a bit more involved, fortunately the Scala
compiler performs them for us.</p>
<h3 id="variance-and-lists">Variance and lists</h3>
<p>One shortcoming with the previous implementation of lists was that
<code>Nil</code> had to be a class, whereas we would prefer it to be an
object (after all, there is only one empty list). We can change this by
making list covariant:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">List</span>[+<span class="type">T</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">List</span>[<span class="type">Nothing</span>]</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="idealized-lists">Idealized lists</h4>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">List</span>[+<span class="type">T</span>]</span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span> </span>= <span class="keyword">this</span> <span class="keyword">match</span> </span><br><span class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= </span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">recur</span></span>(prefix: <span class="type">String</span>, xs: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">String</span> = xs <span class="keyword">match</span></span><br><span class="line">			<span class="keyword">case</span> x :: xs1 =&gt; <span class="string">s"<span class="subst">$prefix</span><span class="subst">$x</span><span class="subst">${recur(", ", xs1)}</span>"</span></span><br><span class="line">			<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="string">")"</span></span><br><span class="line">		recur(<span class="string">"List("</span>, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> </span>::[+<span class="type">T</span>](head: <span class="type">T</span>, tail: <span class="type">List</span>[<span class="type">T</span>]) <span class="keyword">extends</span> <span class="type">List</span>[<span class="type">T</span>]</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Nil</span> <span class="keyword">extends</span> <span class="title">List</span>[<span class="type">Nothing</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> [<span class="type">T</span>](x: <span class="type">T</span>) <span class="function"><span class="keyword">def</span> </span>:: (xs: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>] = ::(x, xs)</span><br></pre></td></tr></tbody></table></figure>
<p>The need for a lower bound was essentially to decouple the new
parameter of the class and the parameter of the newly created object.
Using an extension method such as in <code>::</code> above, sidesteps
the problem and is often simpler.</p>
<h1 id="lists-1">Lists</h1>
<h2 id="lists-operations">Lists operations</h2>
<h3 id="sublists-and-element-access">Sublists and element access</h3>
<ul>
<li><code>xs.length</code>: The number of elements of
<code>xs</code>.</li>
<li><code>xs.last</code>: The list's last element, exception if
<code>xs</code> is empty.</li>
<li><code>xs.init</code>: A list consisting of all elements of
<code>xs</code> except the last one, exception <code>xs</code> is
empty.</li>
<li><code>xs.drop(n)</code>: The rest of the collection after taking
<code>n</code> elements.</li>
<li><code>xs(n)</code> or <code>xs.apply(n)</code>: The element of
<code>xs</code> at index <code>n</code>.</li>
</ul>
<h3 id="creating-new-lists">Creating new lists</h3>
<ul>
<li><code>xs ++ ys</code>: The list consisting of all elements of
<code>xs</code> followed by all elements of <code>ys</code>.</li>
<li><code>xs.reverse</code>: The list containing the elements of
<code>xs</code> in reversed order.</li>
<li><code>xs.updated(n, x)</code>: The list containing the same elements
as <code>xs</code>, except at index <code>n</code> where it contains
<code>x</code>.</li>
</ul>
<h3 id="finding-elements">Finding elements</h3>
<ul>
<li><code>xs.indexOf(x)</code>: The index of the first element in
<code>xs</code> equal to <code>x</code>, or <code>-1</code> if
<code>x</code> does not appear in <code>xs</code>.</li>
<li><code>xs.contains(x)</code>: same as
<code>xs.indexOf(x) &gt;= 0</code>.</li>
</ul>
<h3 id="implementation-of-last">Implementation of <code>last</code></h3>
<p>The complexity of <code>head</code> is small constant time. What is
the complexity of last? To find out, let's write a possible
implementation of <code>last</code> as a stand-alone function.</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">last</span></span>[<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">T</span> = xs <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">List</span>() =&gt; <span class="keyword">throw</span> <span class="type">Error</span>(<span class="string">"Last of empty list"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">List</span>(x) =&gt; x</span><br><span class="line">	<span class="keyword">case</span> y :: ys =&gt; last(ys)</span><br></pre></td></tr></tbody></table></figure>
<p>So, <code>last</code> takes steps proportional to the length of the
list <code>xs</code>.</p>
<h3 id="implementation-of-concatenation">Implementation of
concatenation</h3>
<p>Let's try to write an extension method for <code>++</code>:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> [<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>])</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">++</span> </span>(ys: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>] = xs <span class="keyword">match</span> </span><br><span class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; ys</span><br><span class="line">		<span class="keyword">case</span> x :: xs1 =&gt; x :: (xs1 ++ ys)</span><br></pre></td></tr></tbody></table></figure>
<p>The complexity of concatenation is <code>O(xs.length)</code></p>
<h3 id="implementation-of-reverse">Implementation of
<code>reverse</code></h3>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> [<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>])</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reverse</span></span>: <span class="type">List</span>[<span class="type">T</span>] = xs <span class="keyword">match</span> </span><br><span class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></span><br><span class="line">		<span class="keyword">case</span> y :: ys =&gt; ys.reverse ++ <span class="type">List</span>(y)</span><br></pre></td></tr></tbody></table></figure>
<p>The complexity of reverse is <code>O(xs.length * xs.length)</code>.
It can be done better.</p>
<h3 id="implementation-of-flatten">Implementation of
<code>flatten</code></h3>
<p>Flatten a list structure which means lists all atoms in nested lists
in a list.</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span></span>(xs: <span class="type">Any</span>): <span class="type">List</span>[<span class="type">Any</span>] = xs <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></span><br><span class="line">	<span class="keyword">case</span> y :: ys =&gt; flatten(y) ++ flatten(ys)</span><br><span class="line">	<span class="keyword">case</span> _ =&gt; xs :: <span class="type">Nil</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="tuples-and-generic-methods">Tuples and generic methods</h2>
<h3 id="pair-and-tuples">Pair and tuples</h3>
<p>The pair consisting of x and y is written as <code>(x, y)</code> in
Scala. Pairs can also be used as patterns:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (label, value) = pair</span><br></pre></td></tr></tbody></table></figure>
<p>This works analogously for tuples with more than two elements. One
could also have written</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> label = pair._1</span><br><span class="line"><span class="keyword">val</span> value = pair._2</span><br></pre></td></tr></tbody></table></figure>
<h3 id="translation-of-tuples">Translation of tuples</h3>
<p>For small <span class="math inline">\(n\)</span>, up to 22 (there is
also a <code>TupleXXL</code> class that handles tuples larger than that
limit), the tuple type <span class="math inline">\((T_1, \dots,
T_n)\)</span> is an abbreviation of the parameterized type <span class="math display">\[
\text{scala.Tuple } n[T_1,\dots, T_n]
\]</span> An tuple expression <span class="math inline">\((e_1,\dots,
e_n)\)</span> is equivalent to the function application <span class="math display">\[
\text{scala.Tuple } n(e_1, \dots, e_n)
\]</span> A tuple pattern <span class="math inline">\((p_1,\dots,
p_n)\)</span> is equivalent to the constructor pattern <span class="math display">\[
\text{scala.Tuple } n(p_1, \dots, p_n)
\]</span></p>
<h3 id="merge-sort">Merge sort</h3>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">msort</span></span>[<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>])(lt: (<span class="type">T</span>,<span class="type">T</span>) =&gt; <span class="type">Boolean</span>) =</span><br><span class="line">	<span class="keyword">val</span> n = xs.length / <span class="number">2</span></span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span> xs</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>[<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>], ys: <span class="type">List</span>[<span class="type">T</span>]) = (xs, ys) <span class="keyword">match</span></span><br><span class="line">            <span class="keyword">case</span> (<span class="type">Nil</span>, ys) =&gt; ys</span><br><span class="line">            <span class="keyword">case</span> (xs, <span class="type">Nil</span>) =&gt; xs</span><br><span class="line">            <span class="keyword">case</span> (x :: xs1, y :: ys1) =&gt; </span><br><span class="line">                <span class="keyword">if</span> lt(x, y) <span class="keyword">then</span> x :: merge(xs1, ys)</span><br><span class="line">                <span class="keyword">else</span> y :: merge(xs, ys1)</span><br><span class="line">		<span class="keyword">val</span> (fst, snd) = xs.splitAt(n)</span><br><span class="line">		merge(msort(fst)(lt), msort(snd)(lt))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="higher-order-list-functions">Higher-order list functions</h2>
<h3 id="mapping">Mapping</h3>
<p>A simple way to define <code>map</code> is as follows:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> [<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>])</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">List</span>[<span class="type">U</span>] = xs <span class="keyword">match</span></span><br><span class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; xs</span><br><span class="line">		<span class="keyword">case</span> x :: xs =&gt; f(x) :: xs.map(f)</span><br></pre></td></tr></tbody></table></figure>
<p>In fact, the actual definition of <code>map</code> is a bit more
complicated, because it is tail-recursive, and also because it works for
arbitrary collections, not just lists. Using <code>map</code>, we can
scale a list by the following code:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scaleList</span></span>(xs: <span class="type">List</span>[<span class="type">Double</span>], factor: <span class="type">Double</span>) = </span><br><span class="line">	xs.map(x =&gt; x * factor)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="filtering">Filtering</h3>
<p>Selection of all elements satisfying a given condition. This pattern
is generalized by the method <code>filter</code> of the List class:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> [<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>])</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">List</span>[<span class="type">T</span>] = xs <span class="keyword">match</span></span><br><span class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; xs</span><br><span class="line">		<span class="keyword">case</span> x :: xs =&gt; <span class="keyword">if</span> p(x) <span class="keyword">then</span> x :: xs.filter(p) <span class="keyword">else</span> xs.filter(p)</span><br></pre></td></tr></tbody></table></figure>
<p>Beside filter, there are also the following methods that extract
sublists based on a predicate:</p>
<ul>
<li><code>xs.filterNot(p)</code>: Same as
<code>xs.filter(x =&gt; !p(x))</code>.</li>
<li><code>xs.partition(p)</code>: Same as
<code>(xs.filter(p), xs.filterNot(p))</code>, but computed in a single
traversal of the list <code>xs.</code></li>
<li><code>xs.takeWhile(p)</code>: The longest prefix of list
<code>xs</code> consisting of elements that all satisfy the predicate
p.</li>
<li><code>xs.dropWhile(p)</code>: The remainder of the list
<code>xs</code> after any leading elements satisfying p have been
removed.</li>
<li><code>xs.span(p)</code>: Same as
<code>(xs.takeWhile(p), xs.dropWhile(p))</code> but computed in a single
traversal of the list <code>xs</code>.</li>
</ul>
<h3 id="reduction-of-lists">Reduction of lists</h3>
<p>Another common operation on lists is to combine the elements of a
list using a given operator. For example:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="type">List</span>(x1, ..., xn))</span><br><span class="line">product(<span class="type">List</span>(x1, ..., xn))</span><br></pre></td></tr></tbody></table></figure>
<p>The pattern can be abstracted out using the generic method
<code>reduceLeft</code>. <code>reduceLeft</code> inserts a given binary
operator between adjacent elements of a list:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(x1, ..., xn).reduceLeft(op) = x1.op(x2). ... .op(xn)</span><br></pre></td></tr></tbody></table></figure>
<p>Using <code>reduceLeft</code>, we can simplify:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(xs: <span class="type">List</span>[<span class="type">Int</span>]) = (<span class="number">0</span> :: xs).reduceLeft((x, y) =&gt; x + y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span></span>(xs: <span class="type">List</span>[<span class="type">Int</span>]) = (<span class="number">1</span> :: xs).reduceLeft((x, y) =&gt; x * y)</span><br></pre></td></tr></tbody></table></figure>
<p>Instead of <code>((x, y) =&gt; x * y)</code>, one can also write
short: <code>(_ * _)</code>. Every <code>_</code> represents a new
parameter, going from left to right. The parameters are defined at the
next outer pair of parentheses (or the whole expression if there are no
enclosing parentheses). So, <code>sum</code> and <code>product</code>
can also be expressed like:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(xs: <span class="type">List</span>[<span class="type">Int</span>]) = (<span class="number">0</span> :: xs).reduceLeft(_ + _)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span></span>(xs: <span class="type">List</span>[<span class="type">Int</span>]) = (<span class="number">1</span> :: xs).reduceLeft(_ * _)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="foldleft">FoldLeft</h3>
<p>The function <code>reduceLeft</code> is defined in terms of a more
general function, <code>foldLeft</code>. <code>foldLeft</code> is like
<code>reduceLeft</code> but takes an accumulator, <code>z</code>, as an
additional parameter, which is returned when <code>foldLeft</code> is
called on an empty list:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(x1, ..., xn).foldLeft(z)(op) = z.op(x1).op(x2). ... .op(xn)</span><br></pre></td></tr></tbody></table></figure>
<p>So, <code>sum</code> and <code>product</code> can also be defined as
follows:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(xs: <span class="type">List</span>[<span class="type">Int</span>]) = xs.foldLeft(<span class="number">0</span>)(_ + _)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span></span>(xs: <span class="type">List</span>[<span class="type">Int</span>]) = xs.foldLeft(<span class="number">1</span>)(_ * _)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="implementations-of-reduceleft-and-foldleft">Implementations of
<code>reduceLeft</code> and <code>foldLeft</code></h3>
<p>They can be implemented in class <code>List</code> as follows:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>[<span class="type">T</span>]</span>:</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reduceLeft</span></span>(op: (<span class="type">T</span>, <span class="type">T</span>) =&gt; <span class="type">T</span>): <span class="type">T</span> = <span class="keyword">this</span> <span class="keyword">match</span></span><br><span class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="keyword">throw</span> <span class="type">IllegalOperationException</span>(<span class="string">"Nil.reduceLeft"</span>)</span><br><span class="line">		<span class="keyword">case</span> x :: xs =&gt; xs.foldLeft(x)(op)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">U</span>](z: <span class="type">U</span>)(op: (<span class="type">U</span>, <span class="type">T</span>) =&gt; <span class="type">U</span>): <span class="type">U</span> = <span class="keyword">this</span> <span class="keyword">match</span></span><br><span class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; z</span><br><span class="line">		<span class="keyword">case</span> x :: xs =&gt; xs.foldLeft(op(z, x))(op)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="foldright-and-reduceright">FoldRight and ReduceRight</h3>
<p>Applications of <code>foldLeft</code> and <code>reduceLeft</code>
unfold on trees that lean to the left. They have two dual functions.
<code>foldRight</code> and <code>reduceRight</code>, which produce trees
which lean to the right. Their implementations:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceRight</span></span>(op:  (<span class="type">T</span>, <span class="type">T</span>) =&gt; <span class="type">T</span>): <span class="type">T</span> = <span class="keyword">this</span> <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Nil</span>      =&gt; <span class="keyword">throw</span> <span class="type">IllegalOperationException</span>(<span class="string">"Nil.reduceRight"</span>)</span><br><span class="line">	<span class="keyword">case</span> x :: <span class="type">Nil</span> =&gt; x</span><br><span class="line">	<span class="keyword">case</span> x :: xs  =&gt; op(x, xs.reduceRight(op))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">U</span>](z: <span class="type">U</span>)(op: (<span class="type">T</span>, <span class="type">U</span>) =&gt; <span class="type">U</span>): <span class="type">U</span> = <span class="keyword">this</span> <span class="keyword">match</span> </span><br><span class="line">	<span class="keyword">case</span> <span class="type">Nil</span>     =&gt; z</span><br><span class="line">	<span class="keyword">case</span> x :: xs =&gt; op(x, xs.foldRight(z))(op)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="difference-between-foldleft-and-foldright">Difference between
FoldLeft and FoldRight</h4>
<p>For operators that are associative and commutative,
<code>foldLeft</code> and <code>foldRight</code> are equivalent (even
though there may be a difference in efficiency). But sometimes, only one
of the two operators is appropriate. For example:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span></span>[<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>] = </span><br><span class="line">	xs.foldLeft(<span class="type">List</span>[<span class="type">T</span>]())((xs, x) =&gt; x :: xs)</span><br></pre></td></tr></tbody></table></figure>
<p>Remark: the type parameter in <code>List[T]()</code> is necessary for
type inference.</p>
<h2 id="reasoning-about-lists">Reasoning about lists</h2>
<h3 id="laws-of-concat">Laws of concat</h3>
<p>Recall the concatenation operation <code>++</code> on lists. We would
like to verify that concatenation is associative, and that it admits the
empty list <code>Nil</code> as neutral element to the left and to the
right. But how can we prove properties like these? We can do it by
structural induction on lists.</p>
<h3 id="referential-transparency">Referential transparency</h3>
<p>A proof can freely apply reduction steps as equalities to some part
of a term. That works because pure functional programs don't have side
effects; so that a term is equivalent to the term to which it reduces.
This principle is called referential transparency.</p>
<h3 id="structural-induction">Structural induction</h3>
<p>The principle of structural induction is analogous to natural
induction:</p>
<p>To prove a property <code>P(xs)</code> for all lists xs,</p>
<ul>
<li>show that <code>P(Nil)</code> holds (base case)</li>
<li>for a list <code>xs</code> and some element <code>x</code>, show the
induction step:
<ul>
<li>If <code>P(xs)</code> holds, then <code>P(x :: xs)</code> also
holds.</li>
</ul></li>
</ul>
<h3 id="example">Example</h3>
<p>Let's show that, for lists <code>xs</code>, <code>ys</code>,
<code>zs</code>:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(xs ++ ys) ++ zs = xs ++ (ys ++ zs)</span><br></pre></td></tr></tbody></table></figure>
<p>To do this, use structural induction on <code>xs</code>. From the
previous implementation of <code>++</code>:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> [<span class="type">T</span>](xs: <span class="type">List</span>[<span class="type">T</span>]):</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">++</span> </span>(ys: <span class="type">List</span>[<span class="type">T</span>]) = xs <span class="keyword">match</span></span><br><span class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; ys</span><br><span class="line">		<span class="keyword">case</span> x :: xs1 =&gt; x :: (xs1 ++ ys)</span><br></pre></td></tr></tbody></table></figure>
<p>distill two defining clauses of <code>++</code>:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">       <span class="type">Nil</span> ++ ys = ys</span><br><span class="line">(x :: xs1) ++ ys = x :: (xs1 ++ ys)</span><br></pre></td></tr></tbody></table></figure>
<h1 id="other-collections">Other Collections</h1>
<h2 id="vectors">Vectors</h2>
<h3 id="operations-on-vectors">Operations on vectors</h3>
<p>Vectors are created analogously to lists</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = <span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-88</span>)</span><br><span class="line"><span class="keyword">val</span> people = <span class="type">Vector</span>(<span class="string">"Bob"</span>, <span class="string">"James"</span>, <span class="string">"Peter"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>They support the same operations as lists, with the exception of
<code>::</code>. Instead of <code>x :: xs</code>, there is</p>
<ul>
<li><code>x +: xs</code>: create a new vector with leading element
<code>x</code>, followed by all elements of <code>xs</code></li>
<li><code>xs :+ x</code>: create a new vector with trailing element
<code>x</code>, preceded by all elements of <code>xs</code></li>
<li>Note that the <code>:</code> always points to the sequence.</li>
</ul>
<h2 id="collection-hierarchy">Collection hierarchy</h2>
<p>A common base class of <code>List</code> and <code>Vector</code> is
<code>Seq</code>, the class of all sequences. <code>Seq</code> itself is
a subclass of <code>Iterable</code>.</p>
<h2 id="arrays-and-strings">Arrays and strings</h2>
<p>Arrays and strings support the same operations as <code>Seq</code>
and can implicitly be converted to sequences where needed. (They cannot
be subclasses of <code>Seq</code> because they come from Java).</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> xs: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">xs.map(x =&gt; <span class="number">2</span> * x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ys: <span class="type">String</span> = <span class="string">"Hello, world!"</span></span><br><span class="line">ys.filter(_.isUpper)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="ranges">Ranges</h2>
<p>Another simple kind of sequence is the range. It represents a
sequence of evenly spaced integers. Three operators: <code>to</code>
(inclusive), <code>until</code> (exclusive), <code>by</code> (to
determine step value):</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> r: <span class="type">Range</span> = <span class="number">1</span> until <span class="number">5</span>		<span class="comment">// 1,2,3,4</span></span><br><span class="line"><span class="keyword">val</span> s: <span class="type">Range</span> = <span class="number">1</span> to <span class="number">5</span>			<span class="comment">// 1,2,3,4,5</span></span><br><span class="line"><span class="number">1</span> to <span class="number">10</span> by <span class="number">3</span>					<span class="comment">// 1,4,7,10</span></span><br><span class="line"><span class="number">6</span> to <span class="number">1</span> by <span class="number">-2</span>					<span class="comment">// 6,4,2</span></span><br></pre></td></tr></tbody></table></figure>
<p>A range is represented as a single object with three fields: lower
bound, upper bound, step value.</p>
<h2 id="some-more-sequence-operations">Some more sequence
operations:</h2>
<ul>
<li><code>xs.exists(p)</code>: true if there is an element
<code>x</code> of <code>xs</code> such that <code>p(x)</code> holds,
false otherwise.</li>
<li><code>xs.forall(p)</code>: true if <code>p(x)</code> holds for all
elements <code>x</code> of <code>xs</code>, false otherwise</li>
<li><code>xs.zip(ys)</code>: A sequence of pairs drawn from
corresponding elements of sequences <code>xs</code> and
<code>ys</code>.</li>
<li><code>xs.unzip</code>: Splits a sequence of pairs <code>xs</code>
into two sequences consisting of the first, respectively second halves
of all pairs.</li>
<li><code>xs.flatMap(f)</code>: Applies collection-valued function
<code>f</code> to all elements of <code>xs</code> and concatenates the
results.</li>
<li><code>xs.sum</code>: The sum of all elements of this numeric
collection.</li>
<li><code>xs.product</code>: The product of all elements of this numeric
collection</li>
<li><code>xs.max</code>: The maximum of all elements of this collection
(an <code>Ordering</code> must exist)</li>
<li><code>xs.min</code>: The minimum of all elements of this
collection.</li>
</ul>
<h3 id="example-1">Example 1:</h3>
<p>To list all combinations of numbers <code>x</code> and <code>y</code>
where <code>x</code> is drawn from <code>1..M</code> and <code>y</code>
is drawn from <code>1..N</code>:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> to <span class="type">M</span>).flatMap(x =&gt; (<span class="number">1</span> to <span class="type">N</span>).map(y =&gt; (x, y)))</span><br></pre></td></tr></tbody></table></figure>
<p>This will return the default <code>Seq</code>:
<code>Vector</code>.</p>
<h3 id="example-2">Example 2</h3>
<p>To compute the scalar product of two vectors:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scalarProduct</span></span>(xs: <span class="type">Vector</span>[<span class="type">Double</span>], ys: <span class="type">Vector</span>[<span class="type">Double</span>]): <span class="type">Double</span> = </span><br><span class="line">	xs.zip(ys).map((x, y) =&gt; x * y).sum</span><br></pre></td></tr></tbody></table></figure>
<p>Note that there is some automatic decomposition going on here. Each
pair of elements from <code>xs</code> and <code>ys</code> is split into
its halves which are then passed as the <code>x</code> and
<code>y</code> parameters to the lambda.</p>
<h2 id="combinatorial-search-and-for-expressions">Combinatorial search
and for-expressions</h2>
<h3 id="handling-nested-sequences">Handling nested sequences</h3>
<p>We can extend the usage of higher order functions on sequences to
many calculations which are usually expressed using nested loops. For
example, given a positive integer <code>n</code>, find all pairs of
positive integers <code>i</code> and <code>j</code>, with
<code>i &lt;= j &lt; i &lt; n</code> such that <code>i + j</code> is
prime.</p>
<p>A natural way to do this is to</p>
<ul>
<li>Generate the sequence of all pairs of integers
<code>(i, j)</code></li>
<li>Filter the pairs for which <code>i + j</code> is prime</li>
</ul>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> until n)</span><br><span class="line">	.flatMap(i =&gt; (<span class="number">1</span> until i).map(j =&gt; (i, j)))</span><br><span class="line">	.filter((x, y) =&gt; isPrime(x + y))</span><br></pre></td></tr></tbody></table></figure>
<p>This works, but make most people's head hurt.</p>
<h3 id="for-expressions">For-expressions</h3>
<p>Let <code>persons</code> be a list of elements of class
<code>Person</code>, with fields <code>name</code> and
<code>age</code>.</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></tbody></table></figure>
<p>To obtain the names of persons over 20 years old, you can write:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> p &lt;- persons <span class="keyword">if</span> p.age &gt; <span class="number">20</span> <span class="keyword">yield</span> p.name</span><br></pre></td></tr></tbody></table></figure>
<p>which is equivalent to:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">persons</span><br><span class="line">	.filter(p =&gt; p.age &gt; <span class="number">20</span>)</span><br><span class="line">	.map(p =&gt; p.name)</span><br></pre></td></tr></tbody></table></figure>
<p>The for-expression is similar to loops in imperative languages,
except that it builds a list of the results of all iterations.</p>
<h4 id="syntax-of-for">Syntax of For</h4>
<p>A for-expression is of the form</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> s <span class="keyword">yield</span> e</span><br></pre></td></tr></tbody></table></figure>
<p>where <code>s</code> is a sequence of generators and filters, and
<code>e</code> is an expression whose value is returned by an
iteration.</p>
<ul>
<li>A generator is of the form <code>p &lt;- e</code>, where
<code>p</code> is a pattern and <code>e</code> an expression whose value
is a collection.</li>
<li>A filter is of the form <code>if f</code> where <code>f</code> is a
boolean expression.</li>
<li>The sequence must start with a generator.</li>
<li>If there are several generators in the sequence, the last generators
vary faster than the first.</li>
</ul>
<p>Then the previous problem can be solved by the following code:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> </span><br><span class="line">	i &lt;- <span class="number">1</span> until n</span><br><span class="line">	j &lt;- <span class="number">1</span> until i</span><br><span class="line">	<span class="keyword">if</span> isPrime(i + j)</span><br><span class="line"><span class="keyword">yield</span> (i, j)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="sets">Sets</h2>
<p>A set is written analogously to a sequence:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fruit = <span class="type">Set</span>(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>)</span><br><span class="line"><span class="keyword">val</span> s = (<span class="number">1</span> to <span class="number">6</span>).toSet</span><br></pre></td></tr></tbody></table></figure>
<p>Most operations on sequences are also available on sets, for example,
<code>map</code>, <code>filter</code> and <code>nonEmpty</code>.</p>
<p>The principal differences between sets and sequences are:</p>
<ol type="1">
<li>Sets are unordered; the elements of a set do not have a predefined
order in which they appear in the set.</li>
<li>Sets do not have duplicate elements</li>
<li>The fundamental operation on sets is contains</li>
</ol>
<p>For example: N-queen problem</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">queens</span></span>(n: <span class="type">Int</span>) =</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">checks</span></span>(col: <span class="type">Int</span>, delta: <span class="type">Int</span>, queens: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Boolean</span> = queens <span class="keyword">match</span></span><br><span class="line">		<span class="keyword">case</span> qcol :: others =&gt; </span><br><span class="line">			qcol == col</span><br><span class="line">			|| (qcol - col).abs == delta</span><br><span class="line">			|| checks(col, delta + <span class="number">1</span>, others)</span><br><span class="line">		<span class="keyword">case</span> <span class="type">Nil</span> =&gt; </span><br><span class="line">			<span class="literal">false</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isSafe</span></span>(col: <span class="type">Int</span>, queens: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">Boolean</span> = </span><br><span class="line">		!checks(col, <span class="number">1</span>, queens)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">placeQueens</span></span>(k: <span class="type">Int</span>): <span class="type">Set</span>[<span class="type">List</span>[<span class="type">Int</span>]] = </span><br><span class="line">		<span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">then</span> <span class="type">Set</span>(<span class="type">List</span>())</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">for</span></span><br><span class="line">				queens &lt;- placeQueens(k - <span class="number">1</span>)</span><br><span class="line">				col &lt;- <span class="number">0</span> until n</span><br><span class="line">				<span class="keyword">if</span> isSafe(col, queens)</span><br><span class="line">			<span class="keyword">yield</span> col :: queens</span><br><span class="line">	placeQueens(n)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="maps">Maps</h2>
<p>A map of type <code>Map[Key, Value]</code> is a data structure that
associates keys of type <code>Key</code> with values of type
<code>Value</code>. For example:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> romanNumerals = <span class="type">Map</span>(<span class="string">"I"</span> -&gt; <span class="number">1</span>, <span class="string">"V"</span> -&gt; <span class="number">5</span>, <span class="string">"X"</span> -&gt; <span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> capitalOfCountry = <span class="type">Map</span>(<span class="string">"US"</span> -&gt; <span class="string">"Washington"</span>, <span class="string">"Switzerland"</span> -&gt; <span class="string">"Bern"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="maps-are-iterables.">Maps are iterables.</h3>
<p>Class <code>Map[Key, Value]</code> extends the collection type
<code>Iterable[(Key, Value)]</code>. Therefor, maps support the same
collection operations as other iterables do. Example:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> countryOfCapital = capitalOfCountry.map((x, y) =&gt; (y, x))</span><br></pre></td></tr></tbody></table></figure>
<p>The syntax <code>key -&gt; value</code> is just an alternative way to
write the pair <code>(key, value)</code>. (<code>-&gt;</code>
implemented as an extension method in <code>Predef</code>)</p>
<h3 id="maps-are-functions">Maps are functions</h3>
<p>Class <code>Map[Key, Value]</code> also extends the function type
<code>Key =&gt; Value</code>, so maps can be used everywhere functions
can. In particular, maps can be applied to key arguments:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">capitalOfCountry(<span class="string">"US"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="querying-map">Querying map</h3>
<p>Apply a map to a non-existing key gives an error. To query a map
without knowing beforehand whether it contains a given key, you can use
the <code>get</code> operation:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">capitalOfCountry.get(<span class="string">"US"</span>)			<span class="comment">// Some("Washington")</span></span><br><span class="line">capitalOfCountry.get(<span class="string">"Andorra"</span>)		<span class="comment">// None</span></span><br></pre></td></tr></tbody></table></figure>
<p>The result of a get operation is an <code>Option</code> value.</p>
<h3 id="updating-maps">Updating maps</h3>
<p>Functional updates of a map are done with the <code>+</code> and
<code>++</code> operations:</p>
<ul>
<li><code>m + (k -&gt; v)</code>: The map that takes key <code>k</code>
to value <code>v</code> and is otherwise equal to <code>m</code></li>
<li><code>m ++ kvs</code>: The map <code>m</code> updated via
<code>+</code> with all key/value pairs in <code>kvs</code></li>
</ul>
<p>These operations are purely functional.</p>
<h3 id="sorted-and-groupby">Sorted and <code>groupBy</code></h3>
<p>Two useful operations known from SQL queries are <code>groupBy</code>
and <code>orderBy. orderBy</code> on a collection can be expressed using
<code>sortWith</code> and <code>sorted</code>:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fruit = <span class="type">List</span>(<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"orange"</span>, <span class="string">"pineapple"</span>)</span><br><span class="line">fruit.sortWith(_.length &lt; _.length)	<span class="comment">// List("pear", "apple", "orange", "pineapple")</span></span><br><span class="line">fruit.sorted						<span class="comment">// List("apple", "orange", "pear", "pineapple")</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>groupBy</code> is available on Scala collections. It partitions
a collection into a map of collections according to a discriminator
function <code>f</code>:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruit.groupBy(_.head) 	<span class="comment">//&gt; Map(p -&gt; List(pear, pineapple),</span></span><br><span class="line">						<span class="comment">//| 	a -&gt; List(apple),</span></span><br><span class="line">						<span class="comment">//|		o -&gt; List(orange))</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="default-values">Default values</h3>
<p>So far, maps were partial functions: Applying a map to a key value in
<code>map(key)</code> could lead to an exception, if the key was not
stored in the map. There is an operation <code>withDefaultValue</code>
that turns a map into a total function:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cap1 = capitalOfCountry.withDefaultValue(<span class="string">"&lt;unknown&gt;"</span>)</span><br><span class="line">cap1(<span class="string">"Andorra"</span>)			<span class="comment">// "&lt;unknown&gt;"</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="the-option-type">The <code>Option</code> type</h2>
<p>The <code>Option</code> type is defined as</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Option</span>[+<span class="type">A</span>]</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Some</span>[+<span class="type">A</span>](<span class="params">value: <span class="type">A</span></span>) <span class="keyword">extends</span> <span class="title">Option</span>[<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">None</span> <span class="keyword">extends</span> <span class="title">Option</span>[<span class="type">Nothing</span>]</span></span><br></pre></td></tr></tbody></table></figure>
<p>The expression <code>map.get(key)</code> returns:</p>
<ul>
<li><code>None</code> if <code>map</code> does not contain the given
key,</li>
<li><code>Some(x)</code> if <code>map</code> associates the given key
with the value <code>x</code>.</li>
</ul>
<h3 id="decomposing-option">Decomposing <code>Option</code></h3>
<p>Since options are defined as case classes, they can be decomposed
using pattern matching:</p>
<figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showCapital</span></span>(country: <span class="type">String</span>) = capitalOfCountry.get(country) <span class="keyword">match</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Some</span>(capital) =&gt; capital</span><br><span class="line">	<span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="string">"missing data"</span></span><br></pre></td></tr></tbody></table></figure>
<p>Options also support quite a few operations of the other
collections.</p>
<h2 id="benefits-of-scalas-immutable-collections">Benefits of Scala's
immutable collections</h2>
<ul>
<li>Easy to use: few steps to do the job</li>
<li>Concise: one word replaces a whole loop</li>
<li>Safe: type checker is really good at catching errors</li>
<li>Fast: collection ops are turned, can be parallelized</li>
<li>Universal: one vocabulary to work on all kinds of collections</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Course-note/" rel="tag"># Course note</a>
              <a href="/tags/Programming/" rel="tag"># Programming</a>
              <a href="/tags/Functional-programming/" rel="tag"># Functional programming</a>
              <a href="/tags/Scala/" rel="tag"># Scala</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/basic-machine-learning/" rel="prev" title="Basic Concepts in Machine Learning">
                  <i class="fa fa-angle-left"></i> Basic Concepts in Machine Learning
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/basic_modern_cmake/" rel="next" title="Basic of Modern CMake by Examples">
                  Basic of Modern CMake by Examples <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    © 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-cat"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yue Jiao</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">691k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">10:29</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> &amp; <a href="https://theme-next.js.org/" rel="noopener external nofollow noreferrer" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>








  







<script src="/bundle.js"></script></body></html>