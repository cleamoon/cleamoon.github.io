<!DOCTYPE html><html lang="en"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">







<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.yj0.se","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500}},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/./public/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script>



<link rel="canonical" href="http://blog.yj0.se/2022/intro-to-haskell/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://blog.yj0.se/2022/intro-to-haskell/","path":"2022/intro-to-haskell/","title":"Introduction to Haskell Programming"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Introduction to Haskell Programming | Yue Jiao's blog</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer=""></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer=""></script>








  





  <style>:root {
  --body-bg-color: #eee;
  --content-bg-color: #fff;
  --card-bg-color: #f5f5f5;
  --text-color: #555;
  --selection-bg: #262a30;
  --selection-color: #eee;
  --blockquote-color: #666;
  --link-color: #555;
  --link-hover-color: #222;
  --brand-color: #fff;
  --brand-hover-color: #fff;
  --table-row-odd-bg-color: #f9f9f9;
  --table-row-hover-bg-color: #f5f5f5;
  --menu-item-bg-color: #f5f5f5;
  --theme-color: #222;
  --btn-default-bg: #fff;
  --btn-default-color: #555;
  --btn-default-border-color: #555;
  --btn-default-hover-bg: #222;
  --btn-default-hover-color: #fff;
  --btn-default-hover-border-color: #222;
  --highlight-background: #f3f3f3;
  --highlight-foreground: #444;
  --highlight-gutter-background: #e1e1e1;
  --highlight-gutter-foreground: #555;
  color-scheme: light;
}
html {
  line-height: 1.15; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
}
body {
  margin: 0;
}
main {
  display: block;
}
h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
hr {
  box-sizing: content-box; /* 1 */
  height: 0; /* 1 */
  overflow: visible; /* 2 */
}
pre {
  font-family: monospace, monospace; /* 1 */
  font-size: 1em; /* 2 */
}
a {
  background: transparent;
}
abbr[title] {
  border-bottom: none; /* 1 */
  text-decoration: underline; /* 2 */
  text-decoration: underline dotted; /* 2 */
}
b,
strong {
  font-weight: bolder;
}
code,
kbd,
samp {
  font-family: monospace, monospace; /* 1 */
  font-size: 1em; /* 2 */
}
small {
  font-size: 80%;
}
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sub {
  bottom: -0.25em;
}
sup {
  top: -0.5em;
}
img {
  border-style: none;
}
button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-size: 100%; /* 1 */
  line-height: 1.15; /* 1 */
  margin: 0; /* 2 */
}
button,
input {
/* 1 */
  overflow: visible;
}
button,
select {
/* 1 */
  text-transform: none;
}
button,
[type='button'],
[type='reset'],
[type='submit'] {
  -webkit-appearance: button;
}
button::-moz-focus-inner,
[type='button']::-moz-focus-inner,
[type='reset']::-moz-focus-inner,
[type='submit']::-moz-focus-inner {
  border-style: none;
  padding: 0;
}
button:-moz-focusring,
[type='button']:-moz-focusring,
[type='reset']:-moz-focusring,
[type='submit']:-moz-focusring {
  outline: 1px dotted ButtonText;
}
fieldset {
  padding: 0.35em 0.75em 0.625em;
}
legend {
  box-sizing: border-box; /* 1 */
  color: inherit; /* 2 */
  display: table; /* 1 */
  max-width: 100%; /* 1 */
  padding: 0; /* 3 */
  white-space: normal; /* 1 */
}
progress {
  vertical-align: baseline;
}
textarea {
  overflow: auto;
}
[type='checkbox'],
[type='radio'] {
  box-sizing: border-box; /* 1 */
  padding: 0; /* 2 */
}
[type='number']::-webkit-inner-spin-button,
[type='number']::-webkit-outer-spin-button {
  height: auto;
}
[type='search'] {
  outline-offset: -2px; /* 2 */
  -webkit-appearance: textfield; /* 1 */
}
[type='search']::-webkit-search-decoration {
  -webkit-appearance: none;
}
::-webkit-file-upload-button {
  font: inherit; /* 2 */
  -webkit-appearance: button; /* 1 */
}
details {
  display: block;
}
summary {
  display: list-item;
}
template {
  display: none;
}
[hidden] {
  display: none;
}
::selection {
  background: var(--selection-bg);
  color: var(--selection-color);
}
html,
body {
  height: 100%;
}
body {
  background: var(--body-bg-color);
  box-sizing: border-box;
  color: var(--text-color);
  font-family: Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;
  font-size: 1em;
  line-height: 2;
  min-height: 100%;
  position: relative;
  transition: padding 0.2s ease-in-out;
}
h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;
  font-weight: bold;
  line-height: 1.5;
  margin: 30px 0 15px;
}
h1 {
  font-size: 1.5em;
}
h2 {
  font-size: 1.375em;
}
h3 {
  font-size: 1.25em;
}
h4 {
  font-size: 1.125em;
}
h5 {
  font-size: 1em;
}
h6 {
  font-size: 0.875em;
}
a {
  border-bottom: 1px solid #999;
  color: var(--link-color);
  cursor: pointer;
  outline: 0;
  text-decoration: none;
  overflow-wrap: break-word;
}
a:hover {
  border-bottom-color: var(--link-hover-color);
  color: var(--link-hover-color);
}
iframe,
img,
video,
embed {
  display: block;
  margin-left: auto;
  margin-right: auto;
  max-width: 100%;
}
hr {
  background-image: repeating-linear-gradient(-45deg, #ddd, #ddd 4px, transparent 4px, transparent 8px);
  border: 0;
  height: 3px;
  margin: 40px 0;
}
blockquote {
  border-left: 4px solid #ddd;
  color: var(--blockquote-color);
  margin: 0;
  padding: 0 15px;
}
blockquote cite::before {
  content: '-';
  padding: 0 5px;
}
dt {
  font-weight: bold;
}
dd {
  margin: 0;
  padding: 0;
}
.table-container {
  overflow: auto;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
  font-size: 0.875em;
  margin: 0 0 20px;
  width: 100%;
}
tbody tr:nth-of-type(odd) {
  background: var(--table-row-odd-bg-color);
}
tbody tr:hover {
  background: var(--table-row-hover-bg-color);
}
caption,
th,
td {
  padding: 8px;
}
th,
td {
  border: 1px solid #ddd;
  border-bottom: 3px solid #ddd;
}
th {
  font-weight: 700;
  padding-bottom: 10px;
}
td {
  border-bottom-width: 1px;
}
.btn {
  background: var(--btn-default-bg);
  border: 2px solid var(--btn-default-border-color);
  border-radius: 2px;
  color: var(--btn-default-color);
  display: inline-block;
  font-size: 0.875em;
  line-height: 2;
  padding: 0 20px;
  transition: background-color 0.2s ease-in-out;
}
.btn:hover {
  background: var(--btn-default-hover-bg);
  border-color: var(--btn-default-hover-border-color);
  color: var(--btn-default-hover-color);
}
.btn + .btn {
  margin: 0 0 8px 8px;
}
.btn .fa-fw {
  text-align: left;
  width: 1.285714285714286em;
}
.toggle {
  line-height: 0;
}
.toggle .toggle-line {
  background: #fff;
  display: block;
  height: 2px;
  left: 0;
  position: relative;
  top: 0;
  transition: 0.4s;
  transition-property: left, opacity, top, transform, width;
  width: 100%;
}
.toggle .toggle-line:first-child {
  margin-top: 1px;
}
.toggle .toggle-line:not(:first-child) {
  margin-top: 4px;
}
.toggle.toggle-arrow :first-child {
  left: 50%;
  top: 2px;
  transform: rotate(45deg);
  width: 50%;
}
.toggle.toggle-arrow :last-child {
  left: 50%;
  top: -2px;
  transform: rotate(-45deg);
  width: 50%;
}
.toggle.toggle-close :nth-child(2) {
  opacity: 0;
}
.toggle.toggle-close :first-child {
  top: 6px;
  transform: rotate(45deg);
}
.toggle.toggle-close :last-child {
  top: -6px;
  transform: rotate(-45deg);
}
pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1em
}
code.hljs {
  padding: 3px 5px
}
/*!
  Theme: Default
  Description: Original highlight.js style
  Author: (c) Ivan Sagalaev <maniac@softwaremaniacs.org>
  Maintainer: @highlightjs/core-team
  Website: https://highlightjs.org/
  License: see project LICENSE
  Touched: 2021
*/
/*
This is left on purpose making default.css the single file that can be lifted
as-is from the repository directly without the need for a build step

Typically this "required" baseline CSS is added by `makestuff.js` during build.
*/
pre code.hljs {
  display: block;
  overflow-x: auto;
  padding: 1em
}
code.hljs {
  padding: 3px 5px
}
/* end baseline CSS */
.hljs {
  background: #F3F3F3;
  color: #444
}
/* Base color: saturation 0; */
.hljs-subst {
  /* default */
  
}
/* purposely ignored */
.hljs-formula,
.hljs-attr,
.hljs-property,
.hljs-params {
  
}
.hljs-comment {
  color: #697070
}
.hljs-tag,
.hljs-punctuation {
  color: #444a
}
.hljs-tag .hljs-name,
.hljs-tag .hljs-attr {
  color: #444
}
.hljs-keyword,
.hljs-attribute,
.hljs-selector-tag,
.hljs-meta .hljs-keyword,
.hljs-doctag,
.hljs-name {
  font-weight: bold
}
/* User color: hue: 0 */
.hljs-type,
.hljs-string,
.hljs-number,
.hljs-selector-id,
.hljs-selector-class,
.hljs-quote,
.hljs-template-tag,
.hljs-deletion {
  color: #880000
}
.hljs-title,
.hljs-section {
  color: #880000;
  font-weight: bold
}
.hljs-regexp,
.hljs-symbol,
.hljs-variable,
.hljs-template-variable,
.hljs-link,
.hljs-selector-attr,
.hljs-operator,
.hljs-selector-pseudo {
  color: #ab5656
}
/* Language color: hue: 90; */
.hljs-literal {
  color: #695
}
.hljs-built_in,
.hljs-bullet,
.hljs-code,
.hljs-addition {
  color: #397300
}
/* Meta color: hue: 200 */
.hljs-meta {
  color: #1f7199
}
.hljs-meta .hljs-string {
  color: #38a
}
/* Misc effects */
.hljs-emphasis {
  font-style: italic
}
.hljs-strong {
  font-weight: bold
}
code,
kbd,
figure.highlight,
pre {
  background: var(--highlight-background);
  color: var(--highlight-foreground);
}
figure.highlight,
pre {
  line-height: 1.6;
  margin: 0 auto 20px;
}
figure.highlight figcaption,
pre .caption {
  background: var(--highlight-gutter-background);
  color: var(--highlight-foreground);
  display: flow-root;
  font-size: 0.875em;
  line-height: 1.2;
  padding: 0.5em;
}
figure.highlight figcaption a,
pre .caption a {
  color: var(--highlight-foreground);
  float: right;
}
figure.highlight figcaption a:hover,
pre .caption a:hover {
  border-bottom-color: var(--highlight-foreground);
}
pre,
code {
  font-family: consolas, Menlo, monospace, 'PingFang SC', 'Microsoft YaHei';
}
code {
  border-radius: 3px;
  font-size: 0.875em;
  padding: 2px 4px;
  overflow-wrap: break-word;
}
kbd {
  border: 2px solid #ccc;
  border-radius: 0.2em;
  box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1);
  font-family: inherit;
  padding: 0.1em 0.3em;
  white-space: nowrap;
}
figure.highlight {
  overflow: auto;
  position: relative;
}
figure.highlight pre {
  border: 0;
  margin: 0;
  padding: 10px 0;
}
figure.highlight table {
  border: 0;
  margin: 0;
  width: auto;
}
figure.highlight td {
  border: 0;
  padding: 0;
}
figure.highlight .gutter {
  -webkit-user-select: none;
  user-select: none;
}
figure.highlight .gutter pre {
  background: var(--highlight-gutter-background);
  color: var(--highlight-gutter-foreground);
  padding-left: 10px;
  padding-right: 10px;
  text-align: right;
}
figure.highlight .code pre {
  padding-left: 10px;
  width: 100%;
}
figure.highlight .marked {
  background: rgba(0,0,0,0.3);
}
pre .caption {
  margin-bottom: 10px;
}
.gist table {
  width: auto;
}
.gist table td {
  border: 0;
}
pre {
  overflow: auto;
  padding: 10px;
}
pre code {
  background: none;
  padding: 0;
  text-shadow: none;
}
.blockquote-center {
  border-left: 0;
  margin: 40px 0;
  padding: 0;
  position: relative;
  text-align: center;
}
.blockquote-center::before,
.blockquote-center::after {
  left: 0;
  line-height: 1;
  opacity: 0.6;
  position: absolute;
  width: 100%;
}
.blockquote-center::before {
  border-top: 1px solid #ccc;
  text-align: left;
  top: -20px;
  content: '\f10d';
  font-family: 'Font Awesome 6 Free';
  font-weight: 900;
}
.blockquote-center::after {
  border-bottom: 1px solid #ccc;
  bottom: -20px;
  text-align: right;
  content: '\f10e';
  font-family: 'Font Awesome 6 Free';
  font-weight: 900;
}
.blockquote-center p,
.blockquote-center div {
  text-align: center;
}
.group-picture {
  margin-bottom: 20px;
}
.group-picture .group-picture-row {
  display: flex;
  gap: 3px;
  margin-bottom: 3px;
}
.group-picture .group-picture-column {
  flex: 1;
}
.group-picture .group-picture-column img {
  height: 100%;
  margin: 0;
  object-fit: cover;
  width: 100%;
}
.post-body .label {
  color: #555;
  padding: 0 2px;
}
.post-body .label.default {
  background: #f0f0f0;
}
.post-body .label.primary {
  background: #efe6f7;
}
.post-body .label.info {
  background: #e5f2f8;
}
.post-body .label.success {
  background: #e7f4e9;
}
.post-body .label.warning {
  background: #fcf6e1;
}
.post-body .label.danger {
  background: #fae8eb;
}
.post-body .link-grid {
  display: grid;
  grid-gap: 1.5rem;
  gap: 1.5rem;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  margin-bottom: 20px;
  padding: 1rem;
}
.post-body .link-grid .link-grid-container {
  border: solid #ddd;
  box-shadow: 1rem 1rem 0.5rem rgba(0,0,0,0.5);
  min-height: 5rem;
  min-width: 0;
  padding: 0.5rem;
  position: relative;
  transition: background 0.3s;
}
.post-body .link-grid .link-grid-container:hover {
  animation: next-shake 0.5s;
  background: var(--card-bg-color);
}
.post-body .link-grid .link-grid-container:active {
  box-shadow: 0.5rem 0.5rem 0.25rem rgba(0,0,0,0.5);
  transform: translate(0.2rem, 0.2rem);
}
.post-body .link-grid .link-grid-container .link-grid-image {
  border: 1px solid #ddd;
  border-radius: 50%;
  box-sizing: border-box;
  height: 5rem;
  padding: 3px;
  position: absolute;
  width: 5rem;
}
.post-body .link-grid .link-grid-container p {
  margin: 0 1rem 0 6rem;
}
.post-body .link-grid .link-grid-container p:first-of-type {
  font-size: 1.2em;
}
.post-body .link-grid .link-grid-container p:last-of-type {
  font-size: 0.8em;
  line-height: 1.3rem;
  opacity: 0.7;
}
.post-body .link-grid .link-grid-container a {
  border: 0;
  height: 100%;
  left: 0;
  position: absolute;
  top: 0;
  width: 100%;
}
@keyframes next-shake {
  0% {
    transform: translate(1pt, 1pt) rotate(0deg);
  }
  10% {
    transform: translate(-1pt, -2pt) rotate(-1deg);
  }
  20% {
    transform: translate(-3pt, 0pt) rotate(1deg);
  }
  30% {
    transform: translate(3pt, 2pt) rotate(0deg);
  }
  40% {
    transform: translate(1pt, -1pt) rotate(1deg);
  }
  50% {
    transform: translate(-1pt, 2pt) rotate(-1deg);
  }
  60% {
    transform: translate(-3pt, 1pt) rotate(0deg);
  }
  70% {
    transform: translate(3pt, 1pt) rotate(-1deg);
  }
  80% {
    transform: translate(-1pt, -1pt) rotate(1deg);
  }
  90% {
    transform: translate(1pt, 2pt) rotate(0deg);
  }
  100% {
    transform: translate(1pt, -2pt) rotate(-1deg);
  }
}
.post-body .note {
  border-radius: 3px;
  margin-bottom: 20px;
  padding: 1em;
  position: relative;
  background: #f5f5f5;
  border: 1px solid transparent;
}
.post-body .note summary {
  cursor: pointer;
  outline: 0;
}
.post-body .note summary p {
  display: inline;
}
.post-body .note h2,
.post-body .note h3,
.post-body .note h4,
.post-body .note h5,
.post-body .note h6 {
  border-bottom: initial;
  margin: 0;
  padding-top: 0;
}
.post-body .note :first-child {
  margin-top: 0;
}
.post-body .note :last-child {
  margin-bottom: 0;
}
.post-body .note.default {
  background: #f3f3f3;
  border-color: #e1e1e1;
  color: #666;
}
.post-body .note.default a:not(.btn) {
  border-bottom-color: #666;
  color: #666;
}
.post-body .note.default a:not(.btn):hover {
  border-bottom-color: #454545;
  color: #454545;
}
.post-body .note.primary {
  background: #f3daff;
  border-color: #e1c2ff;
  color: #6f42c1;
}
.post-body .note.primary a:not(.btn) {
  border-bottom-color: #6f42c1;
  color: #6f42c1;
}
.post-body .note.primary a:not(.btn):hover {
  border-bottom-color: #453298;
  color: #453298;
}
.post-body .note.info {
  background: #d9edf7;
  border-color: #b3e5ef;
  color: #31708f;
}
.post-body .note.info a:not(.btn) {
  border-bottom-color: #31708f;
  color: #31708f;
}
.post-body .note.info a:not(.btn):hover {
  border-bottom-color: #215761;
  color: #215761;
}
.post-body .note.success {
  background: #dff0d8;
  border-color: #d0e6be;
  color: #3c763d;
}
.post-body .note.success a:not(.btn) {
  border-bottom-color: #3c763d;
  color: #3c763d;
}
.post-body .note.success a:not(.btn):hover {
  border-bottom-color: #32562c;
  color: #32562c;
}
.post-body .note.warning {
  background: #fcf4e3;
  border-color: #fae4cd;
  color: #8a6d3b;
}
.post-body .note.warning a:not(.btn) {
  border-bottom-color: #8a6d3b;
  color: #8a6d3b;
}
.post-body .note.warning a:not(.btn):hover {
  border-bottom-color: #714f30;
  color: #714f30;
}
.post-body .note.danger {
  background: #f2dfdf;
  border-color: #ebcdd2;
  color: #a94442;
}
.post-body .note.danger a:not(.btn) {
  border-bottom-color: #a94442;
  color: #a94442;
}
.post-body .note.danger a:not(.btn):hover {
  border-bottom-color: #84333f;
  color: #84333f;
}
.post-body .tabs {
  margin-bottom: 20px;
}
.post-body .tabs,
.tabs-comment {
  padding-top: 10px;
}
.post-body .tabs ul.nav-tabs,
.tabs-comment ul.nav-tabs {
  background: var(--content-bg-color);
  display: flex;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  margin: 0;
  padding: 0;
  position: sticky;
  top: 0;
  z-index: 5;
}
@media (max-width: 413px) {
  .post-body .tabs ul.nav-tabs,
  .tabs-comment ul.nav-tabs {
    display: block;
    margin-bottom: 5px;
  }
}
.post-body .tabs ul.nav-tabs li.tab,
.tabs-comment ul.nav-tabs li.tab {
  border-bottom: 1px solid #ddd;
  border-left: 1px solid transparent;
  border-right: 1px solid transparent;
  border-radius: 0 0 0 0;
  border-top: 3px solid transparent;
  flex-grow: 1;
  list-style-type: none;
}
@media (max-width: 413px) {
  .post-body .tabs ul.nav-tabs li.tab,
  .tabs-comment ul.nav-tabs li.tab {
    border-bottom: 1px solid transparent;
    border-left: 3px solid transparent;
    border-right: 1px solid transparent;
    border-top: 1px solid transparent;
  }
}
@media (max-width: 413px) {
  .post-body .tabs ul.nav-tabs li.tab,
  .tabs-comment ul.nav-tabs li.tab {
    border-radius: 0;
  }
}
.post-body .tabs ul.nav-tabs li.tab a,
.tabs-comment ul.nav-tabs li.tab a {
  border-bottom: initial;
  display: block;
  line-height: 1.8;
  padding: 0.25em 0.75em;
  text-align: center;
  transition: all 0.2s ease-out;
}
.post-body .tabs ul.nav-tabs li.tab a i[class^='fa'],
.tabs-comment ul.nav-tabs li.tab a i[class^='fa'] {
  width: 1.285714285714286em;
}
.post-body .tabs ul.nav-tabs li.tab.active,
.tabs-comment ul.nav-tabs li.tab.active {
  border-bottom-color: transparent;
  border-left-color: #ddd;
  border-right-color: #ddd;
  border-top-color: #fc6423;
}
@media (max-width: 413px) {
  .post-body .tabs ul.nav-tabs li.tab.active,
  .tabs-comment ul.nav-tabs li.tab.active {
    border-bottom-color: #ddd;
    border-left-color: #fc6423;
    border-right-color: #ddd;
    border-top-color: #ddd;
  }
}
.post-body .tabs ul.nav-tabs li.tab.active a,
.tabs-comment ul.nav-tabs li.tab.active a {
  cursor: default;
}
.post-body .tabs .tab-content,
.tabs-comment .tab-content {
  border: 1px solid #ddd;
  border-radius: 0 0 0 0;
  border-top-color: transparent;
}
@media (max-width: 413px) {
  .post-body .tabs .tab-content,
  .tabs-comment .tab-content {
    border-radius: 0;
    border-top-color: #ddd;
  }
}
.post-body .tabs .tab-content .tab-pane,
.tabs-comment .tab-content .tab-pane {
  padding: 20px 20px 0;
}
.post-body .tabs .tab-content .tab-pane:not(.active),
.tabs-comment .tab-content .tab-pane:not(.active) {
  display: none;
}
.pagination .prev,
.pagination .next,
.pagination .page-number,
.pagination .space {
  display: inline-block;
  margin: -1px 10px 0;
  padding: 0 10px;
}
@media (max-width: 767px) {
  .pagination .prev,
  .pagination .next,
  .pagination .page-number,
  .pagination .space {
    margin: 0 5px;
  }
}
.pagination .page-number.current {
  background: #ccc;
  border-color: #ccc;
  color: var(--content-bg-color);
}
.pagination {
  border-top: 1px solid #eee;
  margin: 120px 0 0;
  text-align: center;
}
.pagination .prev,
.pagination .next,
.pagination .page-number {
  border-bottom: 0;
  border-top: 1px solid #eee;
  transition: border-color 0.2s ease-in-out;
}
.pagination .prev:hover,
.pagination .next:hover,
.pagination .page-number:hover {
  border-top-color: var(--link-hover-color);
}
@media (max-width: 767px) {
  .pagination {
    border-top: 0;
  }
  .pagination .prev,
  .pagination .next,
  .pagination .page-number {
    border-bottom: 1px solid #eee;
    border-top: 0;
  }
  .pagination .prev:hover,
  .pagination .next:hover,
  .pagination .page-number:hover {
    border-bottom-color: var(--link-hover-color);
  }
}
.pagination .space {
  margin: 0;
  padding: 0;
}
.comments {
  margin-top: 60px;
  overflow: hidden;
}
.comment-button-group {
  display: flex;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  justify-content: center;
  margin: 1em 0;
}
.comment-button-group .comment-button {
  margin: 0.1em 0.2em;
}
.comment-button-group .comment-button.active {
  background: var(--btn-default-hover-bg);
  border-color: var(--btn-default-hover-border-color);
  color: var(--btn-default-hover-color);
}
.comment-position {
  display: none;
}
.comment-position.active {
  display: block;
}
.tabs-comment {
  margin-top: 4em;
  padding-top: 0;
}
.tabs-comment .comments {
  margin-top: 0;
  padding-top: 0;
}
.headband {
  background: var(--theme-color);
  height: 3px;
}
@media (max-width: 991px) {
  .headband {
    display: none;
  }
}
.site-brand-container {
  display: flex;
  flex-shrink: 0;
  padding: 0 10px;
}
.use-motion .column,
.use-motion .site-brand-container .toggle {
  opacity: 0;
}
.site-meta {
  flex-grow: 1;
  text-align: center;
}
@media (max-width: 767px) {
  .site-meta {
    text-align: center;
  }
}
.custom-logo-image {
  margin-top: 20px;
}
@media (max-width: 991px) {
  .custom-logo-image {
    display: none;
  }
}
.brand {
  border-bottom: 0;
  color: var(--brand-color);
  display: inline-block;
  padding: 0;
}
.brand:hover {
  color: var(--brand-hover-color);
}
.site-title {
  font-family: Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;
  font-size: 1.375em;
  font-weight: normal;
  line-height: 1.5;
  margin: 0;
}
.site-subtitle {
  color: #ddd;
  font-size: 0.8125em;
  margin: 10px 10px 0;
}
.use-motion .site-title,
.use-motion .site-subtitle,
.use-motion .custom-logo-image {
  opacity: 0;
  position: relative;
  top: -10px;
}
.site-nav-toggle,
.site-nav-right {
  display: none;
}
@media (max-width: 767px) {
  .site-nav-toggle,
  .site-nav-right {
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
}
.site-nav-toggle .toggle,
.site-nav-right .toggle {
  color: var(--text-color);
  padding: 10px;
  width: 22px;
}
.site-nav-toggle .toggle .toggle-line,
.site-nav-right .toggle .toggle-line {
  background: var(--text-color);
  border-radius: 1px;
}
@media (max-width: 767px) {
  .site-nav {
    --scroll-height: 0;
    height: 0;
    overflow: hidden;
    transition: 0.2s ease-in-out;
    transition-property: height, visibility;
    visibility: hidden;
  }
  body:not(.site-nav-on) .site-nav .animated {
    animation: none;
  }
  body.site-nav-on .site-nav {
    height: var(--scroll-height);
    visibility: unset;
  }
}
.menu {
  margin: 0;
  padding: 1em 0;
  text-align: center;
}
.menu-item {
  display: inline-block;
  list-style: none;
  margin: 0 10px;
}
@media (max-width: 767px) {
  .menu-item {
    display: block;
    margin-top: 10px;
  }
  .menu-item.menu-item-search {
    display: none;
  }
}
.menu-item a {
  border-bottom: 0;
  display: block;
  font-size: 0.8125em;
  transition: border-color 0.2s ease-in-out;
}
.menu-item a:hover,
.menu-item a.menu-item-active {
  background: var(--menu-item-bg-color);
}
.menu-item i[class^='fa'] {
  margin-right: 8px;
}
.menu-item .badge {
  background: #ccc;
  border-radius: 10px;
  color: var(--content-bg-color);
  font-weight: bold;
  line-height: 1;
  margin-left: 0.35em;
  padding: 2px 5px;
  text-shadow: 1px 1px 0 rgba(0,0,0,0.1);
}
.use-motion .menu-item {
  visibility: hidden;
}
@media (max-width: 991px) {
  .sidebar {
    left: -320px;
  }
  .sidebar-active .sidebar {
    left: 0;
  }
  .sidebar {
    background: #222;
    bottom: 0;
    box-shadow: inset 0 2px 6px #000;
    max-height: 100vh;
    overflow-y: auto;
    position: fixed;
    top: 0;
    transition: 0.2s ease-out;
    transition-property: left, right;
    width: 320px;
    z-index: 20;
  }
  .sidebar a {
    border-bottom-color: #555;
    color: #999;
  }
  .sidebar a:hover {
    border-bottom-color: #eee;
    color: #eee;
  }
  .links-of-author:not(:first-child) {
    margin-top: 15px;
  }
  .links-of-author a {
    border-bottom-color: #555;
    display: inline-block;
    margin-bottom: 10px;
    margin-right: 10px;
    vertical-align: middle;
  }
  .links-of-author a::before {
    background: #3dff00;
    display: inline-block;
    margin-right: 3px;
    transform: translateY(-2px);
    border-radius: 50%;
    content: ' ';
    height: 4px;
    width: 4px;
  }
  .links-of-blogroll-item {
    padding: 0 5px;
  }
  .popular-posts .popular-posts-item .popular-posts-link:hover {
    background: none;
  }
  .sidebar-dimmer {
    background: #000;
    height: 100%;
    left: 0;
    opacity: 0;
    position: fixed;
    top: 0;
    transition: visibility 0.4s, opacity 0.4s;
    visibility: hidden;
    width: 100%;
    z-index: 10;
  }
  .sidebar-active .sidebar-dimmer {
    opacity: 0.7;
    visibility: visible;
  }
}
.sidebar-inner {
  color: #999;
  padding: 18px 10px;
  text-align: center;
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.sidebar-toggle {
  bottom: 61px;
  height: 16px;
  padding: 5px;
  width: 16px;
  background: #222;
  cursor: pointer;
  opacity: 0.6;
  position: fixed;
  z-index: 30;
  left: 30px;
}
@media (max-width: 991px) {
  .sidebar-toggle {
    left: 20px;
  }
}
.sidebar-toggle:hover {
  opacity: 0.8;
}
@media (max-width: 991px) {
  .sidebar-toggle {
    opacity: 0.8;
  }
}
.sidebar-toggle:hover .toggle-line {
  background: #fc6423;
}
@media (any-hover: hover) {
  body:not(.sidebar-active) .sidebar-toggle:hover :first-child {
    left: 50%;
    top: 2px;
    transform: rotate(45deg);
    width: 50%;
  }
  body:not(.sidebar-active) .sidebar-toggle:hover :last-child {
    left: 50%;
    top: -2px;
    transform: rotate(-45deg);
    width: 50%;
  }
}
.sidebar-active .sidebar-toggle :nth-child(2) {
  opacity: 0;
}
.sidebar-active .sidebar-toggle :first-child {
  top: 6px;
  transform: rotate(45deg);
}
.sidebar-active .sidebar-toggle :last-child {
  top: -6px;
  transform: rotate(-45deg);
}
.sidebar-nav {
  font-size: 0.875em;
  height: 0;
  margin: 0;
  overflow: hidden;
  padding-left: 0;
  pointer-events: none;
  transition: 0.2s ease-in-out;
  transition-property: height, visibility;
  visibility: hidden;
}
.sidebar-nav-active .sidebar-nav {
  height: calc(2em + 1px);
  pointer-events: unset;
  visibility: unset;
}
.sidebar-nav li {
  border-bottom: 1px solid transparent;
  color: var(--text-color);
  cursor: pointer;
  display: inline-block;
  transition: 0.2s ease-in-out;
  transition-property: border-bottom-color, color;
}
.sidebar-nav li.sidebar-nav-overview {
  margin-left: 10px;
}
.sidebar-nav li:hover {
  color: #fc6423;
}
.sidebar-toc-active .sidebar-nav-toc,
.sidebar-overview-active .sidebar-nav-overview {
  border-bottom-color: #fc6423;
  color: #fc6423;
  transition-delay: 0.2s;
}
.sidebar-toc-active .sidebar-nav-toc:hover,
.sidebar-overview-active .sidebar-nav-overview:hover {
  color: #fc6423;
}
.sidebar-panel-container {
  align-items: start;
  display: grid;
  flex: 1;
  overflow-x: hidden;
  overflow-y: auto;
  padding-top: 0;
  transition: padding-top 0.2s ease-in-out;
}
.sidebar-nav-active .sidebar-panel-container {
  padding-top: 20px;
}
.sidebar-panel {
  animation: deactivate-sidebar-panel 0.2s ease-in-out;
  grid-area: 1/1;
  height: 0;
  opacity: 0;
  overflow: hidden;
  pointer-events: none;
  transform: translateY(0);
  transition: 0.2s ease-in-out;
  transition-delay: 0s;
  transition-property: opacity, transform, visibility;
  visibility: hidden;
}
.sidebar-nav-active .sidebar-panel,
.sidebar-overview-active .sidebar-panel.post-toc-wrap {
  transform: translateY(-20px);
}
.sidebar-overview-active:not(.sidebar-nav-active) .sidebar-panel.post-toc-wrap {
  transition-delay: 0s, 0.2s, 0s;
}
.sidebar-overview-active .sidebar-panel.site-overview-wrap,
.sidebar-toc-active .sidebar-panel.post-toc-wrap {
  animation-name: activate-sidebar-panel;
  height: auto;
  opacity: 1;
  pointer-events: unset;
  transform: translateY(0);
  transition-delay: 0.2s, 0.2s, 0s;
  visibility: unset;
}
.sidebar-panel.site-overview-wrap {
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 10px;
  justify-content: flex-start;
}
@keyframes deactivate-sidebar-panel {
  from {
    height: var(--inactive-panel-height, 0);
  }
  to {
    height: var(--active-panel-height, 0);
  }
}
@keyframes activate-sidebar-panel {
  from {
    height: var(--inactive-panel-height, auto);
  }
  to {
    height: var(--active-panel-height, auto);
  }
}
.post-toc {
  font-size: 0.875em;
}
.post-toc ol {
  list-style: none;
  margin: 0;
  padding: 0 2px 0 10px;
  text-align: left;
}
.post-toc ol > :last-child {
  margin-bottom: 5px;
}
.post-toc ol > ol {
  padding-left: 0;
}
.post-toc ol a {
  transition: all 0.2s ease-in-out;
}
.post-toc .nav-item {
  line-height: 1.8;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.post-toc .nav .nav-child {
  --height: 0;
  height: 0;
  opacity: 0;
  overflow: hidden;
  transition-property: height, opacity, visibility;
  transition: 0.2s ease-in-out;
  visibility: hidden;
}
.post-toc .nav .active > .nav-child {
  height: var(--height, auto);
  opacity: 1;
  visibility: unset;
}
.post-toc .nav .active > a {
  border-bottom-color: #fc6423;
  color: #fc6423;
}
.post-toc .nav .active-current > a {
  color: #fc6423;
}
.post-toc .nav .active-current > a:hover {
  color: #fc6423;
}
.site-author-image {
  border: 1px solid #eee;
  max-width: 120px;
  padding: 2px;
}
.site-author-name {
  color: var(--text-color);
  font-weight: 600;
  margin: 0;
}
.site-description {
  color: #999;
  font-size: 0.8125em;
  margin-top: 0;
}
.site-state {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  line-height: 1.4;
}
.site-state-item {
  padding: 0 15px;
}
.site-state-item a {
  border-bottom: 0;
  display: block;
}
.site-state-item-count {
  display: block;
  font-size: 1em;
  font-weight: 600;
}
.site-state-item-name {
  color: #999;
  font-size: 0.8125em;
}
.sidebar .sidebar-button:not(:first-child) {
  margin-top: 15px;
}
.sidebar .sidebar-button button {
  background: transparent;
  color: #fc6423;
  cursor: pointer;
  line-height: 2;
  padding: 0 15px;
  border: 1px solid #fc6423;
  border-radius: 4px;
}
.sidebar .sidebar-button button:hover {
  background: #fc6423;
  color: #fff;
}
.sidebar .sidebar-button button i[class^='fa'] {
  margin-right: 5px;
}
.links-of-author a {
  font-size: 0.8125em;
}
.links-of-author i[class^='fa'] {
  margin-right: 2px;
}
.cc-license .cc-opacity {
  border-bottom: 0;
  opacity: 0.7;
}
.cc-license .cc-opacity:hover {
  opacity: 0.9;
}
.cc-license img {
  display: inline-block;
}
.links-of-blogroll {
  font-size: 0.8125em;
}
.links-of-blogroll-title {
  font-size: 0.875em;
  font-weight: 600;
}
.links-of-blogroll-list {
  list-style: none;
  gap: 5px;
  margin: 5px 0 0;
  padding: 0;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  flex-direction: column;
}
.links-of-blogroll-item {
  max-width: 100%;
}
.links-of-blogroll-item a {
  box-sizing: border-box;
  display: inline-block;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.footer {
  color: #999;
  font-size: 0.875em;
  padding: 20px 0;
  transition: 0.2s ease-in-out;
  transition-property: left, right;
}
.footer.footer-fixed {
  bottom: 0;
  left: 0;
  position: absolute;
  right: 0;
}
.footer-inner {
  box-sizing: border-box;
  text-align: center;
  display: flex;
  flex-direction: column;
  justify-content: center;
  margin: 0 auto;
  width: calc(100% - 20px);
}
@media (max-width: 767px) {
  .footer-inner {
    width: auto;
  }
}
@media (min-width: 1200px) {
  .footer-inner {
    width: 1160px;
  }
}
@media (min-width: 1600px) {
  .footer-inner {
    width: 73%;
  }
}
.use-motion .footer {
  opacity: 0;
}
.languages {
  display: inline-block;
  font-size: 1.125em;
  position: relative;
}
.languages .lang-select-label span {
  margin: 0 0.5em;
}
.languages .lang-select {
  height: 100%;
  left: 0;
  opacity: 0;
  position: absolute;
  top: 0;
  width: 100%;
}
.with-love {
  color: ##0000ff;
  display: inline-block;
  margin: 0 5px;
}
@keyframes icon-animate {
  0%, 100% {
    transform: scale(1);
  }
  10%, 30% {
    transform: scale(0.9);
  }
  20%, 40%, 60%, 80% {
    transform: scale(1.1);
  }
  50%, 70% {
    transform: scale(1.1);
  }
}
.back-to-top {
  font-size: 12px;
  align-items: center;
  bottom: -100px;
  color: #fff;
  display: flex;
  height: 26px;
  transition: 0.2s ease-in-out;
  transition-property: bottom;
  background: #222;
  cursor: pointer;
  opacity: 0.6;
  position: fixed;
  z-index: 30;
  left: 30px;
}
.back-to-top span {
  margin-right: 8px;
  display: none;
}
.back-to-top .fa {
  text-align: center;
  width: 26px;
}
@media (max-width: 991px) {
  .back-to-top {
    left: 20px;
  }
}
.back-to-top:hover {
  opacity: 0.8;
}
@media (max-width: 991px) {
  .back-to-top {
    opacity: 0.8;
  }
}
.back-to-top:hover {
  color: #fc6423;
}
.back-to-top.back-to-top-on {
  bottom: 30px;
}
.reading-progress-bar {
  --progress: 0;
  background: #37c6c0;
  height: 3px;
  position: fixed;
  z-index: 50;
  width: var(--progress);
  left: 0;
  bottom: 0;
}
.rtl.post-body p,
.rtl.post-body a,
.rtl.post-body h1,
.rtl.post-body h2,
.rtl.post-body h3,
.rtl.post-body h4,
.rtl.post-body h5,
.rtl.post-body h6,
.rtl.post-body li,
.rtl.post-body ul,
.rtl.post-body ol {
  direction: rtl;
  font-family: UKIJ Ekran;
}
.rtl.post-title {
  font-family: UKIJ Ekran;
}
.post-button {
  margin-top: 40px;
  text-align: center;
}
.use-motion .post-block,
.use-motion .pagination,
.use-motion .comments {
  visibility: hidden;
}
.use-motion .post-header {
  visibility: hidden;
}
.use-motion .post-body {
  visibility: hidden;
}
.use-motion .collection-header {
  visibility: hidden;
}
.posts-collapse .post-content {
  margin-bottom: 35px;
  margin-left: 35px;
  position: relative;
}
@media (max-width: 767px) {
  .posts-collapse .post-content {
    margin-left: 0;
    margin-right: 0;
  }
}
.posts-collapse .post-content .collection-title {
  font-size: 1.125em;
  position: relative;
}
.posts-collapse .post-content .collection-title::before {
  background: #999;
  border: 1px solid #fff;
  margin-left: -6px;
  margin-top: -4px;
  position: absolute;
  top: 50%;
  border-radius: 50%;
  content: ' ';
  height: 10px;
  width: 10px;
}
.posts-collapse .post-content .collection-year {
  font-size: 1.5em;
  font-weight: bold;
  margin: 60px 0;
  position: relative;
}
.posts-collapse .post-content .collection-year .collection-year-count {
  font-size: 0.75em;
  background: #ccc;
  border-radius: 10px;
  color: var(--content-bg-color);
  font-weight: bold;
  line-height: 1;
  margin-left: 0.35em;
  padding: 2px 5px;
  text-shadow: 1px 1px 0 rgba(0,0,0,0.1);
}
.posts-collapse .post-content .collection-year::before {
  background: #bbb;
  margin-left: -4px;
  margin-top: -4px;
  position: absolute;
  top: 50%;
  border-radius: 50%;
  content: ' ';
  height: 8px;
  width: 8px;
}
.posts-collapse .post-content .collection-header {
  display: block;
  margin-left: 20px;
}
.posts-collapse .post-content .collection-header small {
  color: #bbb;
  margin-left: 5px;
}
.posts-collapse .post-content .post-header {
  border-bottom: 1px dashed #ccc;
  margin: 30px 2px 0;
  padding-left: 15px;
  position: relative;
  transition: border 0.2s ease-in-out;
}
.posts-collapse .post-content .post-header::before {
  background: #bbb;
  border: 1px solid #fff;
  left: -6px;
  position: absolute;
  top: 0.75em;
  transition: background 0.2s ease-in-out;
  border-radius: 50%;
  content: ' ';
  height: 6px;
  width: 6px;
}
.posts-collapse .post-content .post-header:hover {
  border-bottom-color: #666;
}
.posts-collapse .post-content .post-header:hover::before {
  background: #222;
}
.posts-collapse .post-content .post-meta-container {
  display: inline;
  font-size: 0.75em;
  margin-right: 10px;
}
.posts-collapse .post-content .post-title {
  display: inline;
}
.posts-collapse .post-content .post-title a {
  border-bottom: 0;
  color: var(--link-color);
}
.posts-collapse .post-content .post-title .fa {
  font-size: 0.875em;
  margin-left: 5px;
}
.posts-collapse .post-content::before {
  background: #f5f5f5;
  content: ' ';
  height: 100%;
  margin-left: -2px;
  position: absolute;
  top: 1.25em;
  width: 4px;
}
.post-body {
  font-family: Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;
  overflow-wrap: break-word;
}
@media (min-width: 1200px) {
  .post-body {
    font-size: 1.125em;
  }
}
@media (min-width: 992px) {
  .post-body {
    text-align: justify;
  }
}
@media (max-width: 991px) {
  .post-body {
    text-align: justify;
  }
}
.post-body h1 .header-anchor,
.post-body h2 .header-anchor,
.post-body h3 .header-anchor,
.post-body h4 .header-anchor,
.post-body h5 .header-anchor,
.post-body h6 .header-anchor,
.post-body h1 .headerlink,
.post-body h2 .headerlink,
.post-body h3 .headerlink,
.post-body h4 .headerlink,
.post-body h5 .headerlink,
.post-body h6 .headerlink {
  border-bottom-style: none;
  color: inherit;
  float: right;
  font-size: 0.875em;
  margin-left: 10px;
  opacity: 0;
}
.post-body h1 .header-anchor::before,
.post-body h2 .header-anchor::before,
.post-body h3 .header-anchor::before,
.post-body h4 .header-anchor::before,
.post-body h5 .header-anchor::before,
.post-body h6 .header-anchor::before,
.post-body h1 .headerlink::before,
.post-body h2 .headerlink::before,
.post-body h3 .headerlink::before,
.post-body h4 .headerlink::before,
.post-body h5 .headerlink::before,
.post-body h6 .headerlink::before {
  content: '\f0c1';
  font-family: 'Font Awesome 6 Free';
  font-weight: 900;
}
.post-body h1:hover .header-anchor,
.post-body h2:hover .header-anchor,
.post-body h3:hover .header-anchor,
.post-body h4:hover .header-anchor,
.post-body h5:hover .header-anchor,
.post-body h6:hover .header-anchor,
.post-body h1:hover .headerlink,
.post-body h2:hover .headerlink,
.post-body h3:hover .headerlink,
.post-body h4:hover .headerlink,
.post-body h5:hover .headerlink,
.post-body h6:hover .headerlink {
  opacity: 0.5;
}
.post-body h1:hover .header-anchor:hover,
.post-body h2:hover .header-anchor:hover,
.post-body h3:hover .header-anchor:hover,
.post-body h4:hover .header-anchor:hover,
.post-body h5:hover .header-anchor:hover,
.post-body h6:hover .header-anchor:hover,
.post-body h1:hover .headerlink:hover,
.post-body h2:hover .headerlink:hover,
.post-body h3:hover .headerlink:hover,
.post-body h4:hover .headerlink:hover,
.post-body h5:hover .headerlink:hover,
.post-body h6:hover .headerlink:hover {
  opacity: 1;
}
.post-body .exturl .fa {
  font-size: 0.875em;
  margin-left: 4px;
}
.post-body figure:not(.highlight) figcaption {
  color: #999;
  font-size: 0.875em;
  font-weight: bold;
  line-height: 1;
  margin: -15px auto 15px;
  text-align: center;
}
.post-body iframe,
.post-body img,
.post-body video,
.post-body embed {
  margin-bottom: 20px;
}
.post-body .video-container {
  height: 0;
  margin-bottom: 20px;
  overflow: hidden;
  padding-top: 75%;
  position: relative;
  width: 100%;
}
.post-body .video-container iframe,
.post-body .video-container object,
.post-body .video-container embed {
  height: 100%;
  left: 0;
  margin: 0;
  position: absolute;
  top: 0;
  width: 100%;
}
.post-gallery {
  display: flex;
  min-height: 200px;
}
.post-gallery .post-gallery-image {
  flex: 1;
}
.post-gallery .post-gallery-image:not(:first-child) {
  clip-path: polygon(40px 0, 100% 0, 100% 100%, 0 100%);
  margin-left: -20px;
}
.post-gallery .post-gallery-image:not(:last-child) {
  margin-right: -20px;
}
.post-gallery .post-gallery-image img {
  height: 100%;
  object-fit: cover;
  opacity: 1;
  width: 100%;
}
.posts-expand .post-gallery {
  margin-bottom: 60px;
}
.posts-collapse .post-gallery {
  margin: 15px 0;
}
.posts-expand .post-header {
  font-size: 1.125em;
  margin-bottom: 60px;
  text-align: center;
}
.posts-expand .post-title {
  font-size: 1.5em;
  font-weight: normal;
  margin: initial;
  overflow-wrap: break-word;
}
.posts-expand .post-title-link {
  border-bottom: 0;
  color: var(--link-color);
  display: inline-block;
  max-width: 100%;
  position: relative;
}
.posts-expand .post-title-link::before {
  background: var(--link-color);
  bottom: 0;
  content: '';
  height: 2px;
  left: 0;
  position: absolute;
  transform: scaleX(0);
  transition: transform 0.2s ease-in-out;
  width: 100%;
}
.posts-expand .post-title-link:hover::before {
  transform: scaleX(1);
}
.posts-expand .post-title-link .fa {
  font-size: 0.875em;
  margin-left: 5px;
}
.post-sticky-flag {
  display: inline-block;
  margin-right: 8px;
  transform: rotate(30deg);
}
.posts-expand .post-meta-container {
  color: #999;
  font-family: Lato, 'PingFang SC', 'Microsoft YaHei', sans-serif;
  font-size: 0.75em;
  margin-top: 3px;
}
.posts-expand .post-meta-container .post-description {
  font-size: 0.875em;
  margin-top: 2px;
}
.posts-expand .post-meta-container time {
  border-bottom: 1px dashed #999;
}
.post-meta {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}
:not(.post-meta-break) + .post-meta-item::before {
  content: '|';
  margin: 0 0.5em;
}
.post-meta-item-icon {
  margin-right: 3px;
}
@media (max-width: 991px) {
  .post-meta-item-text {
    display: none;
  }
}
.post-meta-break {
  flex-basis: 100%;
  height: 0;
}
.post-nav {
  border-top: 1px solid #eee;
  display: flex;
  gap: 30px;
  justify-content: space-between;
  margin-top: 1em;
  padding: 10px 5px 0;
}
.post-nav-item {
  flex: 1;
}
.post-nav-item a {
  border-bottom: 0;
  display: block;
  font-size: 0.875em;
  line-height: 1.6;
}
.post-nav-item a:active {
  top: 2px;
}
.post-nav-item .fa {
  font-size: 0.75em;
}
.post-nav-item:first-child .fa {
  margin-right: 5px;
}
.post-nav-item:last-child {
  text-align: right;
}
.post-nav-item:last-child .fa {
  margin-left: 5px;
}
.post-footer {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.post-eof {
  background: #ccc;
  height: 1px;
  margin: 80px auto 60px;
  width: 8%;
}
.post-block:last-of-type .post-eof {
  display: none;
}
.post-tags {
  margin-top: 40px;
  text-align: center;
}
.post-tags a {
  display: inline-block;
  font-size: 0.8125em;
}
.post-tags a:not(:last-child) {
  margin-right: 10px;
}
.social-like {
  border-top: 1px solid #eee;
  font-size: 0.875em;
  margin-top: 1em;
  padding-top: 1em;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
}
.social-like a {
  border-bottom: none;
}
.reward-container {
  margin: 1em 0 0;
  padding: 1em 0;
  text-align: center;
}
.reward-container button {
  background: transparent;
  color: #fc6423;
  cursor: pointer;
  line-height: 2;
  padding: 0 15px;
  border: 2px solid #fc6423;
  border-radius: 2px;
  outline: 0;
  vertical-align: text-top;
}
.reward-container button:hover {
  background: #fc6423;
  color: #fff;
}
.post-reward {
  display: none;
  padding-top: 20px;
}
.post-reward.active {
  display: block;
}
.post-reward div {
  display: inline-block;
}
.post-reward div span {
  display: block;
}
.post-reward img {
  display: inline-block;
  margin: 0.8em 2em 0;
  max-width: 100%;
  width: 180px;
}
@keyframes next-roll {
  from {
    transform: rotateZ(30deg);
  }
  to {
    transform: rotateZ(-30deg);
  }
}
.category-all-page .category-all-title {
  text-align: center;
}
.category-all-page .category-all {
  margin-top: 20px;
}
.category-all-page .category-list {
  list-style: none;
  margin: 0;
  padding: 0;
}
.category-all-page .category-list-item {
  margin: 5px 10px;
}
.category-all-page .category-list-count {
  font-size: 0.75em;
  background: #ccc;
  border-radius: 10px;
  color: var(--content-bg-color);
  font-weight: bold;
  line-height: 1;
  margin-left: 0.35em;
  padding: 2px 5px;
  text-shadow: 1px 1px 0 rgba(0,0,0,0.1);
}
.category-all-page .category-list-child {
  padding-left: 10px;
}
.event-list hr {
  background: #222;
  margin: 20px 0 45px;
}
.event-list hr::after {
  background: #222;
  color: #fff;
  content: 'NOW';
  display: inline-block;
  font-weight: bold;
  padding: 0 5px;
}
.event-list .event {
  --event-background: #222;
  --event-foreground: #bbb;
  --event-title: #fff;
  background: var(--event-background);
  padding: 15px;
}
.event-list .event .event-summary {
  border-bottom: 0;
  color: var(--event-title);
  margin: 0;
  padding: 0 0 0 35px;
  position: relative;
}
.event-list .event .event-summary::before {
  animation: dot-flash 1s alternate infinite ease-in-out;
  background: var(--event-title);
  left: 0;
  margin-top: -6px;
  position: absolute;
  top: 50%;
  border-radius: 50%;
  content: ' ';
  height: 12px;
  width: 12px;
}
.event-list .event:nth-of-type(odd) .event-summary::before {
  animation-delay: 0.5s;
}
.event-list .event:not(:last-child) {
  margin-bottom: 20px;
}
.event-list .event .event-relative-time {
  color: var(--event-foreground);
  display: inline-block;
  font-size: 12px;
  font-weight: normal;
  padding-left: 12px;
}
.event-list .event .event-details {
  color: var(--event-foreground);
  display: block;
  line-height: 18px;
  padding: 6px 0 6px 35px;
}
.event-list .event .event-details::before {
  color: var(--event-foreground);
  display: inline-block;
  margin-right: 9px;
  width: 14px;
  font-family: 'Font Awesome 6 Free';
  font-weight: 900;
}
.event-list .event .event-details.event-location::before {
  content: '\f041';
}
.event-list .event .event-details.event-duration::before {
  content: '\f017';
}
.event-list .event .event-details.event-description::before {
  content: '\f024';
}
.event-list .event-past {
  --event-background: #f5f5f5;
  --event-foreground: #999;
  --event-title: #222;
}
@keyframes dot-flash {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.8);
  }
}
ul.breadcrumb {
  font-size: 0.75em;
  list-style: none;
  margin: 1em 0;
  padding: 0 2em;
  text-align: center;
}
ul.breadcrumb li {
  display: inline;
}
ul.breadcrumb li:not(:first-child)::before {
  content: '/\00a0';
  font-weight: normal;
  padding: 0.5em;
}
ul.breadcrumb li:last-child {
  font-weight: bold;
}
.tag-cloud {
  text-align: center;
}
.tag-cloud a {
  display: inline-block;
  margin: 10px;
}
.tag-cloud-0 {
  border-bottom-color: #aaa;
  color: #aaa;
}
.tag-cloud-1 {
  border-bottom-color: #9a9a9a;
  color: #9a9a9a;
}
.tag-cloud-2 {
  border-bottom-color: #8b8b8b;
  color: #8b8b8b;
}
.tag-cloud-3 {
  border-bottom-color: #7c7c7c;
  color: #7c7c7c;
}
.tag-cloud-4 {
  border-bottom-color: #6c6c6c;
  color: #6c6c6c;
}
.tag-cloud-5 {
  border-bottom-color: #5d5d5d;
  color: #5d5d5d;
}
.tag-cloud-6 {
  border-bottom-color: #4e4e4e;
  color: #4e4e4e;
}
.tag-cloud-7 {
  border-bottom-color: #3e3e3e;
  color: #3e3e3e;
}
.tag-cloud-8 {
  border-bottom-color: #2f2f2f;
  color: #2f2f2f;
}
.tag-cloud-9 {
  border-bottom-color: #202020;
  color: #202020;
}
.tag-cloud-10 {
  border-bottom-color: #111;
  color: #111;
}
.search-active {
  overflow: hidden;
  margin-right: var(--dialog-scrollgutter, 0);
}
.search-pop-overlay {
  background: rgba(0,0,0,0);
  display: flex;
  height: 100%;
  left: 0;
  position: fixed;
  top: 0;
  transition: visibility 0.4s, background 0.4s;
  visibility: hidden;
  width: 100%;
  z-index: 40;
}
.search-active .search-pop-overlay {
  background: rgba(0,0,0,0.3);
  visibility: visible;
}
.search-popup {
  background: var(--card-bg-color);
  border-radius: 5px;
  height: 80%;
  margin: auto;
  transform: scale(0);
  transition: transform 0.4s;
  width: 700px;
}
.search-active .search-popup {
  transform: scale(1);
}
@media (max-width: 767px) {
  .search-popup {
    border-radius: 0;
    height: 100%;
    width: 100%;
  }
}
.search-popup .search-icon,
.search-popup .popup-btn-close {
  color: #999;
  font-size: 18px;
  padding: 0 10px;
}
.search-popup .popup-btn-close {
  cursor: pointer;
}
.search-popup .popup-btn-close:hover .fa {
  color: #222;
}
.search-popup .search-header {
  background: #eee;
  border-top-left-radius: 5px;
  border-top-right-radius: 5px;
  display: flex;
  padding: 5px;
}
.search-popup input.search-input {
  background: transparent;
  border: 0;
  outline: 0;
  width: 100%;
}
.search-popup input.search-input::-webkit-search-cancel-button {
  display: none;
}
.search-popup .search-result-container {
  display: flex;
  flex-direction: column;
  height: calc(100% - 55px);
  overflow: auto;
  padding: 5px 25px;
}
.search-popup .search-result-container hr {
  flex-shrink: 0;
  margin: 5px 0 10px;
}
.search-popup .search-result-container hr:first-child {
  display: none;
}
.search-popup .search-result-list {
  margin: 0 5px;
  padding: 0;
}
.search-popup a.search-result-title {
  font-weight: bold;
}
.search-popup p.search-result {
  border-bottom: 1px dashed #ccc;
  margin: 0 0 10px;
  padding: 5px 0;
}
.search-popup .search-input-container {
  flex-grow: 1;
  padding: 2px;
}
.search-popup .search-result-icon {
  color: #ccc;
  margin: auto;
}
mark.search-keyword {
  background: transparent;
  border-bottom: 1px dashed #ff2a2a;
  color: #ff2a2a;
  font-weight: bold;
}
.use-motion .animated {
  animation-fill-mode: none;
  visibility: inherit;
}
.use-motion .sidebar .animated {
  animation-fill-mode: both;
}
header.header {
  background: var(--content-bg-color);
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);
}
@media (max-width: 991px) {
  header.header {
    border-radius: initial;
  }
}
.main {
  align-items: stretch;
  display: flex;
  justify-content: space-between;
  margin: 0 auto;
  width: calc(100% - 20px);
}
@media (max-width: 767px) {
  .main {
    width: auto;
  }
}
@media (min-width: 1200px) {
  .main {
    width: 1160px;
  }
}
@media (min-width: 1600px) {
  .main {
    width: 73%;
  }
}
@media (max-width: 991px) {
  .main {
    display: block;
    width: auto;
  }
}
.main-inner {
  border-radius: initial;
  box-sizing: border-box;
  width: calc(100% - 252px);
}
@media (max-width: 991px) {
  .main-inner {
    border-radius: initial;
    width: 100%;
  }
}
.footer-inner {
  padding-left: 252px;
}
@media (max-width: 991px) {
  .footer-inner {
    padding-left: 0;
    padding-right: 0;
    width: auto;
  }
}
.column {
  width: 240px;
}
@media (max-width: 991px) {
  .column {
    width: auto;
  }
}
.site-brand-container {
  background: var(--theme-color);
}
@media (max-width: 991px) {
  .site-nav-on .site-brand-container {
    box-shadow: 0 0 16px rgba(0,0,0,0.5);
  }
}
.site-meta {
  padding: 20px 0;
}
@media (min-width: 768px) and (max-width: 991px) {
  .site-nav-toggle,
  .site-nav-right {
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
}
.site-nav-toggle .toggle,
.site-nav-right .toggle {
  color: #fff;
}
.site-nav-toggle .toggle .toggle-line,
.site-nav-right .toggle .toggle-line {
  background: #fff;
}
@media (min-width: 768px) and (max-width: 991px) {
  .site-nav {
    --scroll-height: 0;
    height: 0;
    overflow: hidden;
    transition: 0.2s ease-in-out;
    transition-property: height, visibility;
    visibility: hidden;
  }
  body:not(.site-nav-on) .site-nav .animated {
    animation: none;
  }
  body.site-nav-on .site-nav {
    height: var(--scroll-height);
    visibility: unset;
  }
}
.menu .menu-item {
  display: block;
  margin: 0;
}
.menu .menu-item a {
  padding: 5px 20px;
  position: relative;
  transition-property: background-color;
  display: flex;
  align-items: center;
}
.menu .menu-item a .badge {
  margin-left: auto;
}
@media (max-width: 991px) {
  .menu .menu-item.menu-item-search {
    display: none;
  }
}
.main-menu .menu-item-active::after {
  background: #bbb;
  border-radius: 50%;
  content: ' ';
  height: 6px;
  margin-top: -3px;
  position: absolute;
  right: 15px;
  top: 50%;
  width: 6px;
}
.sub-menu {
  margin: 0;
  padding: 6px 0;
}
.sub-menu .menu-item {
  display: inline-block;
}
.sub-menu .menu-item a {
  background: transparent;
  margin: 5px 10px;
  padding: initial;
}
.sub-menu .menu-item a:hover {
  background: transparent;
  color: #fc6423;
}
.sub-menu .menu-item-active {
  border-bottom-color: #fc6423;
  color: #fc6423;
}
.sub-menu .menu-item-active:hover {
  border-bottom-color: #fc6423;
}
@media (min-width: 992px) {
  .sidebar {
    position: sticky;
    top: 12px;
  }
  .sidebar-toggle {
    display: none;
  }
  .sidebar-inner {
    background: var(--content-bg-color);
    border-radius: initial;
    box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);
    box-sizing: border-box;
    color: var(--text-color);
    margin-top: 12px;
    max-height: calc(100vh - 24px);
  }
  .site-state-item {
    padding: 0 10px;
  }
  .sidebar .sidebar-button {
    border-bottom: 1px dotted #ccc;
    border-top: 1px dotted #ccc;
  }
  .sidebar .sidebar-button button {
    border: 0;
    color: #fc6423;
    display: block;
    width: 100%;
  }
  .sidebar .sidebar-button button:hover {
    background: none;
    border: 0;
    color: #e34603;
  }
  .links-of-author {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
  }
  .links-of-author-item {
    margin: 5px 0 0;
    width: 50%;
  }
  .links-of-author-item a {
    border-bottom: 0;
    border-radius: 4px;
    display: block;
    padding: 0 5px;
    box-sizing: border-box;
    display: inline-block;
    max-width: 100%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .links-of-author-item a:hover {
    background: var(--body-bg-color);
  }
  .links-of-blogroll-item a {
    padding: 0 5px;
  }
}
.main-inner .sub-menu,
.main-inner .post-block,
.main-inner .tabs-comment,
.main-inner > .comments,
.main-inner .comment-position .comments,
.main-inner .pagination {
  background: var(--content-bg-color);
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);
}
.main-inner .post-block:not(:first-child):not(:first-child) {
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);
  margin-top: 12px;
}
@media (min-width: 768px) and (max-width: 991px) {
  .main-inner .post-block:not(:first-child):not(:first-child) {
    margin-top: 10px;
  }
}
@media (max-width: 767px) {
  .main-inner .post-block:not(:first-child):not(:first-child) {
    margin-top: 8px;
  }
}
.main-inner .tabs-comment,
.main-inner > .comments,
.main-inner .comment-position .comments,
.main-inner .pagination {
  border-radius: initial;
  box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);
  margin-top: 12px;
}
@media (min-width: 768px) and (max-width: 991px) {
  .main-inner .tabs-comment,
  .main-inner > .comments,
  .main-inner .comment-position .comments,
  .main-inner .pagination {
    margin-top: 10px;
  }
}
@media (max-width: 767px) {
  .main-inner .tabs-comment,
  .main-inner > .comments,
  .main-inner .comment-position .comments,
  .main-inner .pagination {
    margin-top: 8px;
  }
}
.post-block,
.comments {
  padding: 40px;
}
.post-eof {
  display: none;
}
.pagination {
  border-top: initial;
  padding: 10px 0;
}
.post-body h1,
.post-body h2 {
  border-bottom: 1px solid #eee;
}
.post-body h3 {
  border-bottom: 1px dotted #eee;
}
@media (min-width: 768px) and (max-width: 991px) {
  .main-inner {
    padding: 10px;
  }
  .posts-expand .post-button {
    margin-top: 20px;
  }
  .post-block {
    padding: 20px;
  }
  .comments {
    padding: 10px 20px;
  }
}
@media (max-width: 767px) {
  .main-inner {
    padding: 8px;
  }
  .posts-expand .post-button {
    margin: 12px 0;
  }
  .post-block {
    padding: 12px;
  }
  .comments {
    padding: 10px 12px;
  }
}
</style><noscript>
    
  </noscript>
<link rel="alternate" href="/atom.xml" title="Yue Jiao's blog" type="application/atom+xml">
<script>function loadCss(l){var d=document,h=d.head,s=d.createElement('link');s.rel='stylesheet';s.href=l;!function e(f){if (d.body)return f();setTimeout(function(){e(f)})}(function(){h.appendChild(s);});}loadCss('/style.css');loadCss('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css');</script><noscript><link rel="stylesheet" href="/style.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"></noscript></head>

<body itemscope="" itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Yue Jiao's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="Searching..." spellcheck="false" type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#introduction"><span class="nav-number">1.</span> <span class="nav-text">1. Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#starting-out"><span class="nav-number">2.</span> <span class="nav-text">2. Starting out</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#some-basic-ideas"><span class="nav-number">2.1.</span> <span class="nav-text">Some basic ideas</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#intro-to-list"><span class="nav-number">2.2.</span> <span class="nav-text">Intro to list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#texas-ranges"><span class="nav-number">2.3.</span> <span class="nav-text">Texas ranges</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list-comprehension"><span class="nav-number">2.4.</span> <span class="nav-text">List comprehension</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tuples"><span class="nav-number">2.5.</span> <span class="nav-text">Tuples</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#types-and-typeclasses"><span class="nav-number">3.</span> <span class="nav-text">3. Types and Typeclasses</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#some-basic-types"><span class="nav-number">3.1.</span> <span class="nav-text">Some basic types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#types-of-functions"><span class="nav-number">3.2.</span> <span class="nav-text">Types of functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-variables"><span class="nav-number">3.3.</span> <span class="nav-text">Type variables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#intro-to-typeclasses"><span class="nav-number">3.4.</span> <span class="nav-text">Intro to typeclasses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#some-basic-typeclasses"><span class="nav-number">3.5.</span> <span class="nav-text">Some basic typeclasses:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#syntax-in-functions"><span class="nav-number">4.</span> <span class="nav-text">4. Syntax in Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-matching"><span class="nav-number">4.1.</span> <span class="nav-text">Pattern matching</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#guards"><span class="nav-number">4.2.</span> <span class="nav-text">Guards</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#let"><span class="nav-number">4.3.</span> <span class="nav-text">Let</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#case-expressions"><span class="nav-number">4.4.</span> <span class="nav-text">Case expressions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recursion"><span class="nav-number">5.</span> <span class="nav-text">5. Recursion</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#some-recursion-examples"><span class="nav-number">5.1.</span> <span class="nav-text">Some recursion examples:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#higher-order-functions"><span class="nav-number">6.</span> <span class="nav-text">6. Higher order functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#curried-functions"><span class="nav-number">6.1.</span> <span class="nav-text">Curried functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section-an-infix-function"><span class="nav-number">6.2.</span> <span class="nav-text">Section an infix function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#some-higher-orderism-is-in-order"><span class="nav-number">6.3.</span> <span class="nav-text">Some higher-orderism is in
order</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maps-and-filters"><span class="nav-number">6.4.</span> <span class="nav-text">Maps and filters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda"><span class="nav-number">6.5.</span> <span class="nav-text">Lambda</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#foldl"><span class="nav-number">6.6.</span> <span class="nav-text">Foldl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#function-application-with"><span class="nav-number">6.7.</span> <span class="nav-text">Function application with
$</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#function-composition"><span class="nav-number">6.8.</span> <span class="nav-text">Function composition</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#modules"><span class="nav-number">7.</span> <span class="nav-text">7. Modules</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#data.list"><span class="nav-number">7.1.</span> <span class="nav-text">Data.List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#data.char"><span class="nav-number">7.2.</span> <span class="nav-text">Data.Char</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#data.map"><span class="nav-number">7.3.</span> <span class="nav-text">Data.Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#data.set"><span class="nav-number">7.4.</span> <span class="nav-text">Data.Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#your-own-modules"><span class="nav-number">7.5.</span> <span class="nav-text">Your own modules</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#make-your-own-types-and-typeclasses"><span class="nav-number">8.</span> <span class="nav-text">8. Make your own types and
typeclasses</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#algebraic-data-types"><span class="nav-number">8.1.</span> <span class="nav-text">Algebraic data types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#record-syntax"><span class="nav-number">8.2.</span> <span class="nav-text">Record syntax</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-parameters"><span class="nav-number">8.3.</span> <span class="nav-text">Type parameters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#derived-instances"><span class="nav-number">8.4.</span> <span class="nav-text">Derived instances</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-synonyms"><span class="nav-number">8.5.</span> <span class="nav-text">Type synonyms</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recursive-data-structures"><span class="nav-number">8.6.</span> <span class="nav-text">Recursive data structures</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#binary-search-tree"><span class="nav-number">8.6.1.</span> <span class="nav-text">Binary search tree</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typeclasses"><span class="nav-number">8.7.</span> <span class="nav-text">Typeclasses</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#the-functor-typeclass"><span class="nav-number">8.7.1.</span> <span class="nav-text">The Functor typeclass</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#input-and-output"><span class="nav-number">9.</span> <span class="nav-text">9. Input and Output</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hello-world"><span class="nav-number">9.1.</span> <span class="nav-text">Hello, world!</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#files-and-streams"><span class="nav-number">9.2.</span> <span class="nav-text">Files and streams</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#command-line-arguments"><span class="nav-number">9.3.</span> <span class="nav-text">Command line arguments</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-simple-todo-list-apps"><span class="nav-number">9.3.1.</span> <span class="nav-text">A simple todo list apps</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bytestrings"><span class="nav-number">9.4.</span> <span class="nav-text">Bytestrings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exceptions"><span class="nav-number">9.5.</span> <span class="nav-text">Exceptions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#functors-applicative-functors-and-monoids"><span class="nav-number">10.</span> <span class="nav-text">10. Functors,
Applicative, Functors and Monoids</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#functors-redux"><span class="nav-number">10.1.</span> <span class="nav-text">Functors redux</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#law-of-functor"><span class="nav-number">10.1.1.</span> <span class="nav-text">Law of Functor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#applicative-functors"><span class="nav-number">10.2.</span> <span class="nav-text">Applicative Functors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monoids"><span class="nav-number">10.3.</span> <span class="nav-text">Monoids</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#monoid-instance-for-ordering"><span class="nav-number">10.3.1.</span> <span class="nav-text">Monoid instance for
Ordering</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#maybe-the-monoid"><span class="nav-number">10.3.2.</span> <span class="nav-text">Maybe the Monoid</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#monads"><span class="nav-number">11.</span> <span class="nav-text">11. Monads</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#maybe-monad"><span class="nav-number">11.1.</span> <span class="nav-text">Maybe Monad</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-monad-type-class"><span class="nav-number">11.2.</span> <span class="nav-text">The monad type class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do-notation"><span class="nav-number">11.3.</span> <span class="nav-text">do notation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-list-monad"><span class="nav-number">11.4.</span> <span class="nav-text">The list monad</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#monad-laws"><span class="nav-number">11.5.</span> <span class="nav-text">Monad laws</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#add-log-to-code-with-the-writer-type"><span class="nav-number">11.6.</span> <span class="nav-text">Add log to code with the
Writer type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-apply-monad"><span class="nav-number">11.7.</span> <span class="nav-text">The apply monad</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stateful-computations"><span class="nav-number">11.8.</span> <span class="nav-text">Stateful computations</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yue Jiao</p>
  <div class="site-description" itemprop="description">Personal blog for idea sharing and archiving.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://blog.yj0.se/2022/intro-to-haskell/">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yue Jiao">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yue Jiao's blog">
      <meta itemprop="description" content="Personal blog for idea sharing and archiving.">
    </span>

    <span hidden="" itemprop="post" itemscope="" itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Introduction to Haskell Programming | Yue Jiao's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Introduction to Haskell Programming
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-09 15:05:39" itemprop="dateCreated datePublished" datetime="2022-03-09T15:05:39+01:00">2022-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-29 03:00:41" itemprop="dateModified" datetime="2022-07-29T03:00:41+02:00">2022-07-29</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>64k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time </span>
      <span>59 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>A brief introduction to haskell programming.</p>
<span id="more"></span>
<h2 id="introduction">1. Introduction</h2>
<ul>
<li>Haskell is a purely functional programming language.
<ul>
<li>You cannot set a variable to something and then set it to something
else later: No side-effects</li>
<li>If a function is called twice with the same parameters, it's
guaranteed to return the same result: Referential transparency</li>
</ul></li>
<li>Haskell is lazy: unless specifically told otherwise, Haskell won't
execute functions and calculate things until it's really forced to show
you a result. Allow infinite data structures</li>
<li>Statically typed: Its type system that has type inference.</li>
<li>Most widely used Haskell compiler: GHC</li>
</ul>
<h2 id="starting-out">2. Starting out</h2>
<h3 id="some-basic-ideas">Some basic ideas</h3>
<p>Haskell can be used as a calculator</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Some infix function</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">+, -, *, /</td>
<td style="text-align: left;">Arithmetic</td>
</tr>
<tr>
<td style="text-align: center;">==, /=, &lt;, &gt;, &lt;=, &gt;=</td>
<td style="text-align: left;">Equality</td>
</tr>
<tr>
<td style="text-align: center;">&amp;&amp;, ||</td>
<td style="text-align: left;">Logical</td>
</tr>
<tr>
<td style="text-align: center;">++</td>
<td style="text-align: left;">List concatenation</td>
</tr>
<tr>
<td style="text-align: center;">:</td>
<td style="text-align: left;">List cons</td>
</tr>
<tr>
<td style="text-align: center;">!!</td>
<td style="text-align: left;">List index access</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 74%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">Some prefix function</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">not</td>
<td style="text-align: left;">Logical</td>
</tr>
<tr>
<td style="text-align: center;">succ</td>
<td style="text-align: left;">Increase by 1</td>
</tr>
<tr>
<td style="text-align: center;">max, min</td>
<td style="text-align: left;">Comparison</td>
</tr>
<tr>
<td style="text-align: center;">head</td>
<td style="text-align: left;">First element of a list</td>
</tr>
<tr>
<td style="text-align: center;">tail</td>
<td style="text-align: left;">The list without the head element</td>
</tr>
<tr>
<td style="text-align: center;">last</td>
<td style="text-align: left;">Last element of a list</td>
</tr>
<tr>
<td style="text-align: center;">init</td>
<td style="text-align: left;">The list without the last element</td>
</tr>
<tr>
<td style="text-align: center;">length</td>
<td style="text-align: left;">Get length of a list</td>
</tr>
<tr>
<td style="text-align: center;">null</td>
<td style="text-align: left;">Check if a list is empty</td>
</tr>
<tr>
<td style="text-align: center;">reverse</td>
<td style="text-align: left;">Reverse a list</td>
</tr>
<tr>
<td style="text-align: center;">take</td>
<td style="text-align: left;">Extracts a number of elements from a
list</td>
</tr>
<tr>
<td style="text-align: center;">drop</td>
<td style="text-align: left;">Drop a number of elements from a list</td>
</tr>
<tr>
<td style="text-align: center;">minimum</td>
<td style="text-align: left;">Get min of a list</td>
</tr>
<tr>
<td style="text-align: center;">maximum</td>
<td style="text-align: left;">Get max of a list</td>
</tr>
<tr>
<td style="text-align: center;">sum</td>
<td style="text-align: left;">Get sum of a list</td>
</tr>
<tr>
<td style="text-align: center;">product</td>
<td style="text-align: left;">Get product of a list</td>
</tr>
<tr>
<td style="text-align: center;">elem</td>
<td style="text-align: left;">Check if an item is in a list</td>
</tr>
<tr>
<td style="text-align: center;">cycle</td>
<td style="text-align: left;">Cycles a list into an infinite list</td>
</tr>
<tr>
<td style="text-align: center;">repeat</td>
<td style="text-align: left;">Repeat an element into an infinite
list</td>
</tr>
<tr>
<td style="text-align: center;">replicate</td>
<td style="text-align: left;">Repeat an element for a number of
times</td>
</tr>
<tr>
<td style="text-align: center;">fst</td>
<td style="text-align: left;">Get the first component of a pair
tuple</td>
</tr>
<tr>
<td style="text-align: center;">snd</td>
<td style="text-align: left;">Get the second component of a pair
tuple</td>
</tr>
<tr>
<td style="text-align: center;">zip</td>
<td style="text-align: left;">Zips two lists to list of joining
pairs</td>
</tr>
<tr>
<td style="text-align: center;">compare</td>
<td style="text-align: left;">return GT (greater than), LT (lesser than)
or EQ</td>
</tr>
<tr>
<td style="text-align: center;">read</td>
<td style="text-align: left;">Takes a string and returns a type of Read
class</td>
</tr>
<tr>
<td style="text-align: center;">fromIntegral</td>
<td style="text-align: left;">Takes an integral and turns it into a more
general number</td>
</tr>
</tbody>
</table>
<p>Change prefix function to infix function:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(div <span class="number">42</span> <span class="number">5</span>) == (<span class="number">42</span> `div` <span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>Change back: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((+) <span class="number">42</span> <span class="number">5</span>) == (<span class="number">42</span> + <span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>First function saved as the file <strong>doubleMe.hs</strong>:
</p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleMe</span> x = x + x</span><br></pre></td></tr></tbody></table></figure> Used with: <figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :l doubleMe  </span><br><span class="line">[<span class="number">1</span> <span class="keyword">of</span> <span class="number">1</span>] <span class="type">Compiling</span> <span class="type">Main</span>             ( doubleMe.hs, interpreted )  </span><br><span class="line"><span class="type">Ok</span>, modules loaded: <span class="type">Main</span>. </span><br><span class="line"><span class="title">ghci</span>&gt; doubleMe <span class="number">9</span>  </span><br><span class="line"><span class="number">18</span>  </span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>if</code> statement is an expression which means that it
returns a value thus the <code>else</code> part of the <code>if</code>
statements in Haskell is mandatory</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sumDoubledUs</span> x y = doubleMe x + doubleMe y</span><br><span class="line"></span><br><span class="line"><span class="title">doubleSmallNumber</span> x = <span class="keyword">if</span> x &gt; <span class="number">100</span></span><br><span class="line">                        <span class="keyword">then</span> x</span><br><span class="line">                        <span class="keyword">else</span> x*<span class="number">2</span>  <span class="comment">--The else part is mandatory.</span></span><br><span class="line"></span><br><span class="line"><span class="title">conanO'Brien</span> = <span class="string">"It's a-me, Conan O'Brien!"</span>   </span><br></pre></td></tr></tbody></table></figure>
<p>Functions in Haskell don't have to be in any particular order. Thus
the order of <code>doubleMe</code> and <code>sumDoubleUs</code> is not
important</p>
<p>We usually use ' to either denote a strict version of a function (one
that isn't lazy) or a slightly modified version of a function or a
variable.</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleSmallNumber'</span> x = (<span class="keyword">if</span> x &gt; <span class="number">100</span> <span class="keyword">then</span> x <span class="keyword">else</span> x*<span class="number">2</span>) + <span class="number">1</span>  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="intro-to-list">Intro to list</h3>
<p>List is homogeneous data structure <span class="math inline">\(\rightarrow\)</span> stores elements with same
type</p>
<p></p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> lostNumbers = [<span class="number">4</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">42</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; lostNumbers</span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">42</span>]</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>To concatenate two lists:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ++ [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"hello"</span> ++ <span class="string">" "</span> ++ <span class="string">"world"</span></span><br><span class="line"><span class="string">"hello world"</span></span><br></pre></td></tr></tbody></table></figure>
<p>To use <code>++</code> operator on long strings is however slow.
<code>++</code> takes in two lists, so, even if you want to append one
element to the end of a list with <code>++</code>, you have to surround
it with square brackets so it becomes a list</p>
<p>To append an element at the beginning of a list: <code>:</code>
operator</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="string">'A'</span>:<span class="string">" SMALL CAT"</span></span><br><span class="line"><span class="string">"A SMALL CAT"</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">5</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></tbody></table></figure>
<p><code>[1,2,3]</code> is actually just syntactic sugar for
<code>1:2:3:[]</code></p>
<p>Strings are lists, <code>"hello"</code> is just syntactic sugar for
<code>['h','e','l','l','o']</code>. Thus, we can use list functions on
them</p>
<p>To get an element out of a list by index: <code>!!</code> operator,
the indices start at 0</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="string">"Steve Buscemi"</span> !! <span class="number">6</span></span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] !! <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>
<p>Lists can contain lists. The lists within a list can be of different
lengths but they can't be of different types</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> b = [[<span class="number">1</span>], [<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="title">ghci</span>&gt; b !! <span class="number">2</span></span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>Lists can be compared in lexicographical order</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] &gt; [<span class="number">2</span>,<span class="number">10</span>,<span class="number">100</span>]</span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>] &gt; [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="texas-ranges">Texas ranges</h3>
<p>A faster way to generate a list with a certain pattern</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>..<span class="number">20</span>] == [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>]  </span><br><span class="line">[<span class="string">'a'</span>..<span class="string">'z'</span>] == <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>  </span><br><span class="line">[<span class="string">'K'</span>..<span class="string">'Z'</span>] == <span class="string">"KLMNOPQRSTUVWXYZ"</span>   </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>..<span class="number">20</span>] == [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">6</span>..<span class="number">20</span>] == [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>]</span><br><span class="line">[<span class="number">20</span>,<span class="number">19</span>..<span class="number">1</span>] == [<span class="number">20</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">0.5</span>, <span class="number">0.7</span> .. <span class="number">1</span>] == [<span class="number">0.5</span>,<span class="number">0.7</span>,<span class="number">0.8999999999999999</span>,<span class="number">1.0999999999999999</span>]</span><br><span class="line"><span class="title">take</span> <span class="number">5</span> [<span class="number">13</span>,<span class="number">26</span>..] == [<span class="number">13</span>,<span class="number">26</span>,<span class="number">39</span>,<span class="number">52</span>,<span class="number">65</span>]</span><br><span class="line"><span class="title">take</span> <span class="number">10</span> (cycle [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) == [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="title">take</span> <span class="number">10</span> (repeat <span class="number">5</span>) == [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]  </span><br><span class="line"><span class="title">replicate</span> <span class="number">3</span> <span class="number">10</span> = [<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="list-comprehension">List comprehension</h3>
<p>Similar to set comprehensions. They are used for building more
specific sets out of general sets</p>
<p>The part before the pipe is called the output function</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ x*<span class="number">2</span> | x &lt;- [<span class="number">1</span>..<span class="number">10</span>], x*<span class="number">2</span> &gt;= <span class="number">12</span>] == [<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]  </span><br><span class="line">[ x | x &lt;- [<span class="number">50</span>..<span class="number">100</span>], x `mod` <span class="number">7</span> == <span class="number">3</span>] == [<span class="number">52</span>,<span class="number">59</span>,<span class="number">66</span>,<span class="number">73</span>,<span class="number">80</span>,<span class="number">87</span>,<span class="number">94</span>]</span><br><span class="line">[ x | x &lt;- [<span class="number">15</span>..<span class="number">20</span>], x /= <span class="number">17</span>, x /= <span class="number">19</span>] == [<span class="number">15</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line">[ x*y | x &lt;- [<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>], y &lt;- [<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>], x*y &gt; <span class="number">60</span>] == [<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>] </span><br><span class="line">[ (a,b,c) | c &lt;- [<span class="number">1</span>..<span class="number">20</span>], b &lt;- [<span class="number">1</span>..c], a &lt;- [<span class="number">1</span>..b], a^<span class="number">2</span> + b^<span class="number">2</span> == c^<span class="number">2</span>, gcd a b == <span class="number">1</span>, gcd b c == <span class="number">1</span>] == [(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">12</span>,<span class="number">13</span>),(<span class="number">8</span>,<span class="number">15</span>,<span class="number">17</span>)]</span><br><span class="line"><span class="title">boomBangs</span> xs = [ <span class="keyword">if</span> x &lt; <span class="number">10</span> <span class="keyword">then</span> <span class="number">2</span>*x <span class="keyword">else</span> x | x &lt;- xs, odd x]   </span><br><span class="line"><span class="title">boomBangs</span> [<span class="number">7</span>..<span class="number">13</span>] == [<span class="number">14</span>,<span class="number">18</span>,<span class="number">11</span>,<span class="number">13</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>It can be used to combines a list of adjectives and a list of
nouns:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> nouns = [<span class="string">"hobo"</span>, <span class="string">"frog"</span>, <span class="string">"pope"</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> adjectives = [<span class="string">"lazy"</span>, <span class="string">"grouchy"</span>, <span class="string">"scheming"</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [adjective ++ <span class="string">" "</span> ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]</span><br><span class="line">[<span class="string">"lazy hobo"</span>,<span class="string">"lazy frog"</span>,<span class="string">"lazy pope"</span>,<span class="string">"grouchy hobo"</span>,<span class="string">"grouchy frog"</span>,<span class="string">"grouchy pope"</span>,<span class="string">"scheming hobo"</span>,<span class="string">"scheming frog"</span>,<span class="string">"scheming pope"</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>We can implement our own <code>length</code>:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">length'</span> xs = sum [<span class="number">1</span> | _ &lt;- xs]   </span><br></pre></td></tr></tbody></table></figure>
<p>Here <code>_</code> means that we don't care what the output is</p>
<p>To work on strings:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">removeNonUppercase</span> st = [ c | c &lt;- st, c `elem` [<span class="string">'A'</span>..<span class="string">'Z'</span>]]   </span><br><span class="line"><span class="title">removeNonUppercase</span> <span class="string">"Hahhhah! Ahahahha"</span> == <span class="string">"HA"</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="tuples">Tuples</h3>
<p>Tuples are similar to lists. The fundamental differences are:</p>
<ul>
<li>Tuples have fixed size</li>
<li>Tuples is NOT homogeneous.</li>
<li>Tuples define its own type. <code>[(1,2),(8,11,5),(4,5)]</code> or
<code>[(1,2),("One",2)]</code> are not valid syntactically because they
have different types</li>
</ul>
<p>Two useful functions that operate on pairs:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fst (<span class="number">8</span>, <span class="number">11</span>)</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="title">ghci</span>&gt; snd (<span class="number">8</span>, <span class="number">11</span>)</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></tbody></table></figure>
<p>A cool function that produces a list of pairs: <code>zip</code>. It
takes two lists and then zips them together into one list by joining the
matching elements into pairs</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span> .. <span class="number">5</span>] [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"five"</span>]</span><br><span class="line">[(<span class="number">1</span>,<span class="string">"one"</span>),(<span class="number">2</span>,<span class="string">"two"</span>),(<span class="number">3</span>,<span class="string">"three"</span>),(<span class="number">4</span>,<span class="string">"four"</span>),(<span class="number">5</span>,<span class="string">"five"</span>)]</span><br><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] [<span class="string">"im"</span>, <span class="string">"a"</span>, <span class="string">"turtle"</span>]</span><br><span class="line">[(<span class="number">1</span>,<span class="string">"im"</span>),(<span class="number">2</span>,<span class="string">"a"</span>),(<span class="number">3</span>,<span class="string">"turtle"</span>)]</span><br><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span> ..] [<span class="string">"apple"</span>, <span class="string">"orange"</span>,<span class="string">"cherry"</span>,<span class="string">"mango"</span>]</span><br><span class="line">[(<span class="number">1</span>,<span class="string">"apple"</span>),(<span class="number">2</span>,<span class="string">"orange"</span>),(<span class="number">3</span>,<span class="string">"cherry"</span>),(<span class="number">4</span>,<span class="string">"mango"</span>)]</span><br></pre></td></tr></tbody></table></figure>
<p>A cool example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> rightTriangles = [(a,b,c) | c &lt;- [<span class="number">1</span>..<span class="number">20</span>], b &lt;- [<span class="number">1</span>..c], a &lt;- [<span class="number">1</span>..b], a^<span class="number">2</span> + b^<span class="number">2</span> == c^<span class="number">2</span>]</span><br><span class="line">[(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>),(<span class="number">5</span>,<span class="number">12</span>,<span class="number">13</span>),(<span class="number">9</span>,<span class="number">12</span>,<span class="number">15</span>),(<span class="number">8</span>,<span class="number">15</span>,<span class="number">17</span>),(<span class="number">12</span>,<span class="number">16</span>,<span class="number">20</span>)]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="types-and-typeclasses">3. Types and Typeclasses</h2>
<h3 id="some-basic-types">Some basic types</h3>
<p>A type is a kind of label that every expression has. It tells us in
which category of things that expression fits. A type is written in
capital case</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Type</th>
<th style="text-align: center;">Range</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Int</td>
<td style="text-align: center;">2147483647 to -2147483648 on 32-bit
machine</td>
</tr>
<tr>
<td style="text-align: center;">Integer</td>
<td style="text-align: center;">No boundary</td>
</tr>
<tr>
<td style="text-align: center;">Float</td>
<td style="text-align: center;">Single precision</td>
</tr>
<tr>
<td style="text-align: center;">Double</td>
<td style="text-align: center;">Double precision</td>
</tr>
<tr>
<td style="text-align: center;">Bool</td>
<td style="text-align: center;">True or False</td>
</tr>
<tr>
<td style="text-align: center;">Char</td>
<td style="text-align: center;">A character</td>
</tr>
</tbody>
</table>
<p>Unlike Java or Pascal, Haskell has type inference. Haskell can infer
some type based on context</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t <span class="string">'a'</span></span><br><span class="line"><span class="string">'a'</span> :: <span class="type">Char</span></span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">True</span></span><br><span class="line"><span class="type">True</span> :: <span class="type">Bool</span></span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="string">"Hello"</span></span><br><span class="line"><span class="string">"Hello"</span> :: [<span class="type">Char</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; :t (<span class="type">True</span>, <span class="string">'a'</span>)</span><br><span class="line">(<span class="type">True</span>, <span class="string">'a'</span>) :: (<span class="type">Bool</span>, <span class="type">Char</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><code>::</code> is read as "has type of"</p>
<h3 id="types-of-functions">Types of functions</h3>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">removeNonUppercase</span> :: [<span class="type">Char</span>] -&gt; [<span class="type">Char</span>]  </span><br><span class="line"><span class="title">removeNonUppercase</span> st = [ c | c &lt;- st, c `elem` [<span class="string">'A'</span>..<span class="string">'Z'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="title">addThree</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">addThree</span> x y z = x + y + z</span><br></pre></td></tr></tbody></table></figure>
<p>The parameters are separated with <code>-&gt;</code> and there's no
special distinction between the parameters and the return type</p>
<h3 id="type-variables">Type variables</h3>
<p>For example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; : t head</span><br><span class="line"><span class="title">head</span> :: [a] -&gt; a</span><br></pre></td></tr></tbody></table></figure>
<p>Here <code>a</code> is a type variable which means that
<code>a</code> can be of any type. Functions that have type variables
are called polymorphic functions. Another example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t fst</span><br><span class="line"><span class="title">fst</span> :: (a, b) -&gt; a</span><br></pre></td></tr></tbody></table></figure>
<h3 id="intro-to-typeclasses">Intro to typeclasses</h3>
<p>A typeclass is a sort of interface that defines some behaviour. If a
type is a part of a typeclass, that means that it supports and
implements the behaviour the typeclass describes</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t (==)  </span><br><span class="line">(==) :: (<span class="type">Eq</span> a) =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></tbody></table></figure>
<p>Everything before the <code>=&gt;</code> symbol is called a class
constraint. The type of those two values must be a member of the
<code>Eq</code> class. This was the class constraint</p>
<p>The <code>Eq</code> typeclass provides an interface for testing for
equality. Any type where it makes sense to test for equality between two
values of that type should be a member of the <code>Eq</code> class</p>
<h3 id="some-basic-typeclasses">Some basic typeclasses:</h3>
<ul>
<li><p><code>Eq</code> is used for types that support equality
testing</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">5</span> == <span class="number">5</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">'a'</span> == <span class="string">'a'</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">3.432</span> == <span class="number">3.432</span></span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>Ord</code> members have an ordering. The be a member of
<code>Ord</code>, a type must first have membership in the prestigious
and exclusive <code>Eq</code> club</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t (&gt;)  </span><br><span class="line">(&gt;) :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"Abrakadabra"</span> &lt; <span class="string">"Zebra"</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"Abrakadabra"</span> `compare` <span class="string">"Zebra"</span></span><br><span class="line"><span class="type">LT</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">5</span> `compare` <span class="number">3</span></span><br><span class="line"><span class="type">GT</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>Show</code> members can be presented as strings</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; show <span class="number">3</span></span><br><span class="line"><span class="string">"3"</span></span><br><span class="line"><span class="title">ghci</span>&gt; show <span class="number">5.334</span></span><br><span class="line"><span class="string">"5.334"</span></span><br><span class="line"><span class="title">ghci</span>&gt; show <span class="type">True</span></span><br><span class="line"><span class="string">"True"</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>Read</code> members values can be extract from a string</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; read <span class="string">"True"</span> || <span class="type">False</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="title">ghci</span>&gt; read <span class="string">"[1,2,3,4]"</span> ++ [<span class="number">3</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]  </span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>But we cannot run for example <code>read "4"</code>, the GHCI
will give an error because it doesn't know what we want in return. It
knows we want some type that is part of the <code>Read</code> class, it
doesn't know which one</p></li>
<li><p>Thus we must use explicit type annotations, which is a way of
explicitly saying what the type of expression should be. We do that by
adding <code>::</code> at the end of the expression and then specifying
a type</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; read <span class="string">"5"</span> :: <span class="type">Int</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; read <span class="string">"5"</span> :: <span class="type">Float</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="title">ghci</span>&gt; read <span class="string">"[1,2,3,4]"</span> :: [<span class="type">Int</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; read <span class="string">"(3, 'a')"</span> :: (<span class="type">Int</span>, <span class="type">Char</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">'a'</span>)</span><br></pre></td></tr></tbody></table></figure></li>
</ul></li>
<li><p><code>Enum</code> members are sequentially ordered types</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="string">'a'</span>..<span class="string">'e'</span>]</span><br><span class="line"><span class="string">"abcde"</span></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="type">LT</span> .. <span class="type">GT</span>]</span><br><span class="line">[<span class="type">LT</span>,<span class="type">EQ</span>,<span class="type">GT</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; succ <span class="string">'B'</span></span><br><span class="line"><span class="string">'C'</span></span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>Bounded</code> members have an upper and a lower bound</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; minBound :: <span class="type">Int</span></span><br><span class="line">-<span class="number">9223372036854775808</span></span><br><span class="line"><span class="title">ghci</span>&gt; maxBound :: <span class="type">Char</span></span><br><span class="line">'\<span class="number">1114111</span>'</span><br><span class="line"><span class="title">ghci</span>&gt; maxBound :: (<span class="type">Bool</span>, <span class="type">Int</span>, <span class="type">Char</span>)</span><br><span class="line">(<span class="type">True</span>,<span class="number">9223372036854775807</span>,'\<span class="number">1114111</span>')</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>Num</code> members have the property of being able to act
like numbers</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">20</span> :: <span class="type">Int</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">20</span> :: <span class="type">Integer</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">20</span> :: <span class="type">Float</span></span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">20</span> :: <span class="type">Double</span></span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="title">ghci</span>&gt; :t (*)</span><br><span class="line">(*) :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>Integral</code> members represent integers.
<code>Num</code> includes all numbers, including real numbers and
integral numbers, <code>Integral</code> includes only integral (whole)
numbers. In this typeclass are <code>Int</code> and
<code>Integer</code></p></li>
<li><p><code>Floating</code> members includes only floating point
numbers, so <code>Float</code> and <code>Double</code></p></li>
</ul>
<p>A very useful function for dealing with numbers is
<code>fromIntegral</code>. It has a type declaration of
<code>fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b</code>. That's
useful when you want integral and floating point types to work together
nicely. For example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fromIntegral</span> (length [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) + <span class="number">3.2</span> == <span class="number">7.2</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="syntax-in-functions">4. Syntax in Functions</h2>
<h3 id="pattern-matching">Pattern matching</h3>
<p>Pattern matching consists of specifying patterns to which some data
should conform and then checking to see if it does and deconstructing
the data according to those patterns</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lucky</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">lucky</span> <span class="number">7</span> = <span class="string">"LUCKY NUMBER SEVEN!"</span></span><br><span class="line"><span class="title">lucky</span> x = <span class="string">"Sorry, you're out of luck, pal!"</span></span><br></pre></td></tr></tbody></table></figure>
<p>When you call <code>lucky</code>, the patterns will be checked from
top to bottom and when it conforms to a pattern, the corresponding
function body will be used</p>
<p>Some examples:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">factorial</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">factorial</span> <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="title">factorial</span> n = n * factorial (n - <span class="number">1</span>)  </span><br><span class="line"></span><br><span class="line"><span class="title">addVectors</span> :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)  </span><br><span class="line"><span class="title">addVectors</span> (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)  </span><br><span class="line"></span><br><span class="line"><span class="title">first</span> :: (a, b, c) -&gt; a  </span><br><span class="line"><span class="title">first</span> (x, _, _) = x  </span><br><span class="line">  </span><br><span class="line"><span class="title">second</span> :: (a, b, c) -&gt; b  </span><br><span class="line"><span class="title">second</span> (_, y, _) = y  </span><br><span class="line"></span><br><span class="line"><span class="title">third</span> :: (a, b, c) -&gt; c</span><br><span class="line"><span class="title">third</span> (_, _, z) = z</span><br></pre></td></tr></tbody></table></figure>
<p>We can also pattern match in list comprehensions. Should a pattern
match fail, it will just move on to the next element</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> xs = [(<span class="number">1</span>,<span class="number">3</span>), (<span class="number">4</span>,<span class="number">5</span>), (<span class="number">6</span>,<span class="number">7</span>), (<span class="number">10</span>,<span class="number">12</span>)]</span><br><span class="line"><span class="title">ghci</span>&gt; [a+b | (a,b) &lt;- xs]</span><br><span class="line">[<span class="number">4</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">22</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>The following examples show some pattern matches in list
comprehensions</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">head'</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head'</span> [] = error <span class="string">"Can't call head on an empty list, dummy!"</span>  </span><br><span class="line"><span class="title">head'</span> (x:_) = x  </span><br><span class="line"></span><br><span class="line"><span class="title">length'</span> :: (<span class="type">Num</span> b) =&gt; [a] -&gt; b  </span><br><span class="line"><span class="title">length'</span> [] = <span class="number">0</span>  </span><br><span class="line"><span class="title">length'</span> (_:xs) = <span class="number">1</span> + length' xs  </span><br><span class="line"></span><br><span class="line"><span class="title">sum'</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">sum'</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sum'</span> (x:xs) = x + sum' xs</span><br></pre></td></tr></tbody></table></figure>
<p>There is also a thing called as patterns. Those are a handy way of
breaking something up according to a pattern and binding it to names
whilst still keeping a reference to the whole thing</p>
<p>You can do that by putting a name and an <code>@</code> in front of a
pattern. For instance, the pattern <code>xs@(x:y:ys)</code>. This
pattern will match exactly the same things as <code>x:y:ys</code> but
you can easily get the whole list via <code>xs</code></p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">capital</span> :: <span class="type">String</span> -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">capital</span> <span class="string">""</span> = <span class="string">"Empty string, whoops!"</span>  </span><br><span class="line"><span class="title">capital</span> all@(x:xs) = <span class="string">"The first letter of "</span> ++ all ++ <span class="string">" is "</span> ++ [x]  </span><br></pre></td></tr></tbody></table></figure>
<p>You can't use <code>++</code> in pattern matches. If you tried to
pattern match against <code>(xs ++ ys)</code>, Haskell will not be able
to decide what would be in the first and what would be in the second
list</p>
<h3 id="guards">Guards</h3>
<p>Guards are a way of testing whether some property of a value (or
several of them) are true or false. The guars are a lot more readable
when you have several conditions</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">bmiTell</span> weight height  </span><br><span class="line">    | bmi &lt;= skinny = <span class="string">"You're underweight, you emo, you!"</span>  </span><br><span class="line">    | bmi &lt;= normal = <span class="string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>  </span><br><span class="line">    | bmi &lt;= fat    = <span class="string">"You're fat! Lose some weight, fatty!"</span>  </span><br><span class="line">    | otherwise     = <span class="string">"You're a whale, congratulations!"</span>  </span><br><span class="line">    <span class="keyword">where</span> bmi = weight / height ^ <span class="number">2</span>  </span><br><span class="line">          skinny = <span class="number">18.5</span>  </span><br><span class="line">          normal = <span class="number">25.0</span>  </span><br><span class="line">          fat = <span class="number">30.0</span>  </span><br><span class="line">          </span><br><span class="line"><span class="title">max'</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; a  </span><br><span class="line"><span class="title">max'</span> a b </span><br><span class="line">	| a &gt; b = a </span><br><span class="line">	| otherwise = b  </span><br><span class="line"></span><br><span class="line"><span class="title">myCompare</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="type">Ordering</span>  </span><br><span class="line"><span class="title">a</span> `myCompare` b  </span><br><span class="line">    | a &gt; b     = <span class="type">GT</span>  </span><br><span class="line">    | a == b    = <span class="type">EQ</span>  </span><br><span class="line">    | otherwise = <span class="type">LT</span>           </span><br></pre></td></tr></tbody></table></figure>
<p><code>otherwise</code> is defined simply as
<code>otherwise = True</code> and catches everything. We put the keyword
<code>where</code> after the guards and then we define several names or
functions. These names are visible only across the guards. All the names
in <code>where</code> should be aligned at a single column, otherwise
Haskell will get confused</p>
<h3 id="let">Let</h3>
<p><code>let</code> bindings let you bind to variables anywhere and are
expressions themselves but are local. <code>let</code> bindings bind
values to names, it can be used for pattern matching</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cylinder</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; a  </span><br><span class="line"><span class="title">cylinder</span> r h = </span><br><span class="line">    <span class="keyword">let</span> sideArea = <span class="number">2</span> * pi * r * h  </span><br><span class="line">        topArea = pi * r ^<span class="number">2</span>  </span><br><span class="line">    <span class="keyword">in</span>  sideArea + <span class="number">2</span> * topArea  </span><br><span class="line"></span><br><span class="line"><span class="title">calcBmis</span> :: (<span class="type">RealFloat</span> a) =&gt; [(a, a)] -&gt; [a]  </span><br><span class="line"><span class="title">calcBmis</span> xs = [bmi | (w, h) &lt;- xs, <span class="keyword">let</span> bmi = w / h ^ <span class="number">2</span>, bmi &gt;= <span class="number">25.0</span>]  </span><br></pre></td></tr></tbody></table></figure>
<p>The names that you define in the <code>let</code> part are accessible
to the expression after the <code>in</code> part</p>
<p>The difference between <code>let</code> and <code>where</code> is
that <code>let</code> bindings are expressions themselves.
<code>where</code> bindings are just syntactic constructs. We can do the
following with <code>let</code>:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> * (<span class="keyword">if</span> <span class="number">10</span> &gt; <span class="number">5</span> <span class="keyword">then</span> <span class="number">10</span> <span class="keyword">else</span> <span class="number">0</span>) + <span class="number">2</span>  </span><br><span class="line"><span class="number">42</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> * (<span class="keyword">let</span> a = <span class="number">9</span> <span class="keyword">in</span> a + <span class="number">1</span>) + <span class="number">2</span>  </span><br><span class="line"><span class="number">42</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; (<span class="keyword">let</span> a = <span class="number">100</span>; b = <span class="number">200</span>; c = <span class="number">300</span> <span class="keyword">in</span> a*b*c, <span class="keyword">let</span> foo=<span class="string">"Hey "</span>; bar=<span class="string">"there!"</span> <span class="keyword">in</span> foo++bar)</span><br><span class="line">(<span class="number">6000000</span>,<span class="string">"Hey there!"</span>)</span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> zoot x y z = x * y + z  </span><br><span class="line"><span class="title">ghci</span>&gt; zoot <span class="number">3</span> <span class="number">9</span> <span class="number">2</span>  </span><br><span class="line"><span class="number">29</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> boot x y z = x * y + z <span class="keyword">in</span> boot <span class="number">3</span> <span class="number">4</span> <span class="number">2</span>  </span><br><span class="line"><span class="number">14</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; boot  </span><br><span class="line">&lt;interactive&gt;:<span class="number">1</span>:<span class="number">0</span>: <span class="type">Not</span> <span class="keyword">in</span> scope: `boot'  </span><br></pre></td></tr></tbody></table></figure>
<p>The <code>in</code> part can be omitted when defining functions and
constants, then the names will be visible throughout the entire
interactive session</p>
<h3 id="case-expressions">Case expressions</h3>
<p>Case expressions are expressions. We can evaluate expressions based
on the possible cases of the value of a variable, we can also do pattern
matching. We can rewrite the <code>head'</code> above in the following
way</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">head'</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">head'</span> xs = <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; error <span class="string">"No head for empty lists"</span></span><br><span class="line">					  (x:_) -&gt; x</span><br></pre></td></tr></tbody></table></figure>
<p>The syntax for case expressions is pretty simple:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">case</span> expression <span class="keyword">of</span> pattern -&gt; result</span><br><span class="line">				   pattern -&gt; result</span><br><span class="line">				   pattern -&gt; result</span><br><span class="line">				   ...				   </span><br></pre></td></tr></tbody></table></figure>
<p>Whereas pattern matching on function parameters can only be done when
defining functions, case expressions can be used pretty much anywhere.
For instance:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">describeList</span> :: [a] -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">describeList</span> xs = <span class="string">"The list is "</span> ++ <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; <span class="string">"empty."</span>  </span><br><span class="line">                                               [x] -&gt; <span class="string">"a singleton list."</span>   </span><br><span class="line">                                               xs -&gt; <span class="string">"a longer list."</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">describeList'</span> :: [a] -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">describeList'</span> xs = <span class="string">"The list is "</span> ++ what xs  </span><br><span class="line">    <span class="keyword">where</span> what [] = <span class="string">"empty."</span>  </span><br><span class="line">          what [x] = <span class="string">"a singleton list."</span>  </span><br><span class="line">          what xs = <span class="string">"a longer list."</span>  </span><br></pre></td></tr></tbody></table></figure>
<h2 id="recursion">5. Recursion</h2>
<h3 id="some-recursion-examples">Some recursion examples:</h3>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maximum'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a  </span><br><span class="line"><span class="title">maximum'</span> [] = error <span class="string">"maximum of empty list"</span>  </span><br><span class="line"><span class="title">maximum'</span> [x] = x  </span><br><span class="line"><span class="title">maximum'</span> (x:xs) = max x (maximum' xs)  </span><br><span class="line"></span><br><span class="line"><span class="title">replicate'</span> :: (<span class="type">Num</span> i, <span class="type">Ord</span> i) =&gt; i -&gt; a -&gt; [a]  </span><br><span class="line"><span class="title">replicate'</span> n x  </span><br><span class="line">    | n &lt;= <span class="number">0</span>    = []  </span><br><span class="line">    | otherwise = x:replicate' (n-<span class="number">1</span>) x  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- take' 3 [5,4,3,2,1] ==&gt; [5,4,3]</span></span><br><span class="line"><span class="title">take'</span> :: (<span class="type">Num</span> i, <span class="type">Ord</span> i) =&gt; i -&gt; [a] -&gt; [a]  </span><br><span class="line"><span class="title">take'</span> n _  </span><br><span class="line">    | n &lt;= <span class="number">0</span>   = []  </span><br><span class="line"><span class="title">take'</span> _ []     = []  </span><br><span class="line"><span class="title">take'</span> n (x:xs) = x : take' (n-<span class="number">1</span>) xs  </span><br><span class="line"></span><br><span class="line"><span class="title">reverse'</span> :: [a] -&gt; [a]  </span><br><span class="line"><span class="title">reverse'</span> [] = []  </span><br><span class="line"><span class="title">reverse'</span> (x:xs) = reverse' xs ++ [x]  </span><br><span class="line"></span><br><span class="line"><span class="title">zip'</span> :: [a] -&gt; [b] -&gt; [(a,b)]  </span><br><span class="line"><span class="title">zip'</span> _ [] = []  </span><br><span class="line"><span class="title">zip'</span> [] _ = []  </span><br><span class="line"><span class="title">zip'</span> (x:xs) (y:ys) = (x,y):zip' xs ys  </span><br><span class="line"></span><br><span class="line"><span class="title">elem'</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span>  </span><br><span class="line"><span class="title">elem'</span> a [] = <span class="type">False</span>  </span><br><span class="line"><span class="title">elem'</span> a (x:xs)  </span><br><span class="line">    | a == x    = <span class="type">True</span>  </span><br><span class="line">    | otherwise = a `elem'` xs   </span><br><span class="line"></span><br><span class="line"><span class="title">quicksort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]  </span><br><span class="line"><span class="title">quicksort</span> [] = []  </span><br><span class="line"><span class="title">quicksort</span> (x:xs) =   </span><br><span class="line">    <span class="keyword">let</span> smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x]  </span><br><span class="line">        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]  </span><br><span class="line">    <span class="keyword">in</span>  smallerSorted ++ [x] ++ biggerSorted  </span><br></pre></td></tr></tbody></table></figure>
<h2 id="higher-order-functions">6. Higher order functions</h2>
<p>Haskell functions can take functions as parameters and return
functions as return values. A function that does either of those is
called a higher order function</p>
<h3 id="curried-functions">Curried functions</h3>
<p>Every function in Haskell officially only takes one parameter. All
the functions that accept several parameters have been curried
functions. For example:</p>
<p><code>max :: (Ord a) =&gt; a -&gt; a -&gt; a</code> is the same as
<code>max :: (Ord a) =&gt; a -&gt; (a -&gt; a)</code></p>
<p>The following two calls are equivalent:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; max <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; (max <span class="number">4</span>) <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
<p>If we call a function with too few parameters, we get back a
partially applied function. Using partial application is a neat way to
create functions on the fly so we can pass them to another function or
to seed them with some data. For example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">multThree</span> :: (<span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; a  </span><br><span class="line"><span class="title">multThree</span> x y z = x * y * z  </span><br></pre></td></tr></tbody></table></figure>
<p>Then </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> multTwoWithNine = multThree <span class="number">9</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; multTwoWithNine <span class="number">2</span> <span class="number">3</span>  </span><br><span class="line"><span class="number">54</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> multWithEighteen = multTwoWithNine <span class="number">2</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; multWithEighteen <span class="number">10</span>  </span><br><span class="line"><span class="number">180</span>  </span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Another way of writing it</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compareWithHundred</span> :: (<span class="type">Num</span> a, <span class="type">Ord</span> a) =&gt; a -&gt; <span class="type">Ordering</span></span><br><span class="line"><span class="title">compareWithHundred</span> = compare <span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="section-an-infix-function">Section an infix function</h3>
<p>To section an infix function, simply surround it with parentheses and
only supply a parameter on one side: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">divideByTen</span> :: (<span class="type">Floating</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">divideByTen</span> = (/<span class="number">10</span>)  </span><br><span class="line"></span><br><span class="line"><span class="title">isUpperAlphanum</span> :: <span class="type">Char</span> -&gt; <span class="type">Bool</span>  </span><br><span class="line"><span class="title">isUpperAlphanum</span> = (`elem` [<span class="string">'A'</span>..<span class="string">'Z'</span>])  </span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="some-higher-orderism-is-in-order">Some higher-orderism is in
order</h3>
<p>Functions can take functions as parameters and also return functions.
Note that the parentheses in the following examples are mandatory. They
indicate that the first parameter are functions</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">applyTwice</span> :: (a -&gt; a) -&gt; a -&gt; a  </span><br><span class="line"><span class="title">applyTwice</span> f x = f (f x)  </span><br><span class="line"></span><br><span class="line"><span class="title">zipWith'</span> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]  </span><br><span class="line"><span class="title">zipWith'</span> _ [] _ = []  </span><br><span class="line"><span class="title">zipWith'</span> _ _ [] = []  </span><br><span class="line"><span class="title">zipWith'</span> f (x:xs) (y:ys) = f x y : zipWith' f xs ys  </span><br><span class="line"></span><br><span class="line"><span class="title">flip'</span> :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)  </span><br><span class="line"><span class="title">flip'</span> f = g  </span><br><span class="line">    <span class="keyword">where</span> g x y = f y x  </span><br></pre></td></tr></tbody></table></figure>
<p>Applying: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; applyTwice (+<span class="number">3</span>) <span class="number">10</span>  </span><br><span class="line"><span class="number">16</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; applyTwice (++ <span class="string">" HAHA"</span>) <span class="string">"HEY"</span>  </span><br><span class="line"><span class="string">"HEY HAHA HAHA"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; applyTwice (<span class="string">"HAHA "</span> ++) <span class="string">"HEY"</span>  </span><br><span class="line"><span class="string">"HAHA HAHA HEY"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; applyTwice (<span class="number">3</span>:) [<span class="number">1</span>]  </span><br><span class="line">[<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; zipWith' (+) [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] [<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">[<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith' max [<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]  </span><br><span class="line">[<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith' (++) [<span class="string">"foo "</span>, <span class="string">"bar "</span>, <span class="string">"baz "</span>] [<span class="string">"fighters"</span>, <span class="string">"hoppers"</span>, <span class="string">"aldrin"</span>]  </span><br><span class="line">[<span class="string">"foo fighters"</span>,<span class="string">"bar hoppers"</span>,<span class="string">"baz aldrin"</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith' (*) (replicate <span class="number">5</span> <span class="number">2</span>) [<span class="number">1</span>..]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]  </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="maps-and-filters">Maps and filters</h3>
<p><code>map</code> takes a function and a list and applies that
function to every element in the list, producing a new list. Its
definition:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]  </span><br><span class="line"><span class="title">map</span> _ [] = []  </span><br><span class="line"><span class="title">map</span> f (x:xs) = f x : map f xs  </span><br></pre></td></tr></tbody></table></figure>
<p><code>filter</code> is a function that takes a predicate (a predicate
is a function that tells whether somethign is true or not) and a list
and then returns the list of elements that satisfy the predicate. Its
definition:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filter</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]  </span><br><span class="line"><span class="title">filter</span> _ [] = []  </span><br><span class="line"><span class="title">filter</span> p (x:xs)   </span><br><span class="line">    | p x       = x : filter p xs  </span><br><span class="line">    | otherwise = filter p xs  </span><br></pre></td></tr></tbody></table></figure>
<p>With them, we can implement quicksort easily:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">quicksort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]    </span><br><span class="line"><span class="title">quicksort</span> [] = []    </span><br><span class="line"><span class="title">quicksort</span> (x:xs) =     </span><br><span class="line">    <span class="keyword">let</span> smallerSorted = quicksort (filter (&lt;=x) xs)  </span><br><span class="line">        biggerSorted = quicksort (filter (&gt;x) xs)   </span><br><span class="line">    <span class="keyword">in</span>  smallerSorted ++ [x] ++ biggerSorted  </span><br></pre></td></tr></tbody></table></figure>
<p><code>filter</code> doesn't work on infinite lists while
<code>takeWhile</code> does. Eg. find the sum of all odd squares that
are smaller than 10,000</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; sum (takeWhile (&lt;<span class="number">10000</span>) (filter odd (map (^<span class="number">2</span>) [<span class="number">1</span>..])))  </span><br><span class="line"><span class="number">166650</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; sum (takeWhile (&lt;<span class="number">10000</span>) [n^<span class="number">2</span> | n &lt;- [<span class="number">1</span>..], odd (n^<span class="number">2</span>)])  </span><br><span class="line"><span class="number">166650</span>  </span><br></pre></td></tr></tbody></table></figure>
<p>Generate Collatz sequences</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">chain</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; [a]  </span><br><span class="line"><span class="title">chain</span> <span class="number">1</span> = [<span class="number">1</span>]  </span><br><span class="line"><span class="title">chain</span> n  </span><br><span class="line">    | even n =  n:chain (n `div` <span class="number">2</span>)  </span><br><span class="line">    | odd n  =  n:chain (n*<span class="number">3</span> + <span class="number">1</span>)  </span><br></pre></td></tr></tbody></table></figure>
<p>Applying</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; chain <span class="number">10</span>  </span><br><span class="line">[<span class="number">10</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br></pre></td></tr></tbody></table></figure>
<p>Another example is:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> listOfFuns = map (*) [<span class="number">0</span>..]</span><br><span class="line"><span class="title">ghci</span>&gt; (listOfFuns !! <span class="number">4</span>) <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
<p>What happens here is that the number in the list is applied to the
function <code>*</code>, which has a type of
<code>(Num a) =&gt; a -&gt; a -&gt; a</code>. Applying only one
parameter to a function that takes two parameters returns a function
that takes one parameter. If we map <code>*</code> over the list
<code>[0..]</code>, we get back a list of functions that only take one
parameter. So this function produces a list like
<code>[(0*), (1*), (2*), (3*), (4*), ...]</code>. Thus the fourth
element is <code>(4*)</code> and it gives 20 when it applied to 5</p>
<h3 id="lambda">Lambda</h3>
<p>Lambdas are basically anonymous function. To make a lambda, we write
a <code>\</code> and then we write the parameters, separated by spaces.
After that comes a <code>-&gt;</code> and then the function body. We
usually surround them by parentheses, because otherwise they extend all
the way to the right</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> (\(a,b) -&gt; a + b) [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">6</span>),(<span class="number">2</span>,<span class="number">5</span>)]  </span><br><span class="line"></span><br><span class="line"><span class="title">addThree</span> :: (<span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; a  </span><br><span class="line"><span class="title">addThree</span> = \x -&gt; \y -&gt; \z -&gt; x + y + z  </span><br><span class="line"></span><br><span class="line"><span class="title">flip'</span> :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c  </span><br><span class="line"><span class="title">flip'</span> f = \x y -&gt; f y x  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="foldl">Foldl</h3>
<p><code>foldl</code> - fold a list from left. It needs a binary
function. The binary function is applied between the starting value and
the head of the list. That produces a new accumulator value and the
binary function is called with that value and the next element, etc. For
example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum'</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">sum'</span> xs = foldl (\acc x -&gt; acc + x) <span class="number">0</span> xs</span><br><span class="line"></span><br><span class="line"><span class="title">sum''</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a  </span><br><span class="line"><span class="title">sum''</span> = foldl (+) <span class="number">0</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">elem'</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span>  </span><br><span class="line"><span class="title">elem'</span> y ys = foldl (\acc x -&gt; <span class="keyword">if</span> x == y <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> acc) <span class="type">False</span> ys  </span><br></pre></td></tr></tbody></table></figure>
<p><code>foldr</code> - fold a list from right. The starting value and
the list swapped places. To generate a list as the result, right fold
append is faster. Also only right fold work on infinite list.</p>
<p>The accumulator value (and hence, the result) of a fold can be of any
type. It can be a number, a boolean or even a new list. For example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map'</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]  </span><br><span class="line"><span class="title">map'</span> f xs = foldr (\x acc -&gt; f x : acc) [] xs  </span><br></pre></td></tr></tbody></table></figure>
<p>Folds can be used to implement any function where you traverse a list
once, element by element, and then return something based on that</p>
<p><code>foldl1</code> and <code>foldr1</code> is similar but do not
require starting value and assume that the starting value equal with the
first inputted element from the list. Examples:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maximum'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a  </span><br><span class="line"><span class="title">maximum'</span> = foldr1 (\x acc -&gt; <span class="keyword">if</span> x &gt; acc <span class="keyword">then</span> x <span class="keyword">else</span> acc)  </span><br><span class="line">  </span><br><span class="line"><span class="title">reverse'</span> :: [a] -&gt; [a]  </span><br><span class="line"><span class="title">reverse'</span> = foldl (\acc x -&gt; x : acc) []  </span><br><span class="line">  </span><br><span class="line"><span class="title">product'</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a  </span><br><span class="line"><span class="title">product'</span> = foldr1 (*)  </span><br><span class="line">  </span><br><span class="line"><span class="title">filter'</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]  </span><br><span class="line"><span class="title">filter'</span> p = foldr (\x acc -&gt; <span class="keyword">if</span> p x <span class="keyword">then</span> x : acc <span class="keyword">else</span> acc) []  </span><br><span class="line">  </span><br><span class="line"><span class="title">head'</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head'</span> = foldr1 (\x _ -&gt; x)  </span><br><span class="line">  </span><br><span class="line"><span class="title">last'</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">last'</span> = foldl1 (\_ x -&gt; x)  </span><br></pre></td></tr></tbody></table></figure>
<p><code>scanl</code> and <code>scanr</code> are similar but they report
all the intermediate accumulated states in the form of a list.
<code>scanl1</code> and <code>scanr1</code> are analogous.</p>
<h3 id="function-application-with">Function application with
<code>$</code></h3>
<p>The function application operator <code>$</code> has the lowest
precedence and it is right-associative. It can help us by saving lots of
parenthesis</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">($) :: (a -&gt; b) -&gt; a -&gt; b</span><br><span class="line"><span class="title">f</span> $ x = f x</span><br></pre></td></tr></tbody></table></figure>
<p><code>$</code> means that function application can be treated just
like another function. That way, we can for instance, map function
application over a list of functions</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map ($ <span class="number">3</span>) [(<span class="number">4</span>+), (<span class="number">10</span>*), (^<span class="number">2</span>), sqrt]</span><br><span class="line">[<span class="number">7.0</span>,<span class="number">30.0</span>,<span class="number">9.0</span>,<span class="number">1.7320508075688772</span>]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="function-composition">Function composition</h3>
<p>The <code>.</code> function define function composition <span class="math inline">\((f\circ g)(x)=f(g(x))\)</span></p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</span><br><span class="line"><span class="title">f</span> . g = \x -&gt; f (g x)</span><br></pre></td></tr></tbody></table></figure>
<p>Examples</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (negate . abs) [<span class="number">5</span>,-<span class="number">3</span>,-<span class="number">6</span>,<span class="number">7</span>,-<span class="number">3</span>,<span class="number">2</span>,-<span class="number">19</span>,<span class="number">24</span>]  </span><br><span class="line">[-<span class="number">5</span>,-<span class="number">3</span>,-<span class="number">6</span>,-<span class="number">7</span>,-<span class="number">3</span>,-<span class="number">2</span>,-<span class="number">19</span>,-<span class="number">24</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; map (negate . sum . tail) [[<span class="number">1</span>..<span class="number">5</span>],[<span class="number">3</span>..<span class="number">6</span>],[<span class="number">1</span>..<span class="number">7</span>]]  </span><br><span class="line">[-<span class="number">14</span>,-<span class="number">15</span>,-<span class="number">27</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sum (replicate <span class="number">5</span> (max <span class="number">6.7</span> <span class="number">8.9</span>)) == sum . replicate <span class="number">5</span> . max <span class="number">6.7</span> $ <span class="number">8.9</span></span><br></pre></td></tr></tbody></table></figure>
<p>If you want to rewrite an expression with a lot of parentheses by
using function composition, you can start by putting the last parameter
of the innermost function after a <code>$</code> and then just composing
all the other function calls, writing them without their last parameter
and putting dots between them</p>
<p>Thus
<code>replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))</code>
becomes
<code>replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]</code></p>
<h2 id="modules">7. Modules</h2>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.List  </span><br><span class="line">  </span><br><span class="line"><span class="title">numUniques</span> :: (<span class="type">Eq</span> a) =&gt; [a] -&gt; <span class="type">Int</span>  </span><br><span class="line"><span class="title">numUniques</span> = length . nub  </span><br></pre></td></tr></tbody></table></figure>
<p>In <code>ghci</code>:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :m + <span class="type">Data</span>.<span class="type">List</span> <span class="type">Data</span>.<span class="type">Map</span> <span class="type">Data</span>.<span class="type">Set</span>  </span><br></pre></td></tr></tbody></table></figure>
<p>Import only some functions</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.List (<span class="title">nub</span>, <span class="title">sort</span>)  </span><br></pre></td></tr></tbody></table></figure>
<p>Import everything but some functions</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.List <span class="keyword">hiding</span> (<span class="title">nub</span>)  </span><br></pre></td></tr></tbody></table></figure>
<p>Qualified import</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Map <span class="keyword">as</span> M</span><br><span class="line"><span class="comment">-- M.filter</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="data.list"><code>Data.List</code></h3>
<p><code>foldl'</code> and <code>foldr'</code> are stricter versions of
their respective lazy incarnations. When using lazy folds on really big
lists, you might often get a stack overflow error. The stricter versions
will not.</p>
<p><code>length</code>, <code>take</code>, <code>drop</code>,
<code>splitAt</code>, <code>!!</code> and <code>replicate</code> all
take an <code>Int</code> as one of their parameters. To use the more
general type <code>Num</code>, <code>Data.list</code> has
<code>genericLength</code>, <code>genericTake</code>,
<code>genericDrop</code>, <code>genericSplitAt</code>,
<code>genericIndex</code> and <code>genericReplicate</code>.</p>
<p>The <code>nub</code>, <code>delete</code>, <code>union</code>,
<code>intersect</code> and <code>group</code> functions all have their
more general counterparts called <code>nubBy</code>,
<code>deleteBy</code>, <code>unionBy</code>, <code>intersectBy</code>
and <code>groupBy</code>. They take in a function for comparison the
inputted elements.</p>
<p>Similarly, the <code>sort</code>, <code>insert</code>,
<code>maximum</code> and <code>minimum</code> have their more general
equivalents <code>sortBy</code>, <code>insertBy</code>,
<code>maximumBy</code> and <code>minimumBy</code>. They take in function
for comparison as well.</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; intersperse <span class="string">'.'</span> <span class="string">"MONKEY"</span>  </span><br><span class="line"><span class="string">"M.O.N.K.E.Y"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; intersperse <span class="number">0</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">6</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; intercalate <span class="string">" "</span> [<span class="string">"hey"</span>,<span class="string">"there"</span>,<span class="string">"guys"</span>]  </span><br><span class="line"><span class="string">"hey there guys"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; intercalate [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; transpose [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]  </span><br><span class="line">[[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]]  </span><br><span class="line"><span class="title">ghci</span>&gt; transpose [<span class="string">"hey"</span>,<span class="string">"there"</span>,<span class="string">"guys"</span>]  </span><br><span class="line">[<span class="string">"htg"</span>,<span class="string">"ehu"</span>,<span class="string">"yey"</span>,<span class="string">"rs"</span>,<span class="string">"e"</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; concat [<span class="string">"foo"</span>,<span class="string">"bar"</span>,<span class="string">"car"</span>]  </span><br><span class="line"><span class="string">"foobarcar"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; concat [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]]  </span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; concatMap (replicate <span class="number">4</span>) [<span class="number">1</span>..<span class="number">3</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; and $ map (&gt;<span class="number">4</span>) [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; and $ map (==<span class="number">4</span>) [<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="type">False</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; or $ map (==<span class="number">4</span>) [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; or $ map (&gt;<span class="number">4</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="type">False</span> </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; any (==<span class="number">4</span>) [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; all (&gt;<span class="number">4</span>) [<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>]  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; all (`elem` [<span class="string">'A'</span>..<span class="string">'Z'</span>]) <span class="string">"HEYGUYSwhatsup"</span>  </span><br><span class="line"><span class="type">False</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; any (`elem` [<span class="string">'A'</span>..<span class="string">'Z'</span>]) <span class="string">"HEYGUYSwhatsup"</span>  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> $ iterate (*<span class="number">2</span>) <span class="number">1</span>  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">64</span>,<span class="number">128</span>,<span class="number">256</span>,<span class="number">512</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">3</span> $ iterate (++ <span class="string">"haha"</span>) <span class="string">"haha"</span>  </span><br><span class="line">[<span class="string">"haha"</span>,<span class="string">"hahahaha"</span>,<span class="string">"hahahahahaha"</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; splitAt <span class="number">3</span> <span class="string">"heyman"</span>  </span><br><span class="line">(<span class="string">"hey"</span>,<span class="string">"man"</span>)  </span><br><span class="line"><span class="title">ghci</span>&gt; splitAt <span class="number">100</span> <span class="string">"heyman"</span>  </span><br><span class="line">(<span class="string">"heyman"</span>,<span class="string">""</span>)  </span><br><span class="line"><span class="title">ghci</span>&gt; splitAt (-<span class="number">3</span>) <span class="string">"heyman"</span>  </span><br><span class="line">(<span class="string">""</span>,<span class="string">"heyman"</span>)  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> (a,b) = splitAt <span class="number">3</span> <span class="string">"foobar"</span> <span class="keyword">in</span> b ++ a  </span><br><span class="line"><span class="string">"barfoo"</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; takeWhile (&gt;<span class="number">3</span>) [<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line">[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; takeWhile (/=<span class="string">' '</span>) <span class="string">"This is a sentence"</span>  </span><br><span class="line"><span class="string">"This"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; sum $ takeWhile (&lt;<span class="number">10000</span>) $ map (^<span class="number">3</span>) [<span class="number">1</span>..]  </span><br><span class="line"><span class="number">53361</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; dropWhile (/=<span class="string">' '</span>) <span class="string">"This is a sentence"</span>  </span><br><span class="line"><span class="string">" is a sentence"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; dropWhile (&lt;<span class="number">3</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> stock = [(<span class="number">994.4</span>,<span class="number">2008</span>,<span class="number">9</span>,<span class="number">1</span>),(<span class="number">995.2</span>,<span class="number">2008</span>,<span class="number">9</span>,<span class="number">2</span>),(<span class="number">999.2</span>,<span class="number">2008</span>,<span class="number">9</span>,<span class="number">3</span>),(<span class="number">1001.4</span>,<span class="number">2008</span>,<span class="number">9</span>,<span class="number">4</span>),(<span class="number">998.3</span>,<span class="number">2008</span>,<span class="number">9</span>,<span class="number">5</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; head (dropWhile (\(val,y,m,d) -&gt; val &lt; <span class="number">1000</span>) stock)  </span><br><span class="line">(<span class="number">1001.4</span>,<span class="number">2008</span>,<span class="number">9</span>,<span class="number">4</span>)  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> (fw, rest) = span (/=<span class="string">' '</span>) <span class="string">"This is a sentence"</span> <span class="keyword">in</span> <span class="string">"First word:"</span> ++ fw ++ <span class="string">", the rest:"</span> ++ rest  </span><br><span class="line"><span class="string">"First word: This, the rest: is a sentence"</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; break (==<span class="number">4</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])  </span><br><span class="line"><span class="title">ghci</span>&gt; span (/=<span class="number">4</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; sort [<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sort <span class="string">"This will be sorted soon"</span>  </span><br><span class="line"><span class="string">"    Tbdeehiillnooorssstw"</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; group [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line">[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">5</span>],[<span class="number">6</span>],[<span class="number">7</span>]]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; map (\l@(x:xs) -&gt; (x,length l)) . group . sort $ [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line">[(<span class="number">1</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">7</span>),(<span class="number">3</span>,<span class="number">2</span>),(<span class="number">5</span>,<span class="number">1</span>),(<span class="number">6</span>,<span class="number">1</span>),(<span class="number">7</span>,<span class="number">1</span>)]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; inits <span class="string">"w00t"</span>  </span><br><span class="line">[<span class="string">""</span>,<span class="string">"w"</span>,<span class="string">"w0"</span>,<span class="string">"w00"</span>,<span class="string">"w00t"</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; tails <span class="string">"w00t"</span>  </span><br><span class="line">[<span class="string">"w00t"</span>,<span class="string">"00t"</span>,<span class="string">"0t"</span>,<span class="string">"t"</span>,<span class="string">""</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> w = <span class="string">"w00t"</span> <span class="keyword">in</span> zip (inits w) (tails w)  </span><br><span class="line">[(<span class="string">""</span>,<span class="string">"w00t"</span>),(<span class="string">"w"</span>,<span class="string">"00t"</span>),(<span class="string">"w0"</span>,<span class="string">"0t"</span>),(<span class="string">"w00"</span>,<span class="string">"t"</span>),(<span class="string">"w00t"</span>,<span class="string">""</span>)]  </span><br><span class="line"></span><br><span class="line"><span class="title">search</span> :: (<span class="type">Eq</span> a) =&gt; [a] -&gt; [a] -&gt; <span class="type">Bool</span>  </span><br><span class="line"><span class="title">search</span> needle haystack =   </span><br><span class="line">    <span class="keyword">let</span> nlen = length needle  </span><br><span class="line">    <span class="keyword">in</span>  foldl (\acc x -&gt; <span class="keyword">if</span> take nlen x == needle <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> acc) <span class="type">False</span> (tails haystack)  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"cat"</span> `isInfixOf` <span class="string">"im a cat burglar"</span>  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"Cat"</span> `isInfixOf` <span class="string">"im a cat burglar"</span>  </span><br><span class="line"><span class="type">False</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"hey"</span> `isPrefixOf` <span class="string">"hey there!"</span>  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"hey"</span> `isPrefixOf` <span class="string">"oh hey there!"</span>  </span><br><span class="line"><span class="type">False</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"there!"</span> `isSuffixOf` <span class="string">"oh hey there!"</span>  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"there!"</span> `isSuffixOf` <span class="string">"oh hey there"</span>  </span><br><span class="line"><span class="type">False</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; partition (`elem` [<span class="string">'A'</span>..<span class="string">'Z'</span>]) <span class="string">"BOBsidneyMORGANeddy"</span>  </span><br><span class="line">(<span class="string">"BOBMORGAN"</span>,<span class="string">"sidneyeddy"</span>)  </span><br><span class="line"><span class="title">ghci</span>&gt; partition (&gt;<span class="number">3</span>) [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>]  </span><br><span class="line">([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>])  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; span (`elem` [<span class="string">'A'</span>..<span class="string">'Z'</span>]) <span class="string">"BOBsidneyMORGANeddy"</span>  </span><br><span class="line">(<span class="string">"BOB"</span>,<span class="string">"sidneyMORGANeddy"</span>)  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; find (&gt;<span class="number">4</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line"><span class="type">Just</span> <span class="number">5</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; find (&gt;<span class="number">9</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line"><span class="type">Nothing</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t find  </span><br><span class="line"><span class="title">find</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; <span class="type">Maybe</span> a  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; :t elemIndex  </span><br><span class="line"><span class="title">elemIndex</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [a] -&gt; <span class="type">Maybe</span> <span class="type">Int</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> `elemIndex` [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line"><span class="type">Just</span> <span class="number">3</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">10</span> `elemIndex` [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  </span><br><span class="line"><span class="type">Nothing</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">' '</span> `elemIndices` <span class="string">"Where are the spaces?"</span>  </span><br><span class="line">[<span class="number">5</span>,<span class="number">9</span>,<span class="number">13</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; zipWith3 (\x y z -&gt; x + y + z) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] [<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>] [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">[<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zip4 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] [<span class="number">5</span>,<span class="number">5</span>,<span class="number">3</span>] [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]  </span><br><span class="line">[(<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>)]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; lines <span class="string">"first line\nsecond line\nthird line"</span>  </span><br><span class="line">[<span class="string">"first line"</span>,<span class="string">"second line"</span>,<span class="string">"third line"</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; unlines [<span class="string">"first line"</span>, <span class="string">"second line"</span>, <span class="string">"third line"</span>]  </span><br><span class="line"><span class="string">"first line\nsecond line\nthird line\n"</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; words <span class="string">"hey these are the words in this sentence"</span>  </span><br><span class="line">[<span class="string">"hey"</span>,<span class="string">"these"</span>,<span class="string">"are"</span>,<span class="string">"the"</span>,<span class="string">"words"</span>,<span class="string">"in"</span>,<span class="string">"this"</span>,<span class="string">"sentence"</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; words <span class="string">"hey these           are    the words in this\nsentence"</span>  </span><br><span class="line">[<span class="string">"hey"</span>,<span class="string">"these"</span>,<span class="string">"are"</span>,<span class="string">"the"</span>,<span class="string">"words"</span>,<span class="string">"in"</span>,<span class="string">"this"</span>,<span class="string">"sentence"</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; unwords [<span class="string">"hey"</span>,<span class="string">"there"</span>,<span class="string">"mate"</span>]  </span><br><span class="line"><span class="string">"hey there mate"</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; nub [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; nub <span class="string">"Lots of words and stuff"</span>  </span><br><span class="line"><span class="string">"Lots fwrdanu"</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; delete <span class="string">'h'</span> <span class="string">"hey there ghang!"</span>  </span><br><span class="line"><span class="string">"ey there ghang!"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; delete <span class="string">'h'</span> . delete <span class="string">'h'</span> $ <span class="string">"hey there ghang!"</span>  </span><br><span class="line"><span class="string">"ey tere ghang!"</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>..<span class="number">10</span>] \\ [<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"Im a big baby"</span> \\ <span class="string">"big"</span>  </span><br><span class="line"><span class="string">"Im a  baby"</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="string">"hey man"</span> `union` <span class="string">"man what's up"</span>  </span><br><span class="line"><span class="string">"hey manwt'sup"</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>..<span class="number">7</span>] `union` [<span class="number">5</span>..<span class="number">10</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>..<span class="number">7</span>] `intersect` [<span class="number">5</span>..<span class="number">10</span>]  </span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; insert <span class="number">4</span> [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">2</span>]  </span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">2</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; insert <span class="number">4</span> [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> values = [-<span class="number">4.3</span>, -<span class="number">2.4</span>, -<span class="number">1.2</span>, <span class="number">0.4</span>, <span class="number">2.3</span>, <span class="number">5.9</span>, <span class="number">10.5</span>, <span class="number">29.1</span>, <span class="number">5.3</span>, -<span class="number">2.4</span>, -<span class="number">14.5</span>, <span class="number">2.9</span>, <span class="number">2.3</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; groupBy (\x y -&gt; (x &gt; <span class="number">0</span>) == (y &gt; <span class="number">0</span>)) values  </span><br><span class="line">[[-<span class="number">4.3</span>,-<span class="number">2.4</span>,-<span class="number">1.2</span>],[<span class="number">0.4</span>,<span class="number">2.3</span>,<span class="number">5.9</span>,<span class="number">10.5</span>,<span class="number">29.1</span>,<span class="number">5.3</span>],[-<span class="number">2.4</span>,-<span class="number">14.5</span>],[<span class="number">2.9</span>,<span class="number">2.3</span>]]  </span><br><span class="line"><span class="title">ghci</span>&gt; groupBy ((==) `on` (&gt; <span class="number">0</span>)) values  </span><br><span class="line">[[-<span class="number">4.3</span>,-<span class="number">2.4</span>,-<span class="number">1.2</span>],[<span class="number">0.4</span>,<span class="number">2.3</span>,<span class="number">5.9</span>,<span class="number">10.5</span>,<span class="number">29.1</span>,<span class="number">5.3</span>],[-<span class="number">2.4</span>,-<span class="number">14.5</span>],[<span class="number">2.9</span>,<span class="number">2.3</span>]]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> xs = [[<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>],[],[<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]]  </span><br><span class="line"><span class="title">ghci</span>&gt; sortBy (compare `on` length) xs  </span><br><span class="line">[[],[<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>]]  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="data.char"><code>Data.Char</code></h3>
<p><code>Data.Char</code> has the following trivial functions.
<code>isControl</code>, <code>isSpace</code>, <code>isLower</code>,
<code>isUpper</code>, <code>isAlpha</code>, <code>isAlphaNum</code>,
<code>isPrint</code>, <code>isDigit</code>, <code>isOctDigit</code>,
<code>isHexDigit</code>, <code>isLetter</code>, <code>isMark</code>,
<code>isNumber</code>, <code>isPunctuation</code>,
<code>isSymbol</code>, <code>isSeparator</code>, <code>isAscii</code>,
<code>isAsciiUpper</code>, <code>isAsciiLower</code>,
<code>toUpper</code>, <code>toLower</code>, <code>toTitle</code>,
<code>digitToInt</code>, <code>intToDigit</code>, <code>ord</code>,
<code>chr</code>.</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; generalCategory <span class="string">' '</span>  </span><br><span class="line"><span class="type">Space</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; generalCategory <span class="string">'A'</span>  </span><br><span class="line"><span class="type">UppercaseLetter</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; generalCategory <span class="string">'a'</span>  </span><br><span class="line"><span class="type">LowercaseLetter</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; generalCategory <span class="string">'.'</span>  </span><br><span class="line"><span class="type">OtherPunctuation</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; generalCategory <span class="string">'9'</span>  </span><br><span class="line"><span class="type">DecimalNumber</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; map generalCategory <span class="string">" \t\nA9?|"</span>  </span><br><span class="line">[<span class="type">Space</span>,<span class="type">Control</span>,<span class="type">Control</span>,<span class="type">UppercaseLetter</span>,<span class="type">DecimalNumber</span>,<span class="type">OtherPunctuation</span>,<span class="type">MathSymbol</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; map digitToInt <span class="string">"34538"</span>  </span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; map digitToInt <span class="string">"FF85AB"</span>  </span><br><span class="line">[<span class="number">15</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">11</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; intToDigit <span class="number">15</span>  </span><br><span class="line"><span class="string">'f'</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; intToDigit <span class="number">5</span>  </span><br><span class="line"><span class="string">'5'</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; ord <span class="string">'a'</span>  </span><br><span class="line"><span class="number">97</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; chr <span class="number">97</span>  </span><br><span class="line"><span class="string">'a'</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; map ord <span class="string">"abcdefgh"</span>  </span><br><span class="line">[<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>,<span class="number">104</span>]  </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="data.map"><code>Data.Map</code></h3>
<p>Trivial list map implementation</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">findKey</span> :: (<span class="type">Eq</span> k) =&gt; k -&gt; [(k,v)] -&gt; v  </span><br><span class="line"><span class="title">findKey</span> key xs = snd . head . filter (\(k,v) -&gt; key == k) $ xs  </span><br><span class="line"></span><br><span class="line"><span class="title">findKey</span> :: (<span class="type">Eq</span> k) =&gt; k -&gt; [(k,v)] -&gt; <span class="type">Maybe</span> v  </span><br><span class="line"><span class="title">findKey</span> key = foldr (\(k,v) acc -&gt; <span class="keyword">if</span> key == k <span class="keyword">then</span> <span class="type">Just</span> v <span class="keyword">else</span> acc) <span class="type">Nothing</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">phoneBook</span> =   </span><br><span class="line">    [(<span class="string">"betty"</span>,<span class="string">"555-2938"</span>)  </span><br><span class="line">    ,(<span class="string">"bonnie"</span>,<span class="string">"452-2928"</span>)  </span><br><span class="line">    ,(<span class="string">"patsy"</span>,<span class="string">"493-2928"</span>)  </span><br><span class="line">    ,(<span class="string">"lucille"</span>,<span class="string">"205-2928"</span>)  </span><br><span class="line">    ,(<span class="string">"wendy"</span>,<span class="string">"939-8282"</span>)  </span><br><span class="line">    ,(<span class="string">"penny"</span>,<span class="string">"853-2492"</span>)  </span><br><span class="line">    ]  </span><br><span class="line">    </span><br><span class="line"><span class="title">findKey</span> <span class="string">"penny"</span> phoneBook == <span class="type">Just</span> <span class="string">"853-2492"</span> </span><br><span class="line"><span class="title">findKey</span> <span class="string">"wilma"</span> phoneBook == <span class="type">Nothing</span>  </span><br></pre></td></tr></tbody></table></figure>
<p>But <code>Data.Map</code> is a lot faster. It can be imported by</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Map <span class="keyword">as</span> Map  </span><br></pre></td></tr></tbody></table></figure>
<p>Usage:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.fromList [(<span class="string">"betty"</span>,<span class="string">"555-2938"</span>),(<span class="string">"bonnie"</span>,<span class="string">"452-2928"</span>),(<span class="string">"lucille"</span>,<span class="string">"205-2928"</span>)] </span><br><span class="line"><span class="title">fromList</span> [(<span class="string">"betty"</span>,<span class="string">"555-2938"</span>),(<span class="string">"bonnie"</span>,<span class="string">"452-2928"</span>),(<span class="string">"lucille"</span>,<span class="string">"205-2928"</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.fromList [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">2</span>),(<span class="number">5</span>,<span class="number">5</span>)]  </span><br><span class="line"><span class="title">fromList</span> [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">2</span>),(<span class="number">5</span>,<span class="number">5</span>)]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.empty  </span><br><span class="line"><span class="title">fromList</span> []  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.insert <span class="number">3</span> <span class="number">100</span> <span class="type">Map</span>.empty  </span><br><span class="line"><span class="title">fromList</span> [(<span class="number">3</span>,<span class="number">100</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.insert <span class="number">5</span> <span class="number">600</span> (<span class="type">Map</span>.insert <span class="number">4</span> <span class="number">200</span> ( <span class="type">Map</span>.insert <span class="number">3</span> <span class="number">100</span>  <span class="type">Map</span>.empty))  </span><br><span class="line"><span class="title">fromList</span> [(<span class="number">3</span>,<span class="number">100</span>),(<span class="number">4</span>,<span class="number">200</span>),(<span class="number">5</span>,<span class="number">600</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.insert <span class="number">5</span> <span class="number">600</span> . <span class="type">Map</span>.insert <span class="number">4</span> <span class="number">200</span> . <span class="type">Map</span>.insert <span class="number">3</span> <span class="number">100</span> $ <span class="type">Map</span>.empty  </span><br><span class="line"><span class="title">fromList</span> [(<span class="number">3</span>,<span class="number">100</span>),(<span class="number">4</span>,<span class="number">200</span>),(<span class="number">5</span>,<span class="number">600</span>)]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.null <span class="type">Map</span>.empty  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.null $ <span class="type">Map</span>.fromList [(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">5</span>,<span class="number">5</span>)]  </span><br><span class="line"><span class="type">False</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.size <span class="type">Map</span>.empty  </span><br><span class="line"><span class="number">0</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.size $ <span class="type">Map</span>.fromList [(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">2</span>),(<span class="number">5</span>,<span class="number">4</span>),(<span class="number">6</span>,<span class="number">4</span>)]  </span><br><span class="line"><span class="number">5</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.singleton <span class="number">3</span> <span class="number">9</span>  </span><br><span class="line"><span class="title">fromList</span> [(<span class="number">3</span>,<span class="number">9</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.insert <span class="number">5</span> <span class="number">9</span> $ <span class="type">Map</span>.singleton <span class="number">3</span> <span class="number">9</span>  </span><br><span class="line"><span class="title">fromList</span> [(<span class="number">3</span>,<span class="number">9</span>),(<span class="number">5</span>,<span class="number">9</span>)]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.member <span class="number">3</span> $ <span class="type">Map</span>.fromList [(<span class="number">3</span>,<span class="number">6</span>),(<span class="number">4</span>,<span class="number">3</span>),(<span class="number">6</span>,<span class="number">9</span>)]  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.member <span class="number">3</span> $ <span class="type">Map</span>.fromList [(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="number">5</span>)]  </span><br><span class="line"><span class="type">False</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.map (*<span class="number">100</span>) $ <span class="type">Map</span>.fromList [(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">4</span>),(<span class="number">3</span>,<span class="number">9</span>)]  </span><br><span class="line"><span class="title">fromList</span> [(<span class="number">1</span>,<span class="number">100</span>),(<span class="number">2</span>,<span class="number">400</span>),(<span class="number">3</span>,<span class="number">900</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.filter isUpper $ <span class="type">Map</span>.fromList [(<span class="number">1</span>,<span class="string">'a'</span>),(<span class="number">2</span>,<span class="string">'A'</span>),(<span class="number">3</span>,<span class="string">'b'</span>),(<span class="number">4</span>,<span class="string">'B'</span>)]  </span><br><span class="line"><span class="title">fromList</span> [(<span class="number">2</span>,<span class="string">'A'</span>),(<span class="number">4</span>,<span class="string">'B'</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.toList . <span class="type">Map</span>.insert <span class="number">9</span> <span class="number">2</span> $ <span class="type">Map</span>.singleton <span class="number">4</span> <span class="number">3</span>  </span><br><span class="line">[(<span class="number">4</span>,<span class="number">3</span>),(<span class="number">9</span>,<span class="number">2</span>)]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.fromListWith max [(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="number">100</span>),(<span class="number">3</span>,<span class="number">29</span>),(<span class="number">3</span>,<span class="number">22</span>),(<span class="number">3</span>,<span class="number">11</span>),(<span class="number">4</span>,<span class="number">22</span>),(<span class="number">4</span>,<span class="number">15</span>)]  </span><br><span class="line"><span class="title">fromList</span> [(<span class="number">2</span>,<span class="number">100</span>),(<span class="number">3</span>,<span class="number">29</span>),(<span class="number">4</span>,<span class="number">22</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.fromListWith (+) [(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="number">100</span>),(<span class="number">3</span>,<span class="number">29</span>),(<span class="number">3</span>,<span class="number">22</span>),(<span class="number">3</span>,<span class="number">11</span>),(<span class="number">4</span>,<span class="number">22</span>),(<span class="number">4</span>,<span class="number">15</span>)]  </span><br><span class="line"><span class="title">fromList</span> [(<span class="number">2</span>,<span class="number">108</span>),(<span class="number">3</span>,<span class="number">62</span>),(<span class="number">4</span>,<span class="number">37</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Map</span>.insertWith (+) <span class="number">3</span> <span class="number">100</span> $ <span class="type">Map</span>.fromList [(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">103</span>),(<span class="number">6</span>,<span class="number">339</span>)]  </span><br><span class="line"><span class="title">fromList</span> [(<span class="number">3</span>,<span class="number">104</span>),(<span class="number">5</span>,<span class="number">103</span>),(<span class="number">6</span>,<span class="number">339</span>)]  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="data.set"><code>Data.Set</code></h3>
<p>Imported</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Set <span class="keyword">as</span> Set  </span><br></pre></td></tr></tbody></table></figure>
<p>Usage</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Set</span>.null <span class="type">Set</span>.empty  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Set</span>.null $ <span class="type">Set</span>.fromList [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="type">False</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Set</span>.size $ <span class="type">Set</span>.fromList [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  </span><br><span class="line"><span class="number">3</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Set</span>.singleton <span class="number">9</span>  </span><br><span class="line"><span class="title">fromList</span> [<span class="number">9</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Set</span>.insert <span class="number">4</span> $ <span class="type">Set</span>.fromList [<span class="number">9</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="title">fromList</span> [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Set</span>.insert <span class="number">8</span> $ <span class="type">Set</span>.fromList [<span class="number">5</span>..<span class="number">10</span>]  </span><br><span class="line"><span class="title">fromList</span> [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Set</span>.delete <span class="number">4</span> $ <span class="type">Set</span>.fromList [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  </span><br><span class="line"><span class="title">fromList</span> [<span class="number">3</span>,<span class="number">5</span>]  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Set</span>.fromList [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] `<span class="type">Set</span>.isSubsetOf` <span class="type">Set</span>.fromList [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Set</span>.fromList [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] `<span class="type">Set</span>.isSubsetOf` <span class="type">Set</span>.fromList [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  </span><br><span class="line"><span class="type">True</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Set</span>.fromList [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] `<span class="type">Set</span>.isProperSubsetOf` <span class="type">Set</span>.fromList [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  </span><br><span class="line"><span class="type">False</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Set</span>.fromList [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>] `<span class="type">Set</span>.isSubsetOf` <span class="type">Set</span>.fromList [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  </span><br><span class="line"><span class="type">False</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Set</span>.filter odd $ <span class="type">Set</span>.fromList [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="title">fromList</span> [<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Set</span>.map (+<span class="number">1</span>) $ <span class="type">Set</span>.fromList [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="title">fromList</span> [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="your-own-modules">Your own modules</h3>
<p>Example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Geometry  </span><br><span class="line">( <span class="title">sphereVolume</span>  </span><br><span class="line">, <span class="title">sphereArea</span>  </span><br><span class="line">, <span class="title">cubeVolume</span>  </span><br><span class="line">, <span class="title">cubeArea</span>  </span><br><span class="line">, <span class="title">cuboidArea</span>  </span><br><span class="line">, <span class="title">cuboidVolume</span>  </span><br><span class="line">) <span class="keyword">where</span>  </span><br><span class="line">  </span><br><span class="line"><span class="title">sphereVolume</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">sphereVolume</span> radius = (<span class="number">4.0</span> / <span class="number">3.0</span>) * pi * (radius ^ <span class="number">3</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="title">sphereArea</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">sphereArea</span> radius = <span class="number">4</span> * pi * (radius ^ <span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="title">cubeVolume</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">cubeVolume</span> side = cuboidVolume side side side  </span><br><span class="line">  </span><br><span class="line"><span class="title">cubeArea</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">cubeArea</span> side = cuboidArea side side side  </span><br><span class="line">  </span><br><span class="line"><span class="title">cuboidVolume</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">cuboidVolume</span> a b c = rectangleArea a b * c  </span><br><span class="line">  </span><br><span class="line"><span class="title">cuboidArea</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">cuboidArea</span> a b c = rectangleArea a b * <span class="number">2</span> + rectangleArea a c * <span class="number">2</span> + rectangleArea c b * <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line"><span class="title">rectangleArea</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">rectangleArea</span> a b = a * b  </span><br></pre></td></tr></tbody></table></figure>
<p>Or organized by files and directories. For example if we have a
folder called <code>Geometry</code>. There are three files in the folder
- <code>Sphere.hs</code>, <code>Cuboid.hs</code>, and
<code>Cube.hs</code>.</p>
<p>In <code>Sphere.hs</code>:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Geometry.Sphere  </span><br><span class="line">( <span class="title">volume</span>  </span><br><span class="line">, <span class="title">area</span>  </span><br><span class="line">) <span class="keyword">where</span>  </span><br><span class="line">  </span><br><span class="line"><span class="title">volume</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">volume</span> radius = (<span class="number">4.0</span> / <span class="number">3.0</span>) * pi * (radius ^ <span class="number">3</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="title">area</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">area</span> radius = <span class="number">4</span> * pi * (radius ^ <span class="number">2</span>)  </span><br></pre></td></tr></tbody></table></figure>
<p>In <code>Cuboid.hs</code>:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Geometry.Cuboid  </span><br><span class="line">( <span class="title">volume</span>  </span><br><span class="line">, <span class="title">area</span>  </span><br><span class="line">) <span class="keyword">where</span>  </span><br><span class="line">  </span><br><span class="line"><span class="title">volume</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">volume</span> a b c = rectangleArea a b * c  </span><br><span class="line">  </span><br><span class="line"><span class="title">area</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">area</span> a b c = rectangleArea a b * <span class="number">2</span> + rectangleArea a c * <span class="number">2</span> + rectangleArea c b * <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line"><span class="title">rectangleArea</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">rectangleArea</span> a b = a * b  </span><br></pre></td></tr></tbody></table></figure>
<p>In <code>Cube.hs</code>:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Geometry.Cube  </span><br><span class="line">( <span class="title">volume</span>  </span><br><span class="line">, <span class="title">area</span>  </span><br><span class="line">) <span class="keyword">where</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Geometry.Cuboid <span class="keyword">as</span> Cuboid  </span><br><span class="line">  </span><br><span class="line"><span class="title">volume</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">volume</span> side = <span class="type">Cuboid</span>.volume side side side  </span><br><span class="line">  </span><br><span class="line"><span class="title">area</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">area</span> side = <span class="type">Cuboid</span>.area side side side  </span><br></pre></td></tr></tbody></table></figure>
<p>Usage:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Geometry.Sphere <span class="keyword">as</span> Sphere  </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Geometry.Cuboid <span class="keyword">as</span> Cuboid  </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Geometry.Cube <span class="keyword">as</span> Cube  </span><br></pre></td></tr></tbody></table></figure>
<h2 id="make-your-own-types-and-typeclasses">8. Make your own types and
typeclasses</h2>
<h3 id="algebraic-data-types">Algebraic data types</h3>
<p>How boolean type is defined in the standard library:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Bool</span> = <span class="type">False</span> | <span class="type">True</span>  </span></span><br></pre></td></tr></tbody></table></figure>
<p>Another example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="title">surface</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">surface</span> (<span class="type">Circle</span> _ _ r) = pi * r ^ <span class="number">2</span>  </span><br><span class="line"><span class="title">surface</span> (<span class="type">Rectangle</span> x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)  </span><br><span class="line"></span><br><span class="line"><span class="title">surface</span> $ <span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span> <span class="number">10</span> == <span class="number">314.15927</span> </span><br><span class="line"><span class="title">surface</span> $ <span class="type">Rectangle</span> <span class="number">0</span> <span class="number">0</span> <span class="number">100</span> <span class="number">100</span> == <span class="number">10000.0</span>  </span><br></pre></td></tr></tbody></table></figure>
<p>To improve the previous example, let's make an intermediate data type
that defines a point in two-dimensional space and add
<code>deriving (Show)</code> at the end a data declaration. Haskell will
automatically make the type part of the <code>Show</code> typeclass</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)  </span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Point</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Point</span> <span class="type">Point</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)  </span></span><br><span class="line"></span><br><span class="line"><span class="title">surface</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">surface</span> (<span class="type">Circle</span> _ r) = pi * r ^ <span class="number">2</span>  </span><br><span class="line"><span class="title">surface</span> (<span class="type">Rectangle</span> (<span class="type">Point</span> x1 y1) (<span class="type">Point</span> x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)  </span><br><span class="line"></span><br><span class="line"><span class="title">surface</span> (<span class="type">Rectangle</span> (<span class="type">Point</span> <span class="number">0</span> <span class="number">0</span>) (<span class="type">Point</span> <span class="number">100</span> <span class="number">100</span>)) == <span class="number">10000.0</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">map</span> (<span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span>) [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>] == [<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">4.0</span>,<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">5.0</span>,<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">6.0</span>,<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">6.0</span>] </span><br></pre></td></tr></tbody></table></figure>
<p>How about a function that nudges a shape? It takes a shape, the
amount to move it on the x axis and the amount to move it on the y axis
and then returns a new shape that has the same dimensions, only it's
located somewhere else</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">nudge</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Shape</span>  </span><br><span class="line"><span class="title">nudge</span> (<span class="type">Circle</span> (<span class="type">Point</span> x y) r) a b = <span class="type">Circle</span> (<span class="type">Point</span> (x+a) (y+b)) r  </span><br><span class="line"><span class="title">nudge</span> (<span class="type">Rectangle</span> (<span class="type">Point</span> x1 y1) (<span class="type">Point</span> x2 y2)) a b = <span class="type">Rectangle</span> (<span class="type">Point</span> (x1+a) (y1+b)) (<span class="type">Point</span> (x2+a) (y2+b))  </span><br><span class="line"></span><br><span class="line"><span class="title">nudge</span> (<span class="type">Circle</span> (<span class="type">Point</span> <span class="number">34</span> <span class="number">34</span>) <span class="number">10</span>) <span class="number">5</span> <span class="number">10</span> == <span class="type">Circle</span> (<span class="type">Point</span> <span class="number">39.0</span> <span class="number">44.0</span>) <span class="number">10.0</span> </span><br></pre></td></tr></tbody></table></figure>
<p>If we don't want to deal directly with points, we can make some
auxiliary functions that create shapes of some size at the zero
coordinates and then nudge those:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">baseCircle</span> :: <span class="type">Float</span> -&gt; <span class="type">Shape</span></span><br><span class="line"><span class="title">baseCircle</span> r = <span class="type">Circle</span> (<span class="type">Point</span> <span class="number">0</span> <span class="number">0</span>) r</span><br><span class="line"></span><br><span class="line"><span class="title">baseRect</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Shape</span></span><br><span class="line"><span class="title">baseRect</span> width height = <span class="type">Rectangle</span> (<span class="type">Point</span> <span class="number">0</span> <span class="number">0</span>) (<span class="type">Point</span> width height)</span><br><span class="line"></span><br><span class="line"><span class="title">nudge</span> (baseRect <span class="number">40</span> <span class="number">100</span>) <span class="number">60</span> <span class="number">23</span> == <span class="type">Rectangle</span> (<span class="type">Point</span> <span class="number">60.0</span> <span class="number">23.0</span>) (<span class="type">Point</span> <span class="number">100.0</span> <span class="number">123.0</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>If we wanted to export the functions and types that we defined here
in a module, we could start it off like this:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Shapes </span><br><span class="line">( <span class="type">Point(..)</span></span><br><span class="line">, <span class="type">Shape(..)</span></span><br><span class="line">, <span class="title">surface</span></span><br><span class="line">, <span class="title">nudge</span></span><br><span class="line">, <span class="title">baseCircle</span></span><br><span class="line">, <span class="title">baseRect</span></span><br><span class="line">) <span class="keyword">where</span></span><br></pre></td></tr></tbody></table></figure>
<p>By doing <code>Shape(..)</code>, we exported all the value
constructors for <code>shape</code>, so that means that whoever imports
our module can make shapes by using the <code>Rectangle</code> and
<code>Circle</code> value constructors. It's the same as writing
<code>Shape (Rectangle, Circle)</code></p>
<p>We could also opt not to export any value constructors for
<code>Shape</code> by just writing <code>Shape</code> in the export
statement. That way, someone importing our module could only make shapes
by using the auxiliary function functions <code>baseCircle</code> and
<code>baseRect</code></p>
<p><code>Data.Map</code> uses that approach. You cannot create a map by
doing <code>Map.Map [(1,2), (3,4)]</code> because it doesn't export that
value constructor. However, you can make a mapping by using one of the
auxiliary functions like <code>Map.fromList</code>. Not exporting the
value constructors of a data types makes them more abstract in such a
way that we hide their implementation</p>
<h3 id="record-syntax">Record syntax</h3>
<p>If the data type we want to create is complicated, then to create it
with the previous method will be unreadable. For example:
<code>data Person = Person String string Int Float String String deriving (Show)</code></p>
<p>Then, instead, we can do the following:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> { <span class="title">firstName</span> :: <span class="type">String</span>  </span></span><br><span class="line"><span class="class">                     , <span class="title">lastName</span> :: <span class="type">String</span>  </span></span><br><span class="line"><span class="class">                     , <span class="title">age</span> :: <span class="type">Int</span>  </span></span><br><span class="line"><span class="class">                     , <span class="title">height</span> :: <span class="type">Float</span>  </span></span><br><span class="line"><span class="class">                     , <span class="title">phoneNumber</span> :: <span class="type">String</span>  </span></span><br><span class="line"><span class="class">                     , <span class="title">flavor</span> :: <span class="type">String</span>  </span></span><br><span class="line"><span class="class">                     } <span class="keyword">deriving</span> (<span class="type">Show</span>)   </span></span><br><span class="line"></span><br><span class="line"><span class="title">let</span> guy = <span class="type">Person</span> <span class="string">"Buddy"</span> <span class="string">"Finklestein"</span> <span class="number">43</span> <span class="number">184.2</span> <span class="string">"526-2928"</span> <span class="string">"Chocolate"</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">firstName</span> guy == <span class="string">"Buddy"</span>  </span><br><span class="line"><span class="title">height</span> guy == <span class="number">184.2</span> </span><br><span class="line"><span class="title">flavor</span> guy == <span class="string">"Chocolate"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Car</span> = <span class="type">Car</span> {<span class="title">company</span> :: <span class="type">String</span>, <span class="title">model</span> :: <span class="type">String</span>, <span class="title">year</span> :: <span class="type">Int</span>} <span class="keyword">deriving</span> (<span class="type">Show</span>)  </span></span><br><span class="line"></span><br><span class="line"><span class="type">Car</span> {company=<span class="string">"Ford"</span>, model=<span class="string">"Mustang"</span>, year=<span class="number">1967</span>}  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="type-parameters">Type parameters</h3>
<p>Don't put type constraints into <em>data</em> declarations even if it
seems to make sense, because you'll have to put them into the function
type declarations either way.</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Car</span> a b c = <span class="type">Car</span> { <span class="title">company</span> :: <span class="title">a</span>  </span></span><br><span class="line"><span class="class">                     , <span class="title">model</span> :: <span class="title">b</span>  </span></span><br><span class="line"><span class="class">                     , <span class="title">year</span> :: <span class="title">c</span>   </span></span><br><span class="line"><span class="class">                     } <span class="keyword">deriving</span> (<span class="type">Show</span>)  </span></span><br><span class="line"></span><br><span class="line"><span class="title">tellCar</span> :: <span class="type">Car</span> -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">tellCar</span> (<span class="type">Car</span> {company = c, model = m, year = y}) = <span class="string">"This "</span> ++ c ++ <span class="string">" "</span> ++ m ++ <span class="string">" was made in "</span> ++ show y  </span><br><span class="line"></span><br><span class="line"><span class="title">let</span> stang = <span class="type">Car</span> {company=<span class="string">"Ford"</span>, model=<span class="string">"Mustang"</span>, year=<span class="number">1967</span>}  </span><br><span class="line"></span><br><span class="line"><span class="title">tellCar</span> stang == <span class="string">"This Ford Mustang was made in 1967"</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vector</span> a = <span class="type">Vector</span> a a a <span class="keyword">deriving</span> (<span class="type">Show</span>)  </span></span><br><span class="line">  </span><br><span class="line"><span class="title">vplus</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Vector</span> t -&gt; <span class="type">Vector</span> t -&gt; <span class="type">Vector</span> t  </span><br><span class="line">(<span class="type">Vector</span> i j k) `vplus` (<span class="type">Vector</span> l m n) = <span class="type">Vector</span> (i+l) (j+m) (k+n)  </span><br><span class="line">  </span><br><span class="line"><span class="title">vectMult</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Vector</span> t -&gt; t -&gt; <span class="type">Vector</span> t  </span><br><span class="line">(<span class="type">Vector</span> i j k) `vectMult` m = <span class="type">Vector</span> (i*m) (j*m) (k*m)  </span><br><span class="line">  </span><br><span class="line"><span class="title">scalarMult</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Vector</span> t -&gt; <span class="type">Vector</span> t -&gt; t  </span><br><span class="line">(<span class="type">Vector</span> i j k) `scalarMult` (<span class="type">Vector</span> l m n) = i*l + j*m + k*n  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="derived-instances">Derived instances</h3>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> { <span class="title">firstName</span> :: <span class="type">String</span>  </span></span><br><span class="line"><span class="class">                     , <span class="title">lastName</span> :: <span class="type">String</span>  </span></span><br><span class="line"><span class="class">                     , <span class="title">age</span> :: <span class="type">Int</span>  </span></span><br><span class="line"><span class="class">                     } <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>, <span class="type">Read</span>)  </span></span><br><span class="line"></span><br><span class="line"><span class="title">let</span> mikeD = <span class="type">Person</span> {firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>}  </span><br><span class="line"><span class="title">let</span> adRock = <span class="type">Person</span> {firstName = <span class="string">"Adam"</span>, lastName = <span class="string">"Horovitz"</span>, age = <span class="number">41</span>}  </span><br><span class="line"><span class="title">let</span> mca = <span class="type">Person</span> {firstName = <span class="string">"Adam"</span>, lastName = <span class="string">"Yauch"</span>, age = <span class="number">44</span>}  </span><br><span class="line"></span><br><span class="line"><span class="title">let</span> beastieBoys = [mca, adRock, mikeD]  </span><br><span class="line"><span class="title">mikeD</span> `elem` beastieBoys == <span class="type">True</span>  </span><br><span class="line"></span><br><span class="line"><span class="string">"mikeD is: "</span> ++ show mikeD == <span class="string">"mikeD is: Person {firstName = \"Michael\", lastName = \"Diamond\", age = 43}"</span>  </span><br><span class="line"></span><br><span class="line"><span class="title">read</span> <span class="string">"Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}"</span> == mikeD  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Day</span> = <span class="type">Monday</span> | <span class="type">Tuesday</span> | <span class="type">Wednesday</span> | <span class="type">Thursday</span> | <span class="type">Friday</span> | <span class="type">Saturday</span> | <span class="type">Sunday</span>   </span></span><br><span class="line">           <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>, <span class="type">Enum</span>)  </span><br><span class="line"></span><br><span class="line"><span class="type">Monday</span> `compare` <span class="type">Wednesday</span> == <span class="type">LT</span>  </span><br><span class="line"><span class="title">minBound</span> :: <span class="type">Day</span> == <span class="type">Monday</span>  </span><br><span class="line"><span class="title">maxBound</span> :: <span class="type">Day</span> == <span class="type">Sunday</span>  </span><br><span class="line"><span class="title">succ</span> <span class="type">Monday</span> == <span class="type">Tuesday</span>  </span><br><span class="line"><span class="title">pred</span> <span class="type">Saturday</span> == <span class="type">Friday</span>  </span><br><span class="line">[<span class="type">Thursday</span> .. <span class="type">Sunday</span>] == [<span class="type">Thursday</span>,<span class="type">Friday</span>,<span class="type">Saturday</span>,<span class="type">Sunday</span>]  </span><br><span class="line">[minBound .. maxBound] :: [<span class="type">Day</span>] ==[<span class="type">Monday</span>, <span class="type">Tuesday</span>, <span class="type">Wednesday</span>, <span class="type">Thursday</span>, <span class="type">Friday</span>, <span class="type">Saturday</span>, <span class="type">Sunday</span>]  </span><br></pre></td></tr></tbody></table></figure>
<h3 id="type-synonyms">Type synonyms</h3>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">String</span> = [<span class="type">Char</span>]  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">PhoneNumber</span> = <span class="type">String</span>  </span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Name</span> = <span class="type">String</span>  </span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">PhoneBook</span> = [(<span class="type">Name</span>,<span class="type">PhoneNumber</span>)]  </span></span><br><span class="line"></span><br><span class="line"><span class="title">inPhoneBook</span> :: <span class="type">Name</span> -&gt; <span class="type">PhoneNumber</span> -&gt; <span class="type">PhoneBook</span> -&gt; <span class="type">Bool</span>  </span><br><span class="line"><span class="title">inPhoneBook</span> name pnumber pbook = (name,pnumber) `elem` pbook  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">AssocList</span> k v = [(<span class="title">k</span>, <span class="title">v</span>)]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">IntMap</span> = <span class="type">Map</span> <span class="type">Int</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>The names of the types and values are independent of each other. We
only use a type constructor in a type declaration or a type signature.
We only use a value constructor in actual code. So they can be the
same.</p>
<p>Another useful data type is</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Either</span> a b = <span class="type">Left</span> a | <span class="type">Right</span> b <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Read</span>, <span class="type">Show</span>)</span></span><br></pre></td></tr></tbody></table></figure>
<p>Usage:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Right</span> <span class="string">'a'</span></span><br><span class="line"><span class="type">Right</span> <span class="string">'a'</span> :: <span class="type">Either</span> a <span class="type">Char</span></span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Left</span> <span class="type">True</span></span><br><span class="line"><span class="type">Left</span> <span class="type">True</span> :: <span class="type">Either</span> <span class="type">Bool</span> b</span><br></pre></td></tr></tbody></table></figure>
<p>This type can be used instead of <code>Maybe</code> to get real
information about the returned value.</p>
<p>For example a locker simulator:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Map <span class="keyword">as</span> Map</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">LockerState</span> = <span class="type">Taken</span> | <span class="type">Free</span> <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Eq</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Code</span> = <span class="type">String</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">LockerMap</span> = <span class="type">Map</span>.<span class="type">Map</span> <span class="type">Int</span> (<span class="type">LockerState</span>, <span class="type">Code</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">lockerLookup</span> :: <span class="type">Int</span> -&gt; <span class="type">LockerMap</span> -&gt; <span class="type">Either</span> <span class="type">String</span> <span class="type">Code</span></span><br><span class="line"><span class="title">lockerLookup</span> lockerNumber map =</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Map</span>.lookup lockerNumber map <span class="keyword">of</span></span><br><span class="line">    <span class="type">Nothing</span> -&gt; <span class="type">Left</span> $ <span class="string">"Locker number "</span> ++ show lockerNumber ++ <span class="string">" doesn't exist!"</span></span><br><span class="line">    <span class="type">Just</span> (state, code) -&gt; <span class="keyword">if</span> state /= <span class="type">Taken</span></span><br><span class="line">                          <span class="keyword">then</span> <span class="type">Right</span> code</span><br><span class="line">                          <span class="keyword">else</span> <span class="type">Left</span> $ <span class="string">"Locker "</span> ++ show lockerNumber ++ <span class="string">" is already taken!"</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="recursive-data-structures">Recursive data structures</h3>
<p>For example</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> a = <span class="type">Empty</span> | <span class="type">Cons</span> a (<span class="type">List</span> <span class="title">a</span>) <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span></span><br></pre></td></tr></tbody></table></figure>
<p>Which can be written in the record syntax as:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> a = <span class="type">Empty</span> | <span class="type">Cons</span> { <span class="title">listHead</span> :: <span class="title">a</span>, <span class="title">listTail</span> :: <span class="type">List</span> <span class="title">a</span>} <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span></span><br></pre></td></tr></tbody></table></figure>
<p>Here <code>Cons</code> is another word for <code>:</code>.
<code>:</code> is actually a constructor that takes a value and another
list and returns a list.</p>
<p>We can define functions to be automatically infix by making them
comprised of only special characters. We can also do the same with
constructors</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infixr</span> <span class="number">5</span> :-:</span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">List</span> a = <span class="type">Empty</span> | a :-: (<span class="type">List</span> <span class="title">a</span>) <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Eq</span>, <span class="type">Ord</span>)</span></span><br></pre></td></tr></tbody></table></figure>
<p>When we define functions as operators, we can use that to give them a
fixity. A fixity states how tightly the operator binds and whether it's
left-associative <code>infixl</code> or right-associative
<code>infixr</code>.</p>
<p>When deriving <code>Show</code> for our type, Haskell will still
display it as if the constructor was a prefix function.</p>
<h4 id="binary-search-tree">Binary search tree</h4>
<p>An example of implementation of the binary search tree</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">EmptyTree</span> | <span class="type">Node</span> a (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>) <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Eq</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="title">singleton</span> :: a -&gt; <span class="type">Tree</span> a</span><br><span class="line"><span class="title">singleton</span> x = <span class="type">Node</span> x <span class="type">EmptyTree</span> <span class="type">EmptyTree</span></span><br><span class="line"></span><br><span class="line"><span class="title">treeInsert</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; <span class="type">Tree</span> a -&gt; <span class="type">Tree</span> a</span><br><span class="line"><span class="title">treeInsert</span> x <span class="type">EmptyTree</span> = singleton x</span><br><span class="line"><span class="title">treeInsert</span> x (<span class="type">Node</span> a left right)</span><br><span class="line">	| x == a = <span class="type">Node</span> x left right</span><br><span class="line">	| x &lt;  a = <span class="type">Node</span> a (treeInsert x left) right</span><br><span class="line">	| x &gt;  a = <span class="type">Node</span> a left (treeInsert x right)</span><br><span class="line">	</span><br><span class="line"><span class="title">treeElem</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; <span class="type">Tree</span> a -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">treeElem</span> x <span class="type">EmptyTree</span> = <span class="type">False</span></span><br><span class="line"><span class="title">treeElem</span> x (<span class="type">Node</span> a left right)</span><br><span class="line">	| x == a = <span class="type">True</span></span><br><span class="line">	| x &lt;  a = treeElem x left</span><br><span class="line">	| x &gt;  a = treeElem x right</span><br><span class="line">	</span><br><span class="line"><span class="title">let</span> numsTree = foldr treeInsert <span class="type">EmptyTree</span> [<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br></pre></td></tr></tbody></table></figure>
<h3 id="typeclasses">Typeclasses</h3>
<p>For example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span></span><br><span class="line">	(==) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">	(/=) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">	x == y = not (x /= y)</span><br><span class="line">	x /= y = not (x == y)</span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">TrafficLight</span> = <span class="type">Red</span> | <span class="type">Yellow</span> | <span class="type">Green</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> <span class="type">TrafficLight</span> <span class="keyword">where</span></span></span><br><span class="line">	<span class="type">Red</span> == <span class="type">Red</span> = <span class="type">True</span></span><br><span class="line">	<span class="type">Green</span> == <span class="type">Green</span> = <span class="type">True</span></span><br><span class="line">	<span class="type">Yellow</span> == <span class="type">Yellow</span> = <span class="type">True</span></span><br><span class="line">	_ == _ = <span class="type">False</span></span><br><span class="line"><span class="class">	</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">TrafficLight</span> <span class="keyword">where</span></span></span><br><span class="line">	show <span class="type">Red</span> = <span class="string">"Red light"</span></span><br><span class="line">	show <span class="type">Yellow</span> = <span class="string">"Yellow light"</span></span><br><span class="line">	show <span class="type">Green</span> = <span class="string">"Green light"</span></span><br><span class="line"><span class="class">	</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Eq</span> <span class="title">m</span>) =&gt; <span class="type">Eq</span> (<span class="type">Maybe</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">	<span class="type">Just</span> x == <span class="type">Just</span> y = x == y</span><br><span class="line">	<span class="type">Nothing</span> == <span class="type">Nothing</span> = <span class="type">True</span></span><br><span class="line">	_ == _ = <span class="type">False</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="the-functor-typeclass">The Functor typeclass</h4>
<p>Types with the <code>Functor</code> typeclass is basically those
things that can be mapped over, i.e. the list type is part of the
<code>Functor</code> typeclass.</p>
<p>For example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">	fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> [] <span class="keyword">where</span></span></span><br><span class="line">	fmap = map</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">	fmap f (<span class="type">Just</span> x) = <span class="type">Just</span> (f x)</span><br><span class="line">	fmap f <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Tree</span> <span class="keyword">where</span></span></span><br><span class="line">	fmap f <span class="type">EmptyTree</span> = <span class="type">EmptyTree</span></span><br><span class="line">	fmap f (<span class="type">Node</span> x leftsub rightsub) = <span class="type">Node</span> (f x) (fmap f leftsub) (fmap f rightsub)</span><br><span class="line"><span class="class">	</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> (<span class="type">Either</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">	fmap f (<span class="type">Right</span> x) = <span class="type">Right</span> (f x)</span><br><span class="line">	fmap f (<span class="type">Left</span> x) = <span class="type">Left</span> x</span><br></pre></td></tr></tbody></table></figure>
<h2 id="input-and-output">9. Input and Output</h2>
<h3 id="hello-world">Hello, world!</h3>
<p>In file <code>helloworld.hs</code></p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = putStrLn <span class="string">"Hello, world"</span></span><br></pre></td></tr></tbody></table></figure>
<p>To compile and run:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ghc --make helloworld</span></span><br><span class="line">[1 of 1] Compiling Main             ( helloworld.hs, helloworld.o )  </span><br><span class="line">Linking helloworld ...  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./helloworld</span></span><br><span class="line">Hello, world</span><br></pre></td></tr></tbody></table></figure>
<p>The type of the function <code>putStrLn</code>:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t putStrLn</span><br><span class="line"><span class="title">putStrLn</span> :: <span class="type">String</span> -&gt; <span class="type">IO</span> ()</span><br></pre></td></tr></tbody></table></figure>
<p>A more useful example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	putStrLn <span class="string">"Hello, what's your name?"</span></span><br><span class="line">	name &lt;- getLine</span><br><span class="line">	putStrLn (<span class="string">"Hey "</span> ++ name ++ <span class="string">", you rock!"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>Each of these steps is an I/O action. By putting them together with
<code>do</code> syntax, we glued them into one I/O action. The action
that we got has a type of <code>IO ()</code>, because that's the type of
the last I/O action inside. The last action cannot be bound to a name
like the first two.</p>
<p>The type of <code>getLine</code></p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t getLine</span><br><span class="line"><span class="title">getLine</span> :: <span class="type">IO</span> <span class="type">String</span></span><br></pre></td></tr></tbody></table></figure>
<p>The <code>getLine</code> perform the I/O action and then bind its
result value to <code>name</code>. <code>getLine</code> has a type of
<code>IO String</code>, so <code>name</code> will have a type of
<code>String</code>.</p>
<p>Another example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	line &lt;- getLine</span><br><span class="line">	<span class="keyword">if</span> null line</span><br><span class="line">		<span class="keyword">then</span> return ()</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">do</span> </span><br><span class="line">			putStrLn $ reverseWords line</span><br><span class="line">			main</span><br><span class="line"></span><br><span class="line"><span class="title">reverseWords</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">reverseWords</span> = unwords . map reverse . words</span><br></pre></td></tr></tbody></table></figure>
<p>Using <code>return</code> doesn't cause the I/O do block to end in
execution or anything like that. The <code>return</code> makes I/O
actions that don't really do anything except have an encapsulated result
and that result is thrown away because it isn't bound to a name. For
example:</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span> </span><br><span class="line">	a &lt;- return <span class="string">"hell"</span></span><br><span class="line">	b &lt;- return <span class="string">"yeah!"</span></span><br><span class="line">	putStrLn $ a ++ <span class="string">" "</span> ++ b</span><br></pre></td></tr></tbody></table></figure>
<p><code>return</code> is sort of the opposite to <code>&lt;-</code>.
While <code>return</code> takes a value and wraps it up in a box,
<code>&lt;-</code> takes a box (and performs it) and takes the value out
of it, binding it to a name.</p>
<p>There are more I/O functions:</p>
<ul>
<li><p><code>putStr</code></p></li>
<li><p><code>putChar</code></p></li>
<li><p><code>print</code> == <code>putStrLn . show</code></p></li>
<li><p><code>getChar</code></p></li>
<li><p><code>when</code>: it looks like a control flow statement, but
it's actually a normal function. It takes a boolean value and an I/O
action. If that boolean value is <code>True</code>, it returns the same
I/O action that we supplied to it. If it is <code>False</code>, it
returns the <code>return ()</code>.</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	c &lt;- getChar</span><br><span class="line">	when (c /= <span class="string">' '</span>) $ <span class="keyword">do</span></span><br><span class="line">		putChar c</span><br><span class="line">		main</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>sequence</code> takes a list of I/O actions and returns an
I/O actions that will perform those actions one after the other. The
result contained in that I/O action will be a list of the results of all
the I/O actions that were performed.</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	rs &lt;- sequence [map print [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">	print rs</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>mapM</code>: takes a function and a list, maps the function
over the list and then sequences it</p>
<ul>
<li><code>mapM_</code> does the same, only it throws away the result
later. We usually use <code>mapM_</code> when we don't care what result
our sequenced I/O actions have.</li>
<li><code>forM</code>: like <code>mapM</code>, only that it has its
parameters switched around.</li>
</ul></li>
<li><p><code>forever</code>: takes an I/O action and returns an I/O
action that just repeats the I/O action it got forever.</p>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"><span class="keyword">import</span> Data.Char</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = forever $ <span class="keyword">do</span></span><br><span class="line">	putStr <span class="string">"Give me some input: "</span></span><br><span class="line">	l &lt;- getLine</span><br><span class="line">	putStrLn $ map toUpper l</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="files-and-streams">Files and streams</h3>
<p><code>getContents</code> is an I/O action that reads everything from
the standard input until it encounters an end-of-file character. Its
type is <code>getContents :: IO String</code>. <code>getContents</code>
goes a lazy I/O, it doesn't read all of the input at once. For example:
</p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Char</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	contents &lt;- getContents</span><br><span class="line">	putStr (map toUpper contexts)</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>There is a function called <code>interact</code> that takes a
function of type <code>String -&gt; String</code> as a parameter and
returns an I/O action that will take some input, run that function on it
and then print out the function's result. For example to filter only
lines shorter than 10 characters: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = interact shortLinesOnly</span><br><span class="line"></span><br><span class="line"><span class="title">shortLinesOnly</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">shortLinesOnly</span> input = </span><br><span class="line">	<span class="keyword">let</span> allLines = lines input</span><br><span class="line">		shortLiens = filter (\line -&gt; length line &lt; <span class="number">10</span>) allLines</span><br><span class="line">		result = unlines shortLines</span><br><span class="line">	<span class="keyword">in</span> result</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Which can be reduced to one line: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = interact $ unlines . filter ((&lt; <span class="number">10</span>) . length) . lines</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>For file read, there is a function called <code>hGetContents</code>.
It takes a <code>Handle</code>, so it knows which file to get the
contents from and returns an <code>IO String</code> - an I/O action that
holds as its result the contents of the file. <code>hGetContents</code>
won't attempt to read the file at once and store it in memory, but it
will read it as needed. For example: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	handle &lt;- openFile <span class="string">"file_to_read.txt"</span> <span class="type">ReadMode</span></span><br><span class="line">	contents &lt;- hGetContents handle</span><br><span class="line">	putStr contents</span><br><span class="line">	hClose handle</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Another way of doing this is with <code>withFile</code>:
</p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	withFile <span class="string">"file_to_read.txt"</span> <span class="type">ReadMode</span> (\handle -&gt; <span class="keyword">do</span></span><br><span class="line">		contents &lt;- hGetContents handle</span><br><span class="line">		putStr contents)</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>The <code>withFile</code> can be implemented in the following way:
</p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">withFile'</span> :: <span class="type">FilePath</span> -&gt; <span class="type">IOMode</span> -&gt; (<span class="type">Handle</span> -&gt; <span class="type">IO</span> a) -&gt; <span class="type">IO</span> a</span><br><span class="line"><span class="title">withFile'</span> path mode f = <span class="keyword">do</span></span><br><span class="line">	handle &lt;- openFile path mode</span><br><span class="line">	result &lt;- f handle</span><br><span class="line">	hClose handle</span><br><span class="line">	return result</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Other functions to read and write file: * <code>readFile</code> has a
type signature of <code>readFile :: FilePath -&gt; IO String</code>.
<code>readFile</code> takes a path to a file and return an I/O action
that will read that file (lazily) and bind its contents to something as
a string. * <code>writeFile</code> has a type of
<code>writeFile :: FilePath -&gt; String -&gt; IO ()</code>. It takes a
path to a file and a string to write to that file and returns an I/O
action that will do the writing. * <code>appendFile</code> has a type
signature that's just like <code>writeFile</code>, only
<code>appendFile</code> doesn't truncate the file to zero length if it
already exists but it appends stuff to it.</p>
<p>You can control how exactly buffering is done by using the
<code>hSetBuffering</code> function. It takes a handle and a
<code>BufferMode</code> and returns an I/O action that sets the
buffering. <code>BufferMode</code> is a simple enumeration data type and
the possible values it can hold are: <code>NoBuffering</code>,
<code>LineBuffering</code> or <code>BlockBuffering (Maybe Int)</code>.
The <code>Maybe Int</code> is for how big the chunk should be, in bytes.
If it is <code>Nothing</code>, then the operating system determines the
chunk size. <code>NoBuffering</code> means that it will be read one
character at a time. For example: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	withFile <span class="string">"something.txt"</span> <span class="type">ReadMode</span> (\handle -&gt; <span class="keyword">do</span></span><br><span class="line">		hSetBuffering handle $ <span class="type">BlockBuffering</span> (<span class="type">Just</span> <span class="number">2048</span>)</span><br><span class="line">		contents &lt;- hGetContents handle</span><br><span class="line">		putStr contents)</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>We can also use <code>hFlush</code>, which is a function that takes a
handle and returns an I/O action that will flush the buffer of the file
associated with the handle.</p>
<h3 id="command-line-arguments">Command line arguments</h3>
<p>The <code>System.Environment</code> module has two cool I/O actions.
One is <code>getArgs</code>, which has a type of
<code>getArgs :: IO [String]</code> and is an I/O action that will get
the arguments that the program was run with and have as its contained
result a list with the arguments. <code>getProgName</code> has a type of
<code>getProgName :: IO String</code> and is an I/O action that contains
the program name: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> System.Environment</span><br><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	args &lt;- getArgs</span><br><span class="line">	progName &lt;- getProgName</span><br><span class="line">	putStrLn <span class="string">"The arguments are: "</span></span><br><span class="line">	mapM putStrLn args</span><br><span class="line">	putStrLn <span class="string">"The program name is: "</span></span><br><span class="line">	putStrLn progName</span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="a-simple-todo-list-apps">A simple todo list apps</h4>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> System.Environment</span><br><span class="line"><span class="keyword">import</span> System.Directory</span><br><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"></span><br><span class="line"><span class="title">dispatch</span> :: [(<span class="type">String</span>, [<span class="type">String</span>] -&gt; <span class="type">IO</span> ())]</span><br><span class="line"><span class="title">dispatch</span> = [</span><br><span class="line">	(<span class="string">"add"</span>, add),</span><br><span class="line">	(<span class="string">"view"</span>, view),</span><br><span class="line">	(<span class="string">"remove"</span>, remove)</span><br><span class="line">	]</span><br><span class="line">	</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">	(command:args) &lt;- getArgs</span><br><span class="line">	<span class="keyword">let</span> (<span class="type">Just</span> action) = lookup command dispatch</span><br><span class="line">	action args</span><br><span class="line"></span><br><span class="line"><span class="title">add</span> :: [<span class="type">String</span>] -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">add</span> [fileName, todoItem] = appendFile fileName (todoItem ++ <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">view</span> :: [<span class="type">String</span>] -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">view</span> [fileName] = <span class="keyword">do</span> </span><br><span class="line">	contents &lt;- readFile fileName</span><br><span class="line">	<span class="keyword">let</span> todoTasks = lines contents</span><br><span class="line">		numberedTasks = zipWith (\n line -&gt; show n ++ <span class="string">" - "</span> ++ line) [<span class="number">0</span>..] todoTasks</span><br><span class="line">	putStr $ unlines numberedTasks</span><br><span class="line"></span><br><span class="line"><span class="title">remove</span> :: [<span class="type">String</span>] -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">remove</span> [fileName, numberString] = <span class="keyword">do</span> </span><br><span class="line">	handle &lt;- openFile fileName <span class="type">ReadMode</span></span><br><span class="line">	(tempName, tempHandle) &lt;- openTempFile <span class="string">"."</span> <span class="string">"temp"</span></span><br><span class="line">	contents &lt;- hGetContents handle</span><br><span class="line">	<span class="keyword">let</span> number = read numberString </span><br><span class="line">		todoTasks = lines contents</span><br><span class="line">		newTodoItems = delete (todoTasks !! number) todoTasks</span><br><span class="line">	hPutStr tempHandle $ unlines newTodoItems</span><br><span class="line">	hClose handle</span><br><span class="line">	hClose tempHandle</span><br><span class="line">	removeFile fileName</span><br><span class="line">	renameFile tempName fileName</span><br></pre></td></tr></tbody></table></figure>
<h3 id="bytestrings">Bytestrings</h3>
<p>Bytestrings are sort of like lists, only each element is one byte (or
8 bits) in size. Bytestrings come in two flavors: strict and lazy ones.
Strict bytestrings reside in <code>Data.ByteString</code>. A strict
bytestring represents a series of bytes in an array. The upside is that
there's less overhead because there are no thunks involved. The downside
is that they're likely to fill your memory up faster.</p>
<p>The other variety of bytestrings resides in
<code>Data.ByteString.Lazy</code>. If you evaluatea byte in a lazy
bytestring, the first 64K will be evalated. After that, it's just a
promise for the rest of the chunks.</p>
<p>For example: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.ByteString.Lazy <span class="keyword">as</span> B </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.ByteString <span class="keyword">as</span> S </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">B</span>.pack [<span class="number">99</span>,<span class="number">97</span>,<span class="number">110</span>] </span><br><span class="line"><span class="type">Chunk</span> <span class="string">"can"</span> <span class="type">Empty</span> </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">B</span>.pack [<span class="number">98</span>..<span class="number">120</span>] </span><br><span class="line"><span class="type">Chunk</span> <span class="string">"bcdefghijklmnopqrstuvwx"</span> <span class="type">Empty</span> </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">B</span>.fromChunks [<span class="type">S</span>.pack [<span class="number">40</span>,<span class="number">41</span>,<span class="number">42</span>], <span class="type">S</span>.pack [<span class="number">43</span>,<span class="number">44</span>,<span class="number">45</span>], <span class="type">S</span>.pack [<span class="number">46</span>,<span class="number">47</span>,<span class="number">48</span>]] </span><br><span class="line"><span class="type">Chunk</span> <span class="string">"()*"</span> (<span class="type">Chunk</span> <span class="string">"+,-"</span> (<span class="type">Chunk</span> <span class="string">"./0"</span> <span class="type">Empty</span>)) </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">B</span>.cons <span class="number">85</span> $ <span class="type">B</span>.pack [<span class="number">80</span>,<span class="number">81</span>,<span class="number">82</span>,<span class="number">84</span>] </span><br><span class="line"><span class="type">Chunk</span> <span class="string">"U"</span> (<span class="type">Chunk</span> <span class="string">"PQRT"</span> <span class="type">Empty</span>) </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">B</span>.cons' <span class="number">85</span> $ <span class="type">B</span>.pack [<span class="number">80</span>,<span class="number">81</span>,<span class="number">82</span>,<span class="number">84</span>] </span><br><span class="line"><span class="type">Chunk</span> <span class="string">"UPQRT"</span> <span class="type">Empty</span> </span><br><span class="line"><span class="title">ghci</span>&gt; foldr <span class="type">B</span>.cons <span class="type">B</span>.empty [<span class="number">50</span>..<span class="number">60</span>] </span><br><span class="line"><span class="type">Chunk</span> <span class="string">"2"</span> (<span class="type">Chunk</span> <span class="string">"3"</span> (<span class="type">Chunk</span> <span class="string">"4"</span> (<span class="type">Chunk</span> <span class="string">"5"</span> (<span class="type">Chunk</span> <span class="string">"6"</span> (<span class="type">Chunk</span> <span class="string">"7"</span> (<span class="type">Chunk</span> <span class="string">"8"</span> (<span class="type">Chunk</span> <span class="string">"9"</span> (<span class="type">Chunk</span> <span class="string">":"</span> (<span class="type">Chunk</span> <span class="string">";"</span> (<span class="type">Chunk</span> <span class="string">"&lt;"</span> </span><br><span class="line"><span class="type">Empty</span>)))))))))) </span><br><span class="line"><span class="title">ghci</span>&gt; foldr <span class="type">B</span>.cons' <span class="type">B</span>.empty [<span class="number">50</span>..<span class="number">60</span>] </span><br><span class="line"><span class="type">Chunk</span> <span class="string">"23456789:;&lt;"</span> <span class="type">Empty</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="exceptions">Exceptions</h3>
<p>Pure code can throw exceptions, but they can only be caught in the
I/O part of our code. But for a good practice, don't mix exceptions and
pure code. Take advatange of Haskell's powerful type system and use
types like <code>Either</code> and <code>Maybe</code> to represent
results that may have failed.</p>
<p>An example: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> System.Environment</span><br><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"><span class="keyword">import</span> System.Directory</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span> (fileName:_) &lt;- getArgs</span><br><span class="line">	fileExists &lt;- doesFileExist fileName</span><br><span class="line">	<span class="keyword">if</span> fileExists</span><br><span class="line">		<span class="keyword">then</span> <span class="keyword">do</span> contents &lt;- readFile fileName</span><br><span class="line">			putStrLn $ <span class="string">"The file has "</span> ++ show (length (lines contents)) ++ <span class="string">" lines!"</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">do</span> putStrLn <span class="string">"The file doesn't exist!"</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>With exception: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> System.Environment</span><br><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"><span class="keyword">import</span> System.IO.Error</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = toTry `catch` handler</span><br><span class="line"></span><br><span class="line"><span class="title">toTry</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">toTry</span> = <span class="keyword">do</span> (fileName:_) &lt;- getArgs</span><br><span class="line">	contents &lt;- readFile fileName</span><br><span class="line">	putStrLn $ <span class="string">"The file has "</span> ++ show (length (lines contents)) ++ <span class="string">" lines"</span></span><br><span class="line"></span><br><span class="line"><span class="title">handler</span> :: <span class="type">IOError</span> -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">handler</span> e</span><br><span class="line">	| isDoesNotExistError e = putStrLn <span class="string">"The file doesn't exist"</span></span><br><span class="line">	| otherwise = ioError e</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>The predicates that act on <code>IOError</code> are: *
<code>isAlreadyExistError</code> * <code>isDoesNotExistError</code> *
<code>isAlreadyInUseError</code> * <code>isFullError</code> *
<code>isEOFError</code> * <code>isIllegalOperation</code> *
<code>isPermissionError</code> * <code>isUserError</code></p>
<h2 id="functors-applicative-functors-and-monoids">10. Functors,
Applicative, Functors and Monoids</h2>
<h3 id="functors-redux">Functors redux</h3>
<p>Functors are things that can be mapped over, like lists,
<code>Maybe</code>s, trees, and such. In Haskell, they are described by
the typeclass <code>Functor</code>, which has only one typeclass method,
namely <code>fmap</code>, which has a type of
<code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>.</p>
<p>Let's see how <code>IO</code> is an instance of <code>Functor</code>.
When we <code>fmap</code> a function over an I/O action, we want to get
back an I/O action that does the same thing, but has our function
applied over its result value. </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">IO</span> <span class="keyword">where</span></span> </span><br><span class="line">	fmap f action = <span class="keyword">do</span> </span><br><span class="line">		result &lt;- action</span><br><span class="line">		return (f result)</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span> line &lt;- fmap reverse getLine</span><br><span class="line">	putStrLn $ <span class="string">"You said "</span> ++ line ++ <span class="string">" backwards!"</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>The result of mapping something over an I/O action will be an I/O
action, so right off the bat we use do syntax to glue two actions and
make a new one.</p>
<p>Another instance of <code>Functor</code> that we've been dealing with
all along without knowing was <code>(-&gt;) r</code>.
</p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span> </span><br><span class="line">	fmap f g = (\x -&gt; f (g x))</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Its type is then
<code>fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</code>
which reminds us about function compositions. Thus it can be written as:
</p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span> </span><br><span class="line">	fmap = (.)</span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="law-of-functor">Law of Functor</h4>
<ol type="1">
<li>If we map the <code>id</code> function over a functor, the functor
that we get back should be the same as the original functor.</li>
<li>Composing two functions and then mapping the resulting function over
a functor should be the same as first mapping one function over the
functor and then mapping the other one.</li>
</ol>
<h3 id="applicative-functors">Applicative Functors</h3>
<p>Applicative functors are represented in Haskell by the
<code>Applicative</code> typeclass, found in the
<code>Control.Applicative</code> module. </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Functor</span> <span class="title">f</span>) =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span> </span><br><span class="line">	pure :: a -&gt; f a</span><br><span class="line">	(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>It starts the definition of the <code>Applicative</code> class and it
also introduces a class constraint. It says that if we want to make a
type onstructor part of the <code>Applicative</code> typeclass, it has
to be in <code>Functor</code> first. The first method it defines is
called <code>pure</code>. <code>pure</code> should take a value of any
type and return an applicative functor with that value inside it. The
<code>&lt;*&gt;</code> function has a type declaration of
<code>f (a -&gt; b) -&gt; f a -&gt; f b</code>. It's a sort of a beefed
up <code>fmap</code>. <code>&lt;*&gt;</code> takes a fnctor that has a
function in it and another functor and sort of extracts that function
from the first functor and then maps it over the second one.</p>
<p>For example, <code>Applicative</code> instance implementation for
<code>Maybe</code>: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span> </span><br><span class="line">	pure = <span class="type">Just</span></span><br><span class="line">	<span class="type">Nothing</span> &lt;*&gt; _ = <span class="type">Nothing</span></span><br><span class="line">	(<span class="type">Just</span> f) &lt;*&gt; something = fmap f something</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; pure (+) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span> </span><br><span class="line"><span class="type">Just</span> <span class="number">8</span> </span><br><span class="line"><span class="title">ghci</span>&gt; pure (+) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Nothing</span> </span><br><span class="line"><span class="type">Nothing</span> </span><br><span class="line"><span class="title">ghci</span>&gt; pure (+) &lt;*&gt; <span class="type">Nothing</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span> </span><br><span class="line"><span class="type">Nothing</span> </span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>Applicative</code> instance implementaton for lists:
</p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> [] <span class="keyword">where</span></span></span><br><span class="line">	pure x = [x]</span><br><span class="line">	fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [(+),(*)] &lt;*&gt; [<span class="number">1</span>,<span class="number">2</span>] &lt;*&gt; [<span class="number">3</span>,<span class="number">4</span>] </span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>] </span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>Control.Applicative</code> also exports a function called
<code>&lt;$&gt;</code>, which is just <code>fmap</code> as an infix
operator: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(&lt;$&gt;) :: (<span class="type">Functor</span> f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="title">f</span> &lt;$&gt; x = fmap f x</span><br><span class="line"></span><br><span class="line">(*) &lt;$&gt; [<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>] &lt;*&gt; [<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>] </span><br><span class="line">[<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>] </span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="monoids">Monoids</h3>
<p>A monoid is when you have an associative binary function and a value
which acts as an identity with respect to that function. When something
acts as an identity with respect to a function, it means hat when called
with that function and some other value, the result is always equal to
that other value.</p>
<p>It is defined as: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monoid</span> m <span class="keyword">where</span></span></span><br><span class="line">	mempty :: m</span><br><span class="line">	mappend :: m -&gt; m -&gt; m</span><br><span class="line">	mconcat :: [m] -&gt; m</span><br><span class="line">	mconcat = foldr mappend mempty</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>The <code>Monoid</code> type class is defined in
<code>Data.Monoid</code>. List, product, and sum are all monoids. For
example: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Monoid</span> (<span class="type">Product</span> <span class="title">a</span>) <span class="keyword">where</span></span> </span><br><span class="line">	mempty = <span class="type">Product</span> <span class="number">1</span></span><br><span class="line">	<span class="type">Product</span> x `mappend` <span class="type">Product</span> y = <span class="type">Product</span> (x * y)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; getProduct $ <span class="type">Product</span> <span class="number">3</span> `mappend` <span class="type">Product</span> <span class="number">9</span> </span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="title">ghci</span>&gt; getProduct $ <span class="type">Product</span> <span class="number">3</span> `mappend` mempty </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="title">ghci</span>&gt; getProduct . mconcat . map <span class="type">Product</span> $ [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>] </span><br><span class="line"><span class="number">24</span> </span><br></pre></td></tr></tbody></table></figure><p></p>
<h4 id="monoid-instance-for-ordering">Monoid instance for
<code>Ordering</code></h4>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Ordering</span> <span class="keyword">where</span></span></span><br><span class="line">	mempty = <span class="type">EQ</span> </span><br><span class="line">	<span class="type">LT</span> `mappend` _ = <span class="type">LT</span></span><br><span class="line">	<span class="type">EQ</span> `mappend` y = y</span><br><span class="line">	<span class="type">GT</span> `mappend` _ = <span class="type">GT</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="maybe-the-monoid"><code>Maybe</code> the Monoid</h4>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> a =&gt; <span class="type">Monoid</span> (<span class="type">Maybe</span> <span class="title">a</span>) <span class="keyword">where</span></span>  </span><br><span class="line">    mempty = <span class="type">Nothing</span>  </span><br><span class="line">    <span class="type">Nothing</span> `mappend` m = m  </span><br><span class="line">    m `mappend` <span class="type">Nothing</span> = m  </span><br><span class="line">    <span class="type">Just</span> m1 `mappend` <span class="type">Just</span> m2 = <span class="type">Just</span> (m1 `mappend` m2)  </span><br></pre></td></tr></tbody></table></figure>
<h2 id="monads">11. Monads</h2>
<p>Monads are just beefed up applicative functors, much like applicative
functors are only beefed up functors.</p>
<p>An applicative value can be seeen as a value with an added context.
The <code>Applicative</code> type class allowed us tp use normal
functions on these values with context and the context was preserved.
For example, <code>Maybe a</code> values represent computations that
might have failed, <code>[a]</code> values represent computations that
have several results (non-deterministic computations), <code>IO a</code>
values represent values that have side-effects, etc.</p>
<p>Monads are a natural extension of applicative functors. If you have a
value with a context, <code>m a</code>, how do you apply it to a
function that takes a normal <code>a</code> and returns a value with a
context? So essentially, we will want this function: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&gt;&gt;=) :: (<span class="type">Monad</span> m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Monads are just applicative functors that support
<code>&gt;&gt;=</code>. The <code>&gt;&gt;=</code> function is
pronounced as bind.</p>
<h3 id="maybe-monad"><code>Maybe</code> Monad</h3>
<p><code>Maybe</code> is a monad. <code>&gt;&gt;=</code> would take a
<code>Maybe a</code> value and a function of type
<code>a -&gt; Maybe b</code> and somehow apply the function to the
<code>Maybe a</code>. For example </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (\x -&gt; <span class="type">Just</span> (x+<span class="number">1</span>)) <span class="number">1</span></span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Instead of calling it <code>&gt;&gt;=</code>, let's call it
<code>applyMaybe</code> for now. It takes a <code>Maybe a</code> and a
function that returns a <code>Maybe b</code> and manages to apply that
function to the <code>Maybe a</code>: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">applyMaybe</span> :: <span class="type">Maybe</span> a -&gt; (a -&gt; <span class="type">Maybe</span> b) -&gt; <span class="type">Maybe</span> b</span><br><span class="line"><span class="title">applyMaybe</span> <span class="type">Nothing</span> f  = <span class="type">Nothing</span></span><br><span class="line"><span class="title">applyMaybe</span> (<span class="type">Just</span> x) f = f x</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">3</span> `applyMaybe` \x -&gt; <span class="type">Just</span> (x+<span class="number">1</span>) </span><br><span class="line"><span class="type">Just</span> <span class="number">4</span> </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="string">"smile"</span> `applyMaybe` \x -&gt; <span class="type">Just</span> (x ++ <span class="string">" :)"</span>) </span><br><span class="line"><span class="type">Just</span> <span class="string">"smile :)"</span> </span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="the-monad-type-class">The monad type class</h3>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m <span class="keyword">where</span></span> </span><br><span class="line">	return :: a -&gt; m a</span><br><span class="line">	</span><br><span class="line">	(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">	</span><br><span class="line">	(&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">	x &gt;&gt; y = x &gt;&gt;= \_ -&gt; y</span><br><span class="line">	</span><br><span class="line">	fail :: <span class="type">String</span> -&gt; m a</span><br><span class="line">	fail msg = error msg</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>We don't need to write
<code>class (Applicative m) =&gt; Monad m where</code> because every
monad is an applicative functor by default.</li>
<li><code>return</code> is the same as <code>pure</code>, only with a
different name. It takes a value and puts it in a minimal default
context that still holds that value. In other words, it takes something
and wraps it in a monad.</li>
<li>The next function is <code>&gt;&gt;=</code>, or bind. It's like
tunction application, only instead of taking a normal value and feeding
it to a normal function, it takes a monadic value and feeds it to a
function that takes a normal value but returns monadic value.</li>
<li>The <code>&gt;&gt;</code> function comes with a default
implementation and we pretty much never implement it when making
<code>Monad</code> instances. <code>&gt;&gt;</code> is used when we want
to pass some value to a function that ignores its parameter and always
just returns some predetermined value.</li>
<li><code>fail</code> function will not be used explicitly in our code.
Instead, it's used by Haskell to enable failure in a special syntactic
construct for monads that we'll meet later.</li>
</ul>
<p><code>Maybe</code> monad: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">	return x  = <span class="type">Just</span> x</span><br><span class="line">	<span class="type">Nothing</span> &gt;&gt;= f = <span class="type">Nothing</span></span><br><span class="line">	<span class="type">Just</span> x  &gt;&gt;= f x</span><br><span class="line">	fail _    = <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; return <span class="string">"wait"</span> :: <span class="type">Maybe</span> <span class="type">String</span></span><br><span class="line"><span class="type">Just</span> <span class="string">"wait"</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">9</span> &gt;&gt;= \x -&gt; return (x * <span class="number">10</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">90</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &gt;&gt;= \x -&gt; return (x * <span class="number">10</span>)</span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="do-notation">do notation</h3>
<p>The <code>do</code> notation isn't just for <code>IO</code>, but can
be used for any monad. Its principle is the same, gluing together
monadic values in sequence.</p>
<p>The following example: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">3</span> &gt;&gt;= (\x -&gt; <span class="type">Just</span> <span class="string">"!"</span> &gt;&gt;= (\y -&gt; <span class="type">Just</span> (show x ++ y)))</span><br><span class="line"><span class="type">Just</span> <span class="string">"3!"</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Can be written as: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foo</span> :: <span class="type">Maybe</span> <span class="type">String</span></span><br><span class="line"><span class="title">foo</span> = <span class="keyword">do</span></span><br><span class="line">	x &lt;- <span class="type">Just</span> <span class="number">3</span></span><br><span class="line">	y &lt;- <span class="type">Just</span> <span class="string">"!"</span></span><br><span class="line">	<span class="type">Just</span> (show x ++ y)</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>In a <code>do</code> expression, every line is a monadic value.
</p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">routine</span> :: <span class="type">Maybe</span> <span class="type">Soup</span></span><br><span class="line"><span class="title">routine</span> = <span class="keyword">do</span></span><br><span class="line">	start &lt;- return (<span class="number">0</span>,<span class="number">0</span>)      <span class="comment">-- means (water, salt)</span></span><br><span class="line">	first &lt;- addSalt <span class="number">4</span> start   <span class="comment">-- becomes (0, 4)</span></span><br><span class="line">	<span class="type">Nothing</span>                    <span class="comment">-- means too salty</span></span><br><span class="line">	second &lt;- addWater <span class="number">2</span> first <span class="comment">-- too late to add water</span></span><br><span class="line">	addWater <span class="number">2</span> second          <span class="comment">-- final result</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="the-list-monad">The list monad</h3>
<p>The <code>Monad</code> instance for lists: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> [] <span class="keyword">where</span></span> </span><br><span class="line">	return x = [x]</span><br><span class="line">	xs &gt;&gt;= f = concat (map f xs)</span><br><span class="line">	fail _ = []</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] &gt;&gt;= \x -&gt; [x, -x]</span><br><span class="line">[<span class="number">3</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">4</span>,<span class="number">5</span>,-<span class="number">5</span>]</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Another example of propagation of the non-determinism:
</p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>] &gt;&gt;= \n -&gt; [<span class="string">'a'</span>, <span class="string">'b'</span>] &gt;&gt;= \ch -&gt; return (n, ch)</span><br><span class="line">[(<span class="number">1</span>,<span class="string">'a'</span>),(<span class="number">1</span>,<span class="string">'b'</span>),(<span class="number">2</span>,<span class="string">'a'</span>),(<span class="number">2</span>,<span class="string">'b'</span>)]</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>It is much clearer with <code>do</code> notation: </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">listOfTuples</span> :: [(<span class="type">Int</span>, <span class="type">Char</span>)]</span><br><span class="line"><span class="title">listOfTuples</span> = <span class="keyword">do</span></span><br><span class="line">	n &lt;- [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">	ch &lt;- [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">	return (n, ch)</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>This is similar to list comprehensions. In fact, list comprehensions
are just syntactic sugar for using lists as monads. </p><figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [ (n, ch) | n &lt;- [<span class="number">1</span>,<span class="number">2</span>], ch &lt;- [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br><span class="line">[(<span class="number">1</span>,<span class="string">'a'</span>),(<span class="number">1</span>,<span class="string">'b'</span>),(<span class="number">2</span>,<span class="string">'a'</span>),(<span class="number">2</span>,<span class="string">'b'</span>)]</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="monad-laws">Monad laws</h3>
<ul>
<li>Left identity: If we take a value, put it in a default context with
<code>return</code> and then feed it to a function by using
<code>&gt;&gt;=</code>, it's the same as just taking the value and
applying the function to it. Formally:
<ul>
<li><code>return x &gt;&gt;= f</code> is the same thing as
<code>f x</code></li>
</ul></li>
<li>Right identity: If we have a monadic value and we use
<code>&gt;&gt;=</code> to feed it to <code>return</code>, the result is
our original monadic value. Formally:
<ul>
<li><code>m &gt;&gt;= return</code> is no different than just
<code>m</code></li>
</ul></li>
<li>Associativity: When we have a chain of monadic function applications
with <code>&gt;&gt;=</code>, it shouldn't matter how they're nested.
Formally:
<ul>
<li>Doing <code>(m &gt;&gt;= f) &gt;&gt;= g</code> is just like doing
<code>m &gt;&gt;= (\x -&gt; f x  &gt;&gt;= g)</code></li>
</ul></li>
</ul>
<h3 id="add-log-to-code-with-the-writer-type">Add log to code with the
Writer type</h3>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Writer</span> w a = <span class="type">Writer</span> { <span class="title">runWriter</span> :: (<span class="title">a</span>, <span class="title">w</span>) }</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Monoid</span> <span class="title">w</span>) =&gt; <span class="type">Monad</span> (<span class="type">Writer</span> <span class="title">w</span>) <span class="keyword">where</span></span> </span><br><span class="line">	return x = <span class="type">Writer</span> (x, mempty)</span><br><span class="line">	(<span class="type">Writer</span> (x, v)) &gt;&gt;= f = <span class="keyword">let</span> (<span class="type">Writer</span> (y, v')) = f x <span class="keyword">in</span> <span class="type">Writer</span> (y, v `mappend` v')</span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------------------------------------------------------</span></span><br><span class="line"><span class="keyword">import</span> Control.Monad.Writer</span><br><span class="line"></span><br><span class="line"><span class="title">logNumber</span> :: <span class="type">Int</span> -&gt; <span class="type">Writer</span> [<span class="type">String</span>] <span class="type">Int</span></span><br><span class="line"><span class="title">logNumber</span> x = <span class="type">Writer</span> (x, [<span class="string">"Got number: "</span> ++ show x])</span><br><span class="line"></span><br><span class="line"><span class="title">multWithLog</span> :: <span class="type">Writer</span> [<span class="type">String</span>] <span class="type">Int</span> </span><br><span class="line"><span class="title">multWithLog</span> = <span class="keyword">do</span></span><br><span class="line">	a &lt;- logNumber <span class="number">3</span></span><br><span class="line">	b &lt;- logNumber <span class="number">5</span></span><br><span class="line">	return ( a * b )</span><br><span class="line"></span><br><span class="line"><span class="title">gcd'</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Writer</span> [<span class="type">String</span>] <span class="type">Int</span></span><br><span class="line"><span class="title">gcd'</span> a b</span><br><span class="line">	| b == <span class="number">0</span> = <span class="keyword">do</span> </span><br><span class="line">		tell [<span class="string">"Finished with "</span> ++ show a]</span><br><span class="line">		return a</span><br><span class="line">	| otherwise = <span class="keyword">do</span> </span><br><span class="line">		tell [show a ++ <span class="string">" mod "</span> ++ show b ++ <span class="string">" = "</span> ++ show (a `mod` b)]</span><br><span class="line">		gcd' b (a `mod` b)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; runWriter multWithLog </span><br><span class="line">(<span class="number">15</span>,[<span class="string">"Got number: 3"</span>,<span class="string">"Got number: 5"</span>]) </span><br><span class="line"><span class="title">ghci</span>&gt; mapM_ putStrLn $ snd $ runWriter (gcd' <span class="number">8</span> <span class="number">3</span>) </span><br><span class="line"><span class="number">8</span> mod <span class="number">3</span> = <span class="number">2</span> </span><br><span class="line"><span class="number">3</span> mod <span class="number">2</span> = <span class="number">1</span> </span><br><span class="line"><span class="number">2</span> mod <span class="number">1</span> = <span class="number">0</span> </span><br><span class="line"><span class="type">Finished</span> with <span class="number">1</span> </span><br></pre></td></tr></tbody></table></figure>
<h3 id="the-apply-monad">The apply monad</h3>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span> </span><br><span class="line">	return x = \_ -&gt; x</span><br><span class="line">	h &gt;&gt;= f = \w -&gt; f (h w) w</span><br><span class="line"></span><br><span class="line"><span class="title">addStuff</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">addStuff</span> = <span class="keyword">do</span> </span><br><span class="line">	a &lt;- (*<span class="number">2</span>)</span><br><span class="line">	b &lt;- (+<span class="number">10</span>)</span><br><span class="line">	reutrn (a + b)</span><br><span class="line"></span><br><span class="line"><span class="title">addStuff</span> <span class="number">3</span> == <span class="number">19</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="stateful-computations">Stateful computations</h3>
<figure class="highlight haskell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">State</span> s a = <span class="type">State</span> { <span class="title">runState</span> :: <span class="title">s</span> -&gt; (<span class="title">a</span>, <span class="title">s</span>) }</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> (<span class="type">State</span> <span class="title">s</span>) <span class="keyword">where</span></span> </span><br><span class="line">	return x = <span class="type">State</span> $ \s -&gt; (x, s)</span><br><span class="line">	(<span class="type">State</span> h) &gt;&gt;= f = <span class="type">State</span> $ \s -&gt; <span class="keyword">let</span> (a, newState) = h s</span><br><span class="line">		                                (<span class="type">State</span> g) = f a</span><br><span class="line">									<span class="keyword">in</span> g newState</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -------------------------------------------------------- </span></span><br><span class="line"><span class="keyword">import</span> Control.Monad.State </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Stack</span> = [<span class="type">Int</span>]</span></span><br><span class="line"><span class="title">pop</span> :: <span class="type">State</span> <span class="type">Stack</span> <span class="type">Int</span></span><br><span class="line"><span class="title">pop</span> = <span class="type">State</span> $ \(x:xs) -&gt; (x, xs)</span><br><span class="line"></span><br><span class="line"><span class="title">push</span> :: <span class="type">Int</span> -&gt; <span class="type">State</span> <span class="type">Stack</span> ()</span><br><span class="line"><span class="title">push</span> a = <span class="type">State</span> $ \xs -&gt; ((), a:xs)</span><br><span class="line"></span><br><span class="line"><span class="title">stackManip</span> :: <span class="type">State</span> <span class="type">Stack</span> <span class="type">Int</span></span><br><span class="line"><span class="title">stackManip</span> = <span class="keyword">do</span> </span><br><span class="line">	a &lt;- pop</span><br><span class="line">	<span class="keyword">if</span> a == <span class="number">5</span></span><br><span class="line">		<span class="keyword">then</span> push <span class="number">5</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">do</span></span><br><span class="line">			push <span class="number">3</span></span><br><span class="line">			push <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; runState stackStuff [<span class="number">9</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">((),[<span class="number">8</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>])</span><br></pre></td></tr></tbody></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Programming/" rel="tag"># Programming</a>
              <a href="/tags/Haskell/" rel="tag"># Haskell</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/multivariable_calculus_cheatsheet/" rel="prev" title="Multivariable Calculus Cheatsheet">
                  <i class="fa fa-angle-left"></i> Multivariable Calculus Cheatsheet
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/git-references/" rel="next" title="Simple git references">
                  Simple git references <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
     
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-cat"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yue Jiao</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">693k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">10:30</span>
  </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener external nofollow noreferrer" target="_blank">Hexo</a> &amp; <a href="https://theme-next.js.org/" rel="noopener external nofollow noreferrer" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>



<script src="/bundle.js"></script></body></html>